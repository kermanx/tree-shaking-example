function _mergeNamespaces(n, m) {
	m.forEach(function(e) {
		e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
			if (k !== "default" && !(k in n)) {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function() {
						return e[k];
					}
				});
			}
		});
	});
	return Object.freeze(n);
}
function getDefaultExportFromCjs(x) {
	return x;
}
var react = {};
var react_production = {};
function requireReact_production() {
	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	function getIteratorFn(maybeIterable) {
		if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		maybeIterable = maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
		return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var ReactNoopUpdateQueue = {
		isMounted: function() {
			return false;
		},
		enqueueForceUpdate: function() {},
		enqueueReplaceState: function() {},
		enqueueSetState: function() {}
	}, assign = Object.assign, emptyObject = {};
	function Component(props, context, updater) {
		this.props = props;
		this.context = context;
		this.refs = emptyObject;
		this.updater = updater || ReactNoopUpdateQueue;
	}
	Component.prototype.isReactComponent = {};
	Component.prototype.setState = function(partialState, callback) {
		if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
		this.updater.enqueueSetState(this, partialState, callback, "setState");
	};
	Component.prototype.forceUpdate = function(callback) {
		this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
	};
	function ComponentDummy() {}
	ComponentDummy.prototype = Component.prototype;
	function PureComponent(props, context, updater) {
		this.props = props;
		this.context = context;
		this.refs = emptyObject;
		this.updater = updater || ReactNoopUpdateQueue;
	}
	var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
	pureComponentPrototype.constructor = PureComponent;
	assign(pureComponentPrototype, Component.prototype);
	pureComponentPrototype.isPureReactComponent = true;
	var isArrayImpl = Array.isArray;
	function noop() {}
	var ReactSharedInternals = {
		H: null,
		A: null,
		T: null,
		S: null
	}, hasOwnProperty = Object.prototype.hasOwnProperty;
	function ReactElement(type, key, props) {
		var refProp = props.ref;
		return {
			$$typeof: REACT_ELEMENT_TYPE,
			type,
			key,
			ref: void 0 !== refProp ? refProp : null,
			props
		};
	}
	function cloneAndReplaceKey(oldElement, newKey) {
		return ReactElement(oldElement.type, newKey, oldElement.props);
	}
	function isValidElement(object) {
		return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function escape(key) {
		var escaperLookup = {
			"=": "=0",
			":": "=2"
		};
		return "$" + key.replace(/[=:]/g, function(match) {
			return escaperLookup[match];
		});
	}
	var userProvidedKeyEscapeRegex = /\/+/g;
	function getElementKey(element, index) {
		return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
	}
	function resolveThenable(thenable) {
		switch (thenable.status) {
			case "fulfilled": return thenable.value;
			case "rejected": throw thenable.reason;
			default: switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
				"pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
			}, function(error) {
				"pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
			})), thenable.status) {
				case "fulfilled": return thenable.value;
				case "rejected": throw thenable.reason;
			}
		}
		throw thenable;
	}
	function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
		var type = typeof children;
		if ("undefined" === type || "boolean" === type) children = null;
		var invokeCallback = false;
		if (null === children) invokeCallback = true;
		else switch (type) {
			case "bigint":
			case "string":
			case "number":
				invokeCallback = true;
				break;
			case "object": switch (children.$$typeof) {
				case REACT_ELEMENT_TYPE:
				case REACT_PORTAL_TYPE:
					invokeCallback = true;
					break;
				case REACT_LAZY_TYPE: return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
			}
		}
		if (invokeCallback) return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
			return c;
		})) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1;
		invokeCallback = 0;
		var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
		if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
		else if (i = getIteratorFn(children), "function" === typeof i) for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
		else if ("object" === type) {
			if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
			array = String(children);
			throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
		}
		return invokeCallback;
	}
	function mapChildren(children, func, context) {
		if (null == children) return children;
		var result = [], count = 0;
		mapIntoArray(children, result, "", "", function(child) {
			return func.call(context, child, count++);
		});
		return result;
	}
	function lazyInitializer(payload) {
		if (-1 === payload._status) {
			var ctor = payload._result;
			ctor = ctor();
			ctor.then(function(moduleObject) {
				if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
			}, function(error) {
				if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
			});
			-1 === payload._status && (payload._status = 0, payload._result = ctor);
		}
		if (1 === payload._status) return payload._result.default;
		throw payload._result;
	}
	var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
		if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
			var event = new window.ErrorEvent("error", {
				bubbles: true,
				cancelable: true,
				message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
				error
			});
			if (!window.dispatchEvent(event)) return;
		} else if ("object" === typeof process && "function" === typeof process.emit) {
			process.emit("uncaughtException", error);
			return;
		}
		console.error(error);
	}, Children = {
		map: mapChildren,
		forEach: function(children, forEachFunc, forEachContext) {
			mapChildren(children, function() {
				forEachFunc.apply(this, arguments);
			}, forEachContext);
		},
		count: function(children) {
			var n = 0;
			mapChildren(children, function() {
				n++;
			});
			return n;
		},
		toArray: function(children) {
			return mapChildren(children, function(child) {
				return child;
			}) || [];
		},
		only: function(children) {
			if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
			return children;
		}
	};
	react_production.Activity = REACT_ACTIVITY_TYPE;
	react_production.Children = Children;
	react_production.Component = Component;
	react_production.Fragment = REACT_FRAGMENT_TYPE;
	react_production.Profiler = REACT_PROFILER_TYPE;
	react_production.PureComponent = PureComponent;
	react_production.StrictMode = REACT_STRICT_MODE_TYPE;
	react_production.Suspense = REACT_SUSPENSE_TYPE;
	react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
	react_production.__COMPILER_RUNTIME = {
		__proto__: null,
		c: function(size) {
			return ReactSharedInternals.H.useMemoCache(size);
		}
	};
	react_production.cache = function(fn) {
		return function() {
			return fn.apply(null, arguments);
		};
	};
	react_production.cacheSignal = function() {
		return null;
	};
	react_production.cloneElement = function(element, config, children) {
		if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
		var props = assign({}, element.props), key = element.key;
		if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
		var propName = arguments.length - 2;
		if (1 === propName) props.children = children;
		else if (1 < propName) {
			for (var childArray = Array(propName), i = 0; i < propName; i++) childArray[i] = arguments[i + 2];
			props.children = childArray;
		}
		return ReactElement(element.type, key, props);
	};
	react_production.createContext = function(defaultValue) {
		defaultValue = {
			$$typeof: REACT_CONTEXT_TYPE,
			_currentValue: defaultValue,
			_currentValue2: defaultValue,
			_threadCount: 0
		};
		defaultValue.Provider = defaultValue;
		defaultValue.Consumer = {
			$$typeof: REACT_CONSUMER_TYPE,
			_context: defaultValue
		};
		return defaultValue;
	};
	react_production.createElement = function(type, config, children) {
		var propName, props = {}, key = null;
		if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
		var childrenLength = arguments.length - 2;
		if (1 === childrenLength) props.children = children;
		else if (1 < childrenLength) {
			for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 2];
			props.children = childArray;
		}
		if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) void 0 === props[propName] && (props[propName] = childrenLength[propName]);
		return ReactElement(type, key, props);
	};
	react_production.createRef = function() {
		return { current: null };
	};
	react_production.forwardRef = function(render) {
		return {
			$$typeof: REACT_FORWARD_REF_TYPE,
			render
		};
	};
	react_production.isValidElement = isValidElement;
	react_production.lazy = function(ctor) {
		return {
			$$typeof: REACT_LAZY_TYPE,
			_payload: {
				_status: -1,
				_result: ctor
			},
			_init: lazyInitializer
		};
	};
	react_production.memo = function(type, compare) {
		return {
			$$typeof: REACT_MEMO_TYPE,
			type,
			compare: void 0 === compare ? null : compare
		};
	};
	react_production.startTransition = function(scope) {
		var prevTransition = ReactSharedInternals.T, currentTransition = {};
		ReactSharedInternals.T = currentTransition;
		try {
			var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
			null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
			"object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
		} catch (error) {
			reportGlobalError(error);
		} finally {
			null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
		}
	};
	react_production.unstable_useCacheRefresh = function() {
		return ReactSharedInternals.H.useCacheRefresh();
	};
	react_production.use = function(usable) {
		return ReactSharedInternals.H.use(usable);
	};
	react_production.useActionState = function(action, initialState, permalink) {
		return ReactSharedInternals.H.useActionState(action, initialState, permalink);
	};
	react_production.useCallback = function(callback, deps) {
		return ReactSharedInternals.H.useCallback(callback, deps);
	};
	react_production.useContext = function(Context) {
		return ReactSharedInternals.H.useContext(Context);
	};
	react_production.useDebugValue = function() {};
	react_production.useDeferredValue = function(value, initialValue) {
		return ReactSharedInternals.H.useDeferredValue(value, initialValue);
	};
	react_production.useEffect = function(create, deps) {
		return ReactSharedInternals.H.useEffect(create, deps);
	};
	react_production.useEffectEvent = function(callback) {
		return ReactSharedInternals.H.useEffectEvent(callback);
	};
	react_production.useId = function() {
		return ReactSharedInternals.H.useId();
	};
	react_production.useImperativeHandle = function(ref, create, deps) {
		return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
	};
	react_production.useInsertionEffect = function(create, deps) {
		return ReactSharedInternals.H.useInsertionEffect(create, deps);
	};
	react_production.useLayoutEffect = function(create, deps) {
		return ReactSharedInternals.H.useLayoutEffect(create, deps);
	};
	react_production.useMemo = function(create, deps) {
		return ReactSharedInternals.H.useMemo(create, deps);
	};
	react_production.useOptimistic = function(passthrough, reducer) {
		return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
	};
	react_production.useReducer = function(reducer, initialArg, init) {
		return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
	};
	react_production.useRef = function(initialValue) {
		return ReactSharedInternals.H.useRef(initialValue);
	};
	react_production.useState = function(initialState) {
		return ReactSharedInternals.H.useState(initialState);
	};
	react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
		return ReactSharedInternals.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
	};
	react_production.useTransition = function() {
		return ReactSharedInternals.H.useTransition();
	};
	react_production.version = "19.2.4";
	return react_production;
}
var hasRequiredReact;
function requireReact() {
	if (hasRequiredReact) return react.a;
	hasRequiredReact = 1;
	{
		react.a = requireReact_production();
	}
	return react.a;
}
var reactExports = requireReact();
var React = getDefaultExportFromCjs(reactExports);
var React$1 = _mergeNamespaces({
	__proto__: null,
	default: React
}, [reactExports]);
var client = { a: {} };
var reactDomClient_production = {};
var scheduler = {};
var scheduler_production = {};
function requireScheduler_production() {
	(function(exports$1) {
		function push(heap, node) {
			var index = heap.length;
			heap.push(node);
			a: for (; 0 < index;) {
				var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
				if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
				else break a;
			}
		}
		function peek(heap) {
			return 0 === heap.length ? null : heap[0];
		}
		function pop(heap) {
			if (0 === heap.length) return;
			var first = heap[0], last = heap.pop();
			if (last !== first) {
				heap[0] = last;
				a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;) {
					var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
					if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
					else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;
					else break a;
				}
			}
			return;
		}
		function compare(a, b) {
			var diff = a.sortIndex - b.sortIndex;
			return 0 !== diff ? diff : a.id - b.id;
		}
		exports$1.a = void 0;
		if ("object" === typeof performance && "function" === typeof performance.now) {
			var localPerformance = performance;
			exports$1.a = function() {
				return localPerformance.now();
			};
		} else {
			var localDate = Date, initialTime = localDate.now();
			exports$1.a = function() {
				return localDate.now() - initialTime;
			};
		}
		var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = setTimeout, localClearTimeout = clearTimeout, localSetImmediate = setImmediate;
		function advanceTimers(currentTime) {
			for (var timer = peek(timerQueue); null !== timer;) {
				if (null === timer.callback) pop(timerQueue);
				else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
				else break;
				timer = peek(timerQueue);
			}
		}
		function handleTimeout(currentTime) {
			isHostTimeoutScheduled = false;
			advanceTimers(currentTime);
			if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
			else {
				var firstTimer = peek(timerQueue);
				null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
			}
		}
		var isMessageLoopRunning = false, taskTimeoutID = -1, startTime = -1;
		function shouldYieldToHost() {
			return needsPaint ? true : exports$1.a() - startTime < 5 ? false : true;
		}
		function performWorkUntilDeadline() {
			needsPaint = false;
			if (isMessageLoopRunning) {
				var currentTime = exports$1.a();
				startTime = currentTime;
				var hasMoreWork = true;
				try {
					a: {
						isHostCallbackScheduled = false;
						isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
						isPerformingWork = true;
						var previousPriorityLevel = currentPriorityLevel;
						try {
							b: {
								advanceTimers(currentTime);
								for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());) {
									var callback = currentTask.callback;
									if ("function" === typeof callback) {
										currentTask.callback = null;
										currentPriorityLevel = currentTask.priorityLevel;
										var continuationCallback = callback(currentTask.expirationTime <= currentTime);
										currentTime = exports$1.a();
										if ("function" === typeof continuationCallback) {
											currentTask.callback = continuationCallback;
											advanceTimers(currentTime);
											hasMoreWork = true;
											break b;
										}
										currentTask === peek(taskQueue) && pop(taskQueue);
										advanceTimers(currentTime);
									} else pop(taskQueue);
									currentTask = peek(taskQueue);
								}
								if (null !== currentTask) hasMoreWork = true;
								else {
									var firstTimer = peek(timerQueue);
									null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
									hasMoreWork = false;
								}
							}
							break a;
						} finally {
							currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
						}
						hasMoreWork = void 0;
					}
				} finally {
					hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
				}
			}
		}
		var schedulePerformWorkUntilDeadline;
		{
			schedulePerformWorkUntilDeadline = function() {
				localSetImmediate(performWorkUntilDeadline);
			};
		}
		function requestHostTimeout(callback, ms) {
			taskTimeoutID = localSetTimeout(function() {
				callback(exports$1.a());
			}, ms);
		}
		exports$1.h = function(task) {
			task.callback = null;
		};
		exports$1.j = function() {
			return currentPriorityLevel;
		};
		exports$1.l = function() {
			needsPaint = true;
		};
		exports$1.n = function(priorityLevel, callback, options) {
			var currentTime = exports$1.a();
			"object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
			switch (priorityLevel) {
				case 1:
					var timeout = -1;
					break;
				case 2:
					timeout = 250;
					break;
				case 5:
					timeout = 1073741823;
					break;
				case 4:
					timeout = 1e4;
					break;
				default: timeout = 5e3;
			}
			timeout = options + timeout;
			priorityLevel = {
				id: taskIdCounter++,
				callback,
				priorityLevel,
				startTime: options,
				expirationTime: timeout,
				sortIndex: -1
			};
			options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
			return priorityLevel;
		};
		exports$1.o = shouldYieldToHost;
	})(scheduler_production);
	return scheduler_production;
}
function requireScheduler() {
	{
		scheduler.a = requireScheduler_production();
	}
	return scheduler.a;
}
var reactDom = {};
var reactDom_production = {};
function requireReactDom_production() {
	var React = requireReact();
	function formatProdErrorMessage(code) {
		var url = "https://react.dev/errors/" + 299;
		if (1 < arguments.length) {
			url += "?args[]=" + encodeURIComponent(arguments[1]);
			for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
		}
		return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	}
	var Internals = { a: 0 }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
	function createPortal$1(children, containerInfo, implementation) {
		var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
		return {
			$$typeof: REACT_PORTAL_TYPE,
			key: null == key ? null : "" + key,
			children,
			containerInfo,
			implementation
		};
	}
	var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
	reactDom_production.a = Internals;
	reactDom_production.b = function(children, container) {
		var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
		if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType) throw Error(formatProdErrorMessage(299));
		return createPortal$1(children, container, null, key);
	};
	reactDom_production.c = function(fn) {
		var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.a;
		try {
			{
				ReactSharedInternals.T = null, Internals.a = 2;
				return fn();
			}
		} finally {
			ReactSharedInternals.T = previousTransition, Internals.a = previousUpdatePriority, Internals.b.a();
		}
	};
	reactDom_production.k = function(fn) {
		return fn();
	};
	return reactDom_production;
}
var hasRequiredReactDom;
function requireReactDom() {
	if (hasRequiredReactDom) return reactDom.a;
	hasRequiredReactDom = 1;
	function checkDCE() {
		/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
		if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
			return;
		}
		try {
			// Verify that the code above has been dead code eliminated (DCE'd).
			__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
		} catch (err) {
			// DevTools shouldn't crash React, no matter what.
			// We should still report in case we break this code.
			console.error(err);
		}
	}
	{
		// DCE check should happen before ReactDOM bundle executes so that
		// DevTools can report bad minification during injection.
		checkDCE();
		reactDom.a = requireReactDom_production();
	}
	return reactDom.a;
}
function requireReactDomClient_production() {
	var Scheduler = requireScheduler(), React = requireReact(), ReactDOM = requireReactDom();
	function formatProdErrorMessage(code) {
		var url = "https://react.dev/errors/" + code;
		if (1 < arguments.length) {
			url += "?args[]=" + encodeURIComponent(arguments[1]);
			for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
		}
		return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	}
	function isValidContainer(node) {
		return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
	}
	function getNearestMountedFiber(fiber) {
		var node = fiber, nearestMounted = fiber;
		if (fiber.alternate) for (; node.return;) node = node.return;
		else {
			fiber = node;
			do
				node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
			while (fiber);
		}
		return 3 === node.tag ? nearestMounted : null;
	}
	function getSuspenseInstanceFromFiber(fiber) {
		if (13 === fiber.tag) {
			var suspenseState = fiber.memoizedState;
			null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
			if (null !== suspenseState) return suspenseState.dehydrated;
		}
		return null;
	}
	function getActivityInstanceFromFiber(fiber) {
		if (31 === fiber.tag) {
			var activityState = fiber.memoizedState;
			null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
			if (null !== activityState) return activityState.dehydrated;
		}
		return null;
	}
	var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
	var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
	var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
	var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	function getIteratorFn(maybeIterable) {
		if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		maybeIterable = maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
		return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
	function getComponentNameFromType(type) {
		if (null == type) return null;
		if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
		if ("string" === typeof type) return type;
		switch (type) {
			case REACT_FRAGMENT_TYPE: return "Fragment";
			case REACT_PROFILER_TYPE: return "Profiler";
			case REACT_STRICT_MODE_TYPE: return "StrictMode";
			case REACT_SUSPENSE_TYPE: return "Suspense";
			case REACT_SUSPENSE_LIST_TYPE: return "SuspenseList";
			case REACT_ACTIVITY_TYPE: return "Activity";
		}
		if ("object" === typeof type) switch (type.$$typeof) {
			case REACT_PORTAL_TYPE: return "Portal";
			case REACT_CONTEXT_TYPE: return type.displayName || "Context";
			case REACT_CONSUMER_TYPE: return (type._context.displayName || "Context") + ".Consumer";
			case REACT_FORWARD_REF_TYPE:
				var innerType = type.render;
				type = type.displayName;
				type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
				return type;
			case REACT_MEMO_TYPE: return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
			case REACT_LAZY_TYPE:
				innerType = type._payload;
				type = type._init;
				try {
					return getComponentNameFromType(type(innerType));
				} catch {}
		}
		return null;
	}
	var isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.a, sharedNotPendingObject = {
		pending: false,
		data: null,
		method: null,
		action: null
	}, valueStack = [], index = -1;
	function createCursor(defaultValue) {
		return { current: defaultValue };
	}
	function pop(cursor) {
		0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
	}
	function push(cursor, value) {
		index++;
		valueStack[index] = cursor.current;
		cursor.current = value;
	}
	var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
	function pushHostContainer(fiber, nextRootInstance) {
		push(rootInstanceStackCursor, nextRootInstance);
		push(contextFiberStackCursor, fiber);
		push(contextStackCursor, null);
		switch (nextRootInstance.nodeType) {
			case 9:
			case 11:
				fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
				break;
			default: if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI) nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
			else switch (fiber) {
				case "svg":
					fiber = 1;
					break;
				case "math":
					fiber = 2;
					break;
				default: fiber = 0;
			}
		}
		pop(contextStackCursor);
		push(contextStackCursor, fiber);
	}
	function popHostContainer() {
		pop(contextStackCursor);
		pop(contextFiberStackCursor);
		pop(rootInstanceStackCursor);
	}
	function pushHostContext(fiber) {
		null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
		var context = contextStackCursor.current;
		var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
		context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
	}
	function popHostContext(fiber) {
		contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
		hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
	}
	var prefix, suffix;
	function describeBuiltInComponentFrame(name) {
		if (void 0 === prefix) try {
			throw Error();
		} catch (x) {
			var match = x.stack.trim().match(/\n( *(at )?)/);
			prefix = match && match[1] || "";
			suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
		}
		return "\n" + prefix + name + suffix;
	}
	var reentry = false;
	function describeNativeComponentFrame(fn, construct) {
		if (!fn || reentry) return "";
		reentry = true;
		var previousPrepareStackTrace;
		try {
			var RunInRootFrame = { DetermineComponentFrameRoot: function() {
				try {
					if (construct) {
						var Fake = function() {
							throw Error();
						};
						Object.defineProperty(Fake.prototype, "props", { set: function() {
							throw Error();
						} });
						if (Reflect.construct) {
							try {
								Reflect.construct(Fake, []);
							} catch (x) {
								var control = x;
							}
							Reflect.construct(fn, [], Fake);
						} else {
							try {
								Fake.call();
							} catch (x$1) {
								control = x$1;
							}
							fn.call(Fake.prototype);
						}
					} else {
						try {
							throw Error();
						} catch (x$2) {
							control = x$2;
						}
						(Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
					}
				} catch (sample) {
					if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
				}
				return [null, null];
			} };
			RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
			var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
			namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
			var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
			if (sampleStack && controlStack) {
				var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
				for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");) RunInRootFrame++;
				for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
				if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length) for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];) namePropDescriptor--;
				for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--) if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
					if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
						do
							if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
								var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
								fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
								return frame;
							}
						while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
					}
					break;
				}
			}
		} finally {
			reentry = false;
		}
		return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
	}
	function describeFiber(fiber, childFiber) {
		switch (fiber.tag) {
			case 26:
			case 27:
			case 5: return describeBuiltInComponentFrame(fiber.type);
			case 16: return describeBuiltInComponentFrame("Lazy");
			case 13: return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
			case 19: return describeBuiltInComponentFrame("SuspenseList");
			case 0:
			case 15: return describeNativeComponentFrame(fiber.type, false);
			case 11: return describeNativeComponentFrame(fiber.type.render, false);
			case 1: return describeNativeComponentFrame(fiber.type, true);
			case 31: return describeBuiltInComponentFrame("Activity");
			default: return "";
		}
	}
	function getStackByFiberInDevAndProd(workInProgress) {
		try {
			var info = "", previous = null;
			do
				info += describeFiber(workInProgress, previous), previous = workInProgress, workInProgress = workInProgress.return;
			while (workInProgress);
			return info;
		} catch (x) {
			return "\nError generating stack: " + x.message + "\n" + x.stack;
		}
	}
	var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.n, cancelCallback$1 = Scheduler.h, shouldYield = Scheduler.o, requestPaint = Scheduler.l, now = Scheduler.a, getCurrentPriorityLevel = Scheduler.j, rendererID = null, injectedHook = null;
	function setIsStrictModeForDevtools(newIsStrictMode) {
		if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
			injectedHook.setStrictMode(rendererID, newIsStrictMode);
		} catch {}
	}
	var clz32 = Math.clz32;
	var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
	function getHighestPriorityLanes(lanes) {
		var pendingSyncLanes = lanes & 42;
		if (0 !== pendingSyncLanes) return pendingSyncLanes;
		switch (lanes & -lanes) {
			case 1: return 1;
			case 2: return 2;
			case 4: return 4;
			case 8: return 8;
			case 16: return 16;
			case 32: return 32;
			case 64: return 64;
			case 128: return 128;
			case 256:
			case 512:
			case 1024:
			case 2048:
			case 4096:
			case 8192:
			case 16384:
			case 32768:
			case 65536:
			case 131072: return lanes & 261888;
			case 262144:
			case 524288:
			case 1048576:
			case 2097152: return lanes & 3932160;
			case 4194304:
			case 8388608:
			case 16777216:
			case 33554432: return lanes & 62914560;
			case 67108864: return 67108864;
			case 134217728: return 134217728;
			case 268435456: return 268435456;
			case 536870912: return 536870912;
			case 1073741824: return 0;
			default: return lanes;
		}
	}
	function getNextLanes(root, wipLanes, rootHasPendingCommit) {
		var pendingLanes = root.pendingLanes;
		if (0 === pendingLanes) return 0;
		var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
		root = root.warmLanes;
		var nonIdlePendingLanes = pendingLanes & 134217727;
		0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
		return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
	}
	function checkIfRootIsPrerendering(root, renderLanes) {
		return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);
	}
	function computeExpirationTime(lane, currentTime) {
		switch (lane) {
			case 1:
			case 2:
			case 4:
			case 8:
			case 64: return currentTime + 250;
			case 16:
			case 32:
			case 128:
			case 256:
			case 512:
			case 1024:
			case 2048:
			case 4096:
			case 8192:
			case 16384:
			case 32768:
			case 65536:
			case 131072:
			case 262144:
			case 524288:
			case 1048576:
			case 2097152: return currentTime + 5e3;
			case 4194304:
			case 8388608:
			case 16777216:
			case 33554432: return -1;
			case 67108864:
			case 134217728:
			case 268435456:
			case 536870912:
			case 1073741824: return -1;
			default: return -1;
		}
	}
	function claimNextRetryLane() {
		var lane = nextRetryLane;
		nextRetryLane <<= 1;
		0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
		return lane;
	}
	function createLaneMap(initial) {
		for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
		return laneMap;
	}
	function markRootUpdated$1(root, updateLane) {
		root.pendingLanes |= updateLane;
		268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
	}
	function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
		var previouslyPendingLanes = root.pendingLanes;
		root.pendingLanes = remainingLanes;
		root.suspendedLanes = 0;
		root.pingedLanes = 0;
		root.warmLanes = 0;
		root.expiredLanes &= remainingLanes;
		root.entangledLanes &= remainingLanes;
		root.errorRecoveryDisabledLanes &= remainingLanes;
		root.shellSuspendCounter = 0;
		var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;
		for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;) {
			var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
			entanglements[index$7] = 0;
			expirationTimes[index$7] = -1;
			var hiddenUpdatesForLane = hiddenUpdates[index$7];
			if (null !== hiddenUpdatesForLane) for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
				var update = hiddenUpdatesForLane[index$7];
				null !== update && (update.lane &= -536870913);
			}
			remainingLanes &= ~lane;
		}
		0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
		0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
	}
	function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
		root.pendingLanes |= spawnedLane;
		root.suspendedLanes &= ~spawnedLane;
		var spawnedLaneIndex = 31 - clz32(spawnedLane);
		root.entangledLanes |= spawnedLane;
		root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
	}
	function markRootEntangled(root, entangledLanes) {
		var rootEntangledLanes = root.entangledLanes |= entangledLanes;
		for (root = root.entanglements; rootEntangledLanes;) {
			var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
			lane & entangledLanes | root[index$8] & entangledLanes && (root[index$8] |= entangledLanes);
			rootEntangledLanes &= ~lane;
		}
	}
	function getBumpedLaneForHydration(root, renderLanes) {
		var renderLane = renderLanes & -renderLanes;
		renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
		return 0 !== (renderLane & (root.suspendedLanes | renderLanes)) ? 0 : renderLane;
	}
	function getBumpedLaneForHydrationByLane(lane) {
		switch (lane) {
			case 2:
				lane = 1;
				break;
			case 8:
				lane = 4;
				break;
			case 32:
				lane = 16;
				break;
			case 256:
			case 512:
			case 1024:
			case 2048:
			case 4096:
			case 8192:
			case 16384:
			case 32768:
			case 65536:
			case 131072:
			case 262144:
			case 524288:
			case 1048576:
			case 2097152:
			case 4194304:
			case 8388608:
			case 16777216:
			case 33554432:
				lane = 128;
				break;
			case 268435456:
				lane = 134217728;
				break;
			default: lane = 0;
		}
		return lane;
	}
	function lanesToEventPriority(lanes) {
		lanes &= -lanes;
		return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
	}
	function resolveUpdatePriority() {
		var updatePriority = ReactDOMSharedInternals.a;
		if (0 !== updatePriority) return updatePriority;
		updatePriority = window.event;
		return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
	}
	var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
	function detachDeletedInstance(node) {
		delete node[internalInstanceKey];
		delete node[internalPropsKey];
		delete node[internalEventHandlersKey];
		delete node[internalEventHandlerListenersKey];
		delete node[internalEventHandlesSetKey];
	}
	function getClosestInstanceFromNode(targetNode) {
		var targetInst = targetNode[internalInstanceKey];
		if (targetInst) return targetInst;
		for (var parentNode = targetNode.parentNode; parentNode;) {
			if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
				parentNode = targetInst.alternate;
				if (null !== targetInst.child || null !== parentNode && null !== parentNode.child) for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode;) {
					if (parentNode = targetNode[internalInstanceKey]) return parentNode;
					targetNode = getParentHydrationBoundary(targetNode);
				}
				return targetInst;
			}
			targetNode = parentNode;
			parentNode = targetNode.parentNode;
		}
		return null;
	}
	function getInstanceFromNode(node) {
		if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
			var tag = node.tag;
			if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag) return node;
		}
		return null;
	}
	function getNodeFromInstance(inst) {
		var tag = inst.tag;
		if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
		throw Error(formatProdErrorMessage(33));
	}
	function getResourcesFromRoot(root) {
		var resources = root[internalRootNodeResourcesKey];
		resources || (resources = root[internalRootNodeResourcesKey] = {
			hoistableStyles: new Map(),
			hoistableScripts: new Map()
		});
		return resources;
	}
	function markNodeAsHoistable(node) {
		node[internalHoistableMarker] = true;
	}
	var allNativeEvents = new Set(), registrationNameDependencies = {};
	function registerTwoPhaseEvent(registrationName, dependencies) {
		registerDirectEvent(registrationName, dependencies);
		registerDirectEvent(registrationName + "Capture", dependencies);
	}
	function registerDirectEvent(registrationName, dependencies) {
		registrationNameDependencies[registrationName] = dependencies;
		for (registrationName = 0; registrationName < dependencies.length; registrationName++) allNativeEvents.add(dependencies[registrationName]);
	}
	var VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
	function isAttributeNameSafe(attributeName) {
		if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return true;
		if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
		if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = true;
		illegalAttributeNameCache[attributeName] = true;
		return false;
	}
	function setValueForAttribute(node, name, value) {
		if (isAttributeNameSafe(name)) if (null === value) node.removeAttribute(name);
		else {
			switch (typeof value) {
				case "undefined":
				case "function":
				case "symbol":
					node.removeAttribute(name);
					return;
				case "boolean":
					var prefix$10 = name.toLowerCase().slice(0, 5);
					if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
						node.removeAttribute(name);
						return;
					}
			}
			node.setAttribute(name, "" + value);
		}
	}
	function setValueForKnownAttribute(node, name, value) {
		if (null === value) node.removeAttribute(name);
		else {
			switch (typeof value) {
				case "undefined":
				case "function":
				case "symbol":
				case "boolean":
					node.removeAttribute(name);
					return;
			}
			node.setAttribute(name, "" + value);
		}
	}
	function setValueForNamespacedAttribute(node, namespace, name, value) {
		if (null === value) node.removeAttribute(name);
		else {
			switch (typeof value) {
				case "undefined":
				case "function":
				case "symbol":
				case "boolean":
					node.removeAttribute(name);
					return;
			}
			node.setAttributeNS(namespace, name, "" + value);
		}
	}
	function getToStringValue(value) {
		switch (typeof value) {
			case "bigint":
			case "boolean":
			case "number":
			case "string":
			case "undefined": return value;
			case "object": return value;
			default: return "";
		}
	}
	function isCheckable(elem) {
		var type = elem.type;
		return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
	}
	function trackValueOnNode(node, valueField, currentValue) {
		var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
		if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
			var get = descriptor.get, set = descriptor.set;
			Object.defineProperty(node, valueField, {
				configurable: true,
				get: function() {
					return get.call(this);
				},
				set: function(value) {
					currentValue = "" + value;
					set.call(this, value);
				}
			});
			Object.defineProperty(node, valueField, { enumerable: descriptor.enumerable });
			return {
				getValue: function() {
					return currentValue;
				},
				setValue: function(value) {
					currentValue = "" + value;
				},
				stopTracking: function() {
					node._valueTracker = null;
					delete node[valueField];
				}
			};
		}
	}
	function track(node) {
		if (!node._valueTracker) {
			var valueField = isCheckable(node) ? "checked" : "value";
			node._valueTracker = trackValueOnNode(node, valueField, "" + node[valueField]);
		}
	}
	function updateValueIfChanged(node) {
		if (!node) return false;
		var tracker = node._valueTracker;
		if (!tracker) return true;
		var lastValue = tracker.getValue();
		var value = "";
		node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
		node = value;
		return node !== lastValue ? (tracker.setValue(node), true) : false;
	}
	function getActiveElement(doc) {
		doc = doc || ("undefined" !== typeof document ? document : void 0);
		if ("undefined" === typeof doc) return null;
		try {
			return doc.activeElement || doc.body;
		} catch {
			return doc.body;
		}
	}
	var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
	function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
		return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {
			return "\\" + ch.charCodeAt(0).toString(16) + " ";
		});
	}
	function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
		element.name = "";
		null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
		if (null != value) if ("number" === type) {
			if (0 === value && "" === element.value || element.value != value) element.value = "" + getToStringValue(value);
		} else element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
		else "submit" !== type && "reset" !== type || element.removeAttribute("value");
		null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
		null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
		null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
		null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
	}
	function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
		null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
		if (null != value || null != defaultValue) {
			if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
				track(element);
				return;
			}
			defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
			value = null != value ? "" + getToStringValue(value) : defaultValue;
			isHydrating || value === element.value || (element.value = value);
			element.defaultValue = value;
		}
		checked = null != checked ? checked : defaultChecked;
		checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
		element.checked = isHydrating ? element.checked : !!checked;
		element.defaultChecked = !!checked;
		null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
		track(element);
	}
	function setDefaultValue(node, type, value) {
		"number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
	}
	function updateOptions(node, multiple, propValue, setDefaultSelected) {
		node = node.options;
		if (multiple) {
			multiple = {};
			for (var i = 0; i < propValue.length; i++) multiple["$" + propValue[i]] = true;
			for (propValue = 0; propValue < node.length; propValue++) i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
		} else {
			propValue = "" + getToStringValue(propValue);
			multiple = null;
			for (i = 0; i < node.length; i++) {
				if (node[i].value === propValue) {
					node[i].selected = true;
					setDefaultSelected && (node[i].defaultSelected = true);
					return;
				}
				null !== multiple || node[i].disabled || (multiple = node[i]);
			}
			null !== multiple && (multiple.selected = true);
		}
	}
	function updateTextarea(element, value, defaultValue) {
		if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
			element.defaultValue !== value && (element.defaultValue = value);
			return;
		}
		element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
	}
	function initTextarea(element, value, defaultValue, children) {
		if (null == value) {
			if (null != children) {
				if (null != defaultValue) throw Error(formatProdErrorMessage(92));
				if (isArrayImpl(children)) {
					if (1 < children.length) throw Error(formatProdErrorMessage(93));
					children = children[0];
				}
				defaultValue = children;
			}
			null == defaultValue && (defaultValue = "");
			value = defaultValue;
		}
		defaultValue = getToStringValue(value);
		element.defaultValue = defaultValue;
		children = element.textContent;
		children === defaultValue && "" !== children && null !== children && (element.value = children);
		track(element);
	}
	function setTextContent(node, text) {
		if (text) {
			var firstChild = node.firstChild;
			if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
				firstChild.nodeValue = text;
				return;
			}
		}
		node.textContent = text;
	}
	var unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
	function setValueForStyle(style, styleName, value) {
		var isCustomProperty = 0 === styleName.indexOf("--");
		null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style.setProperty(styleName, "") : "float" === styleName ? style.cssFloat = "" : style[styleName] = "" : isCustomProperty ? style.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style.cssFloat = value : style[styleName] = ("" + value).trim() : style[styleName] = value + "px";
	}
	function setValueForStyles(node, styles, prevStyles) {
		if (null != styles && "object" !== typeof styles) throw Error(formatProdErrorMessage(62));
		node = node.style;
		if (null != prevStyles) {
			for (var styleName in prevStyles) !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
			for (var styleName$16 in styles) styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
		} else for (var styleName$17 in styles) styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
	}
	function isCustomElement(tagName) {
		if (-1 === tagName.indexOf("-")) return false;
		switch (tagName) {
			case "annotation-xml":
			case "color-profile":
			case "font-face":
			case "font-face-src":
			case "font-face-uri":
			case "font-face-format":
			case "font-face-name":
			case "missing-glyph": return false;
			default: return true;
		}
	}
	var aliases = new Map([
		["acceptCharset", "accept-charset"],
		["htmlFor", "for"],
		["httpEquiv", "http-equiv"],
		["crossOrigin", "crossorigin"],
		["accentHeight", "accent-height"],
		["alignmentBaseline", "alignment-baseline"],
		["arabicForm", "arabic-form"],
		["baselineShift", "baseline-shift"],
		["capHeight", "cap-height"],
		["clipPath", "clip-path"],
		["clipRule", "clip-rule"],
		["colorInterpolation", "color-interpolation"],
		["colorInterpolationFilters", "color-interpolation-filters"],
		["colorProfile", "color-profile"],
		["colorRendering", "color-rendering"],
		["dominantBaseline", "dominant-baseline"],
		["enableBackground", "enable-background"],
		["fillOpacity", "fill-opacity"],
		["fillRule", "fill-rule"],
		["floodColor", "flood-color"],
		["floodOpacity", "flood-opacity"],
		["fontFamily", "font-family"],
		["fontSize", "font-size"],
		["fontSizeAdjust", "font-size-adjust"],
		["fontStretch", "font-stretch"],
		["fontStyle", "font-style"],
		["fontVariant", "font-variant"],
		["fontWeight", "font-weight"],
		["glyphName", "glyph-name"],
		["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
		["glyphOrientationVertical", "glyph-orientation-vertical"],
		["horizAdvX", "horiz-adv-x"],
		["horizOriginX", "horiz-origin-x"],
		["imageRendering", "image-rendering"],
		["letterSpacing", "letter-spacing"],
		["lightingColor", "lighting-color"],
		["markerEnd", "marker-end"],
		["markerMid", "marker-mid"],
		["markerStart", "marker-start"],
		["overlinePosition", "overline-position"],
		["overlineThickness", "overline-thickness"],
		["paintOrder", "paint-order"],
		["panose-1", "panose-1"],
		["pointerEvents", "pointer-events"],
		["renderingIntent", "rendering-intent"],
		["shapeRendering", "shape-rendering"],
		["stopColor", "stop-color"],
		["stopOpacity", "stop-opacity"],
		["strikethroughPosition", "strikethrough-position"],
		["strikethroughThickness", "strikethrough-thickness"],
		["strokeDasharray", "stroke-dasharray"],
		["strokeDashoffset", "stroke-dashoffset"],
		["strokeLinecap", "stroke-linecap"],
		["strokeLinejoin", "stroke-linejoin"],
		["strokeMiterlimit", "stroke-miterlimit"],
		["strokeOpacity", "stroke-opacity"],
		["strokeWidth", "stroke-width"],
		["textAnchor", "text-anchor"],
		["textDecoration", "text-decoration"],
		["textRendering", "text-rendering"],
		["transformOrigin", "transform-origin"],
		["underlinePosition", "underline-position"],
		["underlineThickness", "underline-thickness"],
		["unicodeBidi", "unicode-bidi"],
		["unicodeRange", "unicode-range"],
		["unitsPerEm", "units-per-em"],
		["vAlphabetic", "v-alphabetic"],
		["vHanging", "v-hanging"],
		["vIdeographic", "v-ideographic"],
		["vMathematical", "v-mathematical"],
		["vectorEffect", "vector-effect"],
		["vertAdvY", "vert-adv-y"],
		["vertOriginX", "vert-origin-x"],
		["vertOriginY", "vert-origin-y"],
		["wordSpacing", "word-spacing"],
		["writingMode", "writing-mode"],
		["xmlnsXlink", "xmlns:xlink"],
		["xHeight", "x-height"]
	]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
	function sanitizeURL(url) {
		return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
	}
	function noop$1() {}
	var currentReplayingEvent = null;
	function getEventTarget(nativeEvent) {
		nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
		nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
		return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
	}
	var restoreTarget = null, restoreQueue = null;
	function restoreStateOfTarget(target) {
		var internalInstance = getInstanceFromNode(target);
		if (internalInstance && (target = internalInstance.stateNode)) {
			var props = target[internalPropsKey] || null;
			a: switch (target = internalInstance.stateNode, internalInstance.type) {
				case "input":
					updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
					internalInstance = props.name;
					if ("radio" === props.type && null != internalInstance) {
						for (props = target; props.parentNode;) props = props.parentNode;
						props = props.querySelectorAll("input[name=\"" + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + "\"][type=\"radio\"]");
						for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
							var otherNode = props[internalInstance];
							if (otherNode !== target && otherNode.form === target.form) {
								var otherProps = otherNode[internalPropsKey] || null;
								if (!otherProps) throw Error(formatProdErrorMessage(90));
								updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
							}
						}
						for (internalInstance = 0; internalInstance < props.length; internalInstance++) otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
					}
					break a;
				case "textarea":
					updateTextarea(target, props.value, props.defaultValue);
					break a;
				case "select": internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
			}
		}
	}
	var isInsideEventHandler = false;
	function batchedUpdates$1(fn, a) {
		if (isInsideEventHandler) return fn(a, void 0);
		isInsideEventHandler = true;
		try {
			var __unused_5559 = fn(a);
			return;
		} finally {
			if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
				if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn)) for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
			}
		}
	}
	function getListener(inst, registrationName) {
		var stateNode = inst.stateNode;
		if (null === stateNode) return null;
		var props = stateNode[internalPropsKey] || null;
		if (null === props) return null;
		stateNode = props[registrationName];
		a: switch (registrationName) {
			case "onClick":
			case "onClickCapture":
			case "onDoubleClick":
			case "onDoubleClickCapture":
			case "onMouseDown":
			case "onMouseDownCapture":
			case "onMouseMove":
			case "onMouseMoveCapture":
			case "onMouseUp":
			case "onMouseUpCapture":
			case "onMouseEnter":
				(props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
				inst = !props;
				break a;
			default: inst = false;
		}
		if (inst) return null;
		if (stateNode && "function" !== typeof stateNode) throw Error(formatProdErrorMessage(231, registrationName, typeof stateNode));
		return stateNode;
	}
	var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
	if (canUseDOM) try {
		var options = {};
		Object.defineProperty(options, "passive", { get: function() {
			passiveBrowserEventsSupported = true;
		} });
		window.addEventListener("test", options, options);
		window.removeEventListener("test", options, options);
	} catch {
		passiveBrowserEventsSupported = false;
	}
	var root = null, startText = null, fallbackText = null;
	function getData() {
		if (fallbackText) return fallbackText;
		var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
		for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
		var minEnd = startLength - start;
		for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
		return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
	}
	function getEventCharCode(nativeEvent) {
		var keyCode = nativeEvent.keyCode;
		"charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
		10 === nativeEvent && (nativeEvent = 13);
		return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
	}
	function functionThatReturnsTrue() {
		return true;
	}
	function functionThatReturnsFalse() {
		return false;
	}
	function createSyntheticEvent(Interface) {
		function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
			this._reactName = reactName;
			this._targetInst = targetInst;
			this.type = reactEventType;
			this.nativeEvent = nativeEvent;
			this.target = nativeEventTarget;
			this.currentTarget = null;
			for (var propName in Interface) Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
			this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
			this.isPropagationStopped = functionThatReturnsFalse;
			return this;
		}
		assign(SyntheticBaseEvent.prototype, {
			preventDefault: function() {
				this.defaultPrevented = true;
				var event = this.nativeEvent;
				event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
			},
			stopPropagation: function() {
				var event = this.nativeEvent;
				event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
			},
			persist: function() {},
			isPersistent: functionThatReturnsTrue
		});
		return SyntheticBaseEvent;
	}
	var EventInterface = {
		eventPhase: 0,
		bubbles: 0,
		cancelable: 0,
		timeStamp: function(event) {
			return event.timeStamp || Date.now();
		},
		defaultPrevented: 0,
		isTrusted: 0
	}, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, {
		view: 0,
		detail: 0
	}), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
		screenX: 0,
		screenY: 0,
		clientX: 0,
		clientY: 0,
		pageX: 0,
		pageY: 0,
		ctrlKey: 0,
		shiftKey: 0,
		altKey: 0,
		metaKey: 0,
		getModifierState: getEventModifierState,
		button: 0,
		buttons: 0,
		relatedTarget: function(event) {
			return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
		},
		movementX: function(event) {
			if ("movementX" in event) return event.movementX;
			event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
			return lastMovementX;
		},
		movementY: function(event) {
			return "movementY" in event ? event.movementY : lastMovementY;
		}
	}), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
		animationName: 0,
		elapsedTime: 0,
		pseudoElement: 0
	}), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, { clipboardData: function(event) {
		return "clipboardData" in event ? event.clipboardData : window.clipboardData;
	} }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
		Esc: "Escape",
		Spacebar: " ",
		Left: "ArrowLeft",
		Up: "ArrowUp",
		Right: "ArrowRight",
		Down: "ArrowDown",
		Del: "Delete",
		Win: "OS",
		Menu: "ContextMenu",
		Apps: "ContextMenu",
		Scroll: "ScrollLock",
		MozPrintableKey: "Unidentified"
	}, translateToKey = {
		8: "Backspace",
		9: "Tab",
		12: "Clear",
		13: "Enter",
		16: "Shift",
		17: "Control",
		18: "Alt",
		19: "Pause",
		20: "CapsLock",
		27: "Escape",
		32: " ",
		33: "PageUp",
		34: "PageDown",
		35: "End",
		36: "Home",
		37: "ArrowLeft",
		38: "ArrowUp",
		39: "ArrowRight",
		40: "ArrowDown",
		45: "Insert",
		46: "Delete",
		112: "F1",
		113: "F2",
		114: "F3",
		115: "F4",
		116: "F5",
		117: "F6",
		118: "F7",
		119: "F8",
		120: "F9",
		121: "F10",
		122: "F11",
		123: "F12",
		144: "NumLock",
		145: "ScrollLock",
		224: "Meta"
	}, modifierKeyToProp = {
		Alt: "altKey",
		Control: "ctrlKey",
		Meta: "metaKey",
		Shift: "shiftKey"
	};
	function modifierStateGetter(keyArg) {
		var nativeEvent = this.nativeEvent;
		return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
	}
	function getEventModifierState() {
		return modifierStateGetter;
	}
	var KeyboardEventInterface = assign({}, UIEventInterface, {
		key: function(nativeEvent) {
			if (nativeEvent.key) {
				var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
				if ("Unidentified" !== key) return key;
			}
			return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
		},
		code: 0,
		location: 0,
		ctrlKey: 0,
		shiftKey: 0,
		altKey: 0,
		metaKey: 0,
		repeat: 0,
		locale: 0,
		getModifierState: getEventModifierState,
		charCode: function(event) {
			return "keypress" === event.type ? getEventCharCode(event) : 0;
		},
		keyCode: function(event) {
			return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
		},
		which: function(event) {
			return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
		}
	}), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
		pointerId: 0,
		width: 0,
		height: 0,
		pressure: 0,
		tangentialPressure: 0,
		tiltX: 0,
		tiltY: 0,
		twist: 0,
		pointerType: 0,
		isPrimary: 0
	}), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
		touches: 0,
		targetTouches: 0,
		changedTouches: 0,
		altKey: 0,
		metaKey: 0,
		ctrlKey: 0,
		shiftKey: 0,
		getModifierState: getEventModifierState
	}), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
		propertyName: 0,
		elapsedTime: 0,
		pseudoElement: 0
	}), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
		deltaX: function(event) {
			return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
		},
		deltaY: function(event) {
			return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
		},
		deltaZ: 0,
		deltaMode: 0
	}), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
		newState: 0,
		oldState: 0
	}), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [
		9,
		13,
		27,
		32
	], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
	canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
	var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
	function isFallbackCompositionEnd(domEventName, nativeEvent) {
		switch (domEventName) {
			case "keyup": return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
			case "keydown": return 229 !== nativeEvent.keyCode;
			case "keypress":
			case "mousedown":
			case "focusout": return true;
			default: return false;
		}
	}
	function getDataFromCustomEvent(nativeEvent) {
		nativeEvent = nativeEvent.detail;
		return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
	}
	var isComposing = false;
	function getNativeBeforeInputChars(domEventName, nativeEvent) {
		switch (domEventName) {
			case "compositionend": return getDataFromCustomEvent(nativeEvent);
			case "keypress":
				if (32 !== nativeEvent.which) return null;
				hasSpaceKeypress = true;
				return SPACEBAR_CHAR;
			case "textInput": return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
			default: return null;
		}
	}
	function getFallbackBeforeInputChars(domEventName, nativeEvent) {
		if (isComposing) return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = (startText = root = null, null), isComposing = false, domEventName) : null;
		switch (domEventName) {
			case "paste": return null;
			case "keypress":
				if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
					if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
					if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
				}
				return null;
			case "compositionend": return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
			default: return null;
		}
	}
	var supportedInputTypes = {
		color: true,
		date: true,
		datetime: true,
		"datetime-local": true,
		email: true,
		month: true,
		number: true,
		password: true,
		range: true,
		search: true,
		tel: true,
		text: true,
		time: true,
		url: true,
		week: true
	};
	function isTextInputElement(elem) {
		var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
	}
	function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
		restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
		inst = accumulateTwoPhaseListeners(inst, "onChange");
		0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({
			event: nativeEvent,
			listeners: inst
		}));
	}
	var activeElement$1 = null, activeElementInst$1 = null;
	function runEventInBatch(dispatchQueue) {
		processDispatchQueue(dispatchQueue, 0);
	}
	function getInstIfValueChanged(targetInst) {
		var targetNode = getNodeFromInstance(targetInst);
		if (updateValueIfChanged(targetNode)) return targetInst;
	}
	function getTargetInstForChangeEvent(domEventName, targetInst) {
		if ("change" === domEventName) return targetInst;
	}
	var isInputEventSupported = false;
	if (canUseDOM) {
		var JSCompiler_inline_result$jscomp$286;
		if (canUseDOM) {
			var isSupported$jscomp$inline_427 = "oninput" in document;
			if (!isSupported$jscomp$inline_427) {
				var element$jscomp$inline_428 = document.createElement("div");
				element$jscomp$inline_428.setAttribute("oninput", "return;");
				isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
			}
			JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
		} else JSCompiler_inline_result$jscomp$286 = false;
		isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
	}
	function stopWatchingForValueChange() {
		activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
	}
	function handlePropertyChange(nativeEvent) {
		if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
			var dispatchQueue = [];
			createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
			batchedUpdates$1(runEventInBatch, dispatchQueue);
		}
	}
	function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
		"focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
	}
	function getTargetInstForInputEventPolyfill(domEventName) {
		if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName) return getInstIfValueChanged(activeElementInst$1);
	}
	function getTargetInstForClickEvent(domEventName, targetInst) {
		if ("click" === domEventName) return getInstIfValueChanged(targetInst);
	}
	function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
		if ("input" === domEventName || "change" === domEventName) return getInstIfValueChanged(targetInst);
	}
	var objectIs = Object.is;
	function shallowEqual(objA, objB) {
		if (objectIs(objA, objB)) return true;
		if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return false;
		var keysA = Object.keys(objA), keysB = Object.keys(objB);
		if (keysA.length !== keysB.length) return false;
		for (keysB = 0; keysB < keysA.length; keysB++) {
			var currentKey = keysA[keysB];
			if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return false;
		}
		return true;
	}
	function getLeafNode(node) {
		for (; node && node.firstChild;) node = node.firstChild;
		return node;
	}
	function getNodeForCharacterOffset(root, offset) {
		var node = getLeafNode(root);
		root = 0;
		for (var nodeEnd; node;) {
			if (3 === node.nodeType) {
				nodeEnd = root + node.textContent.length;
				if (root <= offset && nodeEnd >= offset) return {
					node,
					offset: offset - root
				};
				root = nodeEnd;
			}
			a: {
				for (; node;) {
					if (node.nextSibling) {
						node = node.nextSibling;
						break a;
					}
					node = node.parentNode;
				}
				node = void 0;
			}
			node = getLeafNode(node);
		}
	}
	function containsNode(outerNode, innerNode) {
		return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
	}
	function getActiveElementDeep(containerInfo) {
		containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
		for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;) {
			try {
				var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
			} catch {
				JSCompiler_inline_result = false;
			}
			if (JSCompiler_inline_result) containerInfo = element.contentWindow;
			else break;
			element = getActiveElement(containerInfo.document);
		}
		return element;
	}
	function hasSelectionCapabilities(elem) {
		var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
	}
	var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
	function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
		var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
		mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = {
			start: doc.selectionStart,
			end: doc.selectionEnd
		} : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
			anchorNode: doc.anchorNode,
			anchorOffset: doc.anchorOffset,
			focusNode: doc.focusNode,
			focusOffset: doc.focusOffset
		}), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
			event: nativeEvent,
			listeners: doc
		}), nativeEvent.target = activeElement)));
	}
	function makePrefixMap(styleProp, eventName) {
		var prefixes = {};
		prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
		prefixes["Webkit" + styleProp] = "webkit" + eventName;
		prefixes["Moz" + styleProp] = "moz" + eventName;
		return prefixes;
	}
	var vendorPrefixes = {
		animationend: makePrefixMap("Animation", "AnimationEnd"),
		animationiteration: makePrefixMap("Animation", "AnimationIteration"),
		animationstart: makePrefixMap("Animation", "AnimationStart"),
		transitionrun: makePrefixMap("Transition", "TransitionRun"),
		transitionstart: makePrefixMap("Transition", "TransitionStart"),
		transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
		transitionend: makePrefixMap("Transition", "TransitionEnd")
	}, style = {};
	canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
	function getVendorPrefixedEventName(eventName) {
		var prefixMap = vendorPrefixes[eventName], styleProp;
		for (styleProp in prefixMap) if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixMap[styleProp];
		return eventName;
	}
	var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
	simpleEventPluginEvents.push("scrollEnd");
	function registerSimpleEvent(domEventName, reactName) {
		topLevelEventsToReactNames.set(domEventName, reactName);
		registerTwoPhaseEvent(reactName, [domEventName]);
	}
	var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
		if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
			var event = new window.ErrorEvent("error", {
				bubbles: true,
				cancelable: true,
				message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
				error
			});
			if (!window.dispatchEvent(event)) return;
		} else if ("object" === typeof process && "function" === typeof process.emit) {
			process.emit("uncaughtException", error);
			return;
		}
		console.error(error);
	}, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
	function finishQueueingConcurrentUpdates() {
		for (var endIndex = concurrentQueuesIndex, i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0, 0); i < endIndex;) {
			var fiber = concurrentQueues[i];
			concurrentQueues[i++] = null;
			var queue = concurrentQueues[i];
			concurrentQueues[i++] = null;
			var update = concurrentQueues[i];
			concurrentQueues[i++] = null;
			var lane = concurrentQueues[i];
			concurrentQueues[i++] = null;
			if (null !== queue && null !== update) {
				var pending = queue.pending;
				null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
				queue.pending = update;
			}
			0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
		}
	}
	function enqueueUpdate$1(fiber, queue, update, lane) {
		concurrentQueues[concurrentQueuesIndex++] = fiber;
		concurrentQueues[concurrentQueuesIndex++] = queue;
		concurrentQueues[concurrentQueuesIndex++] = update;
		concurrentQueues[concurrentQueuesIndex++] = lane;
		concurrentlyUpdatedLanes |= lane;
		fiber.lanes |= lane;
		fiber = fiber.alternate;
		null !== fiber && (fiber.lanes |= lane);
	}
	function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
		enqueueUpdate$1(fiber, queue, update, lane);
		return getRootForUpdatedFiber(fiber);
	}
	function enqueueConcurrentRenderForLane(fiber, lane) {
		enqueueUpdate$1(fiber, null, null, lane);
		return getRootForUpdatedFiber(fiber);
	}
	function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
		sourceFiber.lanes |= lane;
		var alternate = sourceFiber.alternate;
		null !== alternate && (alternate.lanes |= lane);
		for (var isHidden = false, parent = sourceFiber.return; null !== parent;) parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
		return 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912));
	}
	function getRootForUpdatedFiber(sourceFiber) {
		if (50 < nestedUpdateCount) throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
		for (var parent = sourceFiber.return; null !== parent;) sourceFiber = parent, parent = sourceFiber.return;
		return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
	}
	var emptyContextObject = {};
	function FiberNode(tag, pendingProps, key, mode) {
		this.tag = tag;
		this.key = key;
		this.sibling = (this.child = (this.return = (this.stateNode = (this.type = this.elementType = null, null), null), null), null);
		this.index = 0;
		this.refCleanup = this.ref = null;
		this.pendingProps = pendingProps;
		this.dependencies = (this.memoizedState = (this.updateQueue = this.memoizedProps = null, null), null);
		this.mode = mode;
		this.subtreeFlags = this.flags = 0;
		this.deletions = null;
		this.childLanes = this.lanes = 0;
		this.alternate = null;
	}
	function createFiberImplClass(tag, pendingProps, key, mode) {
		return new FiberNode(tag, pendingProps, key, mode);
	}
	function shouldConstruct(Component) {
		Component = Component.prototype;
		return !(!Component || !Component.isReactComponent);
	}
	function createWorkInProgress(current, pendingProps) {
		var workInProgress = current.alternate;
		null === workInProgress ? (workInProgress = createFiberImplClass(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null);
		workInProgress.flags = current.flags & 65011712;
		workInProgress.childLanes = current.childLanes;
		workInProgress.lanes = current.lanes;
		workInProgress.child = current.child;
		workInProgress.memoizedProps = current.memoizedProps;
		workInProgress.memoizedState = current.memoizedState;
		workInProgress.updateQueue = current.updateQueue;
		pendingProps = current.dependencies;
		workInProgress.dependencies = null === pendingProps ? null : {
			lanes: pendingProps.lanes,
			firstContext: pendingProps.firstContext
		};
		workInProgress.sibling = current.sibling;
		workInProgress.index = current.index;
		workInProgress.ref = current.ref;
		workInProgress.refCleanup = current.refCleanup;
		return workInProgress;
	}
	function resetWorkInProgress(workInProgress, renderLanes) {
		workInProgress.flags &= 65011714;
		var current = workInProgress.alternate;
		null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {
			lanes: renderLanes.lanes,
			firstContext: renderLanes.firstContext
		});
		return workInProgress;
	}
	function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
		var fiberTag = 0;
		owner = type;
		if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
		else if ("string" === typeof type) fiberTag = isHostHoistableType(type, pendingProps, contextStackCursor.current) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
		else a: switch (type) {
			case REACT_ACTIVITY_TYPE: return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
			case REACT_FRAGMENT_TYPE: return createFiberFromFragment(pendingProps.children, mode, lanes, key);
			case REACT_STRICT_MODE_TYPE:
				fiberTag = 8;
				mode |= 24;
				break;
			case REACT_PROFILER_TYPE: return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
			case REACT_SUSPENSE_TYPE: return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
			case REACT_SUSPENSE_LIST_TYPE: return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
			default:
				if ("object" === typeof type && null !== type) switch (type.$$typeof) {
					case REACT_CONTEXT_TYPE:
						fiberTag = 10;
						break a;
					case REACT_CONSUMER_TYPE:
						fiberTag = 9;
						break a;
					case REACT_FORWARD_REF_TYPE:
						fiberTag = 11;
						break a;
					case REACT_MEMO_TYPE:
						fiberTag = 14;
						break a;
					case REACT_LAZY_TYPE:
						fiberTag = 16;
						owner = null;
						break a;
				}
				fiberTag = 29;
				pendingProps = Error(formatProdErrorMessage(130, null === type ? "null" : typeof type, ""));
				owner = null;
		}
		key = createFiberImplClass(fiberTag, pendingProps, key, mode);
		key.elementType = type;
		key.type = owner;
		key.lanes = lanes;
		return key;
	}
	function createFiberFromFragment(elements, mode, lanes, key) {
		elements = createFiberImplClass(7, elements, key, mode);
		elements.lanes = lanes;
		return elements;
	}
	function createFiberFromText(content, mode, lanes) {
		content = createFiberImplClass(6, content, null, mode);
		content.lanes = lanes;
		return content;
	}
	function createFiberFromDehydratedFragment(dehydratedNode) {
		var fiber = createFiberImplClass(18, null, null, 0);
		fiber.stateNode = dehydratedNode;
		return fiber;
	}
	function createFiberFromPortal(portal, mode, lanes) {
		mode = createFiberImplClass(4, null !== portal.children ? portal.children : [], portal.key, mode);
		mode.lanes = lanes;
		mode.stateNode = {
			containerInfo: portal.containerInfo,
			pendingChildren: null,
			implementation: portal.implementation
		};
		return mode;
	}
	var CapturedStacks = new WeakMap();
	function createCapturedValueAtFiber(value, source) {
		if ("object" === typeof value && null !== value) {
			var existing = CapturedStacks.get(value);
			if (void 0 !== existing) return existing;
			source = {
				value,
				source,
				stack: getStackByFiberInDevAndProd(source)
			};
			CapturedStacks.set(value, source);
			return source;
		}
		return {
			value,
			source,
			stack: getStackByFiberInDevAndProd(source)
		};
	}
	var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
	function pushTreeFork(workInProgress, totalChildren) {
		forkStack[forkStackIndex++] = treeForkCount;
		forkStack[forkStackIndex++] = treeForkProvider;
		treeForkProvider = workInProgress;
		treeForkCount = totalChildren;
	}
	function pushTreeId(workInProgress, totalChildren, index) {
		idStack[idStackIndex++] = treeContextId;
		idStack[idStackIndex++] = treeContextOverflow;
		idStack[idStackIndex++] = treeContextProvider;
		treeContextProvider = workInProgress;
		var baseIdWithLeadingBit = treeContextId;
		workInProgress = treeContextOverflow;
		var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
		baseIdWithLeadingBit &= ~(1 << baseLength);
		index += 1;
		var length = 32 - clz32(totalChildren) + baseLength;
		if (30 < length) {
			var numberOfOverflowBits = baseLength - baseLength % 5;
			length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
			baseIdWithLeadingBit >>= numberOfOverflowBits;
			baseLength -= numberOfOverflowBits;
			treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
			treeContextOverflow = length + workInProgress;
		} else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;
	}
	function pushMaterializedTreeId(workInProgress) {
		null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
	}
	function popTreeContext(workInProgress) {
		for (; workInProgress === treeForkProvider;) treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
		for (; workInProgress === treeContextProvider;) treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
	}
	function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
		idStack[idStackIndex++] = treeContextId;
		idStack[idStackIndex++] = treeContextOverflow;
		idStack[idStackIndex++] = treeContextProvider;
		treeContextId = suspendedContext.id;
		treeContextOverflow = suspendedContext.overflow;
		treeContextProvider = workInProgress;
	}
	var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
	function throwOnHydrationMismatch(fiber) {
		var error = Error(formatProdErrorMessage(418, 1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML", ""));
		queueHydrationError(createCapturedValueAtFiber(error, fiber));
		throw HydrationMismatchException;
	}
	function prepareToHydrateHostInstance(fiber) {
		var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
		instance[internalInstanceKey] = fiber;
		instance[internalPropsKey] = props;
		switch (type) {
			case "dialog":
				listenToNonDelegatedEvent("cancel", instance);
				listenToNonDelegatedEvent("close", instance);
				break;
			case "iframe":
			case "object":
			case "embed":
				listenToNonDelegatedEvent("load", instance);
				break;
			case "video":
			case "audio":
				for (type = 0; type < mediaEventTypes.length; type++) listenToNonDelegatedEvent(mediaEventTypes[type], instance);
				break;
			case "source":
				listenToNonDelegatedEvent("error", instance);
				break;
			case "img":
			case "image":
			case "link":
				listenToNonDelegatedEvent("error", instance);
				listenToNonDelegatedEvent("load", instance);
				break;
			case "details":
				listenToNonDelegatedEvent("toggle", instance);
				break;
			case "input":
				listenToNonDelegatedEvent("invalid", instance);
				initInput(instance, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, true);
				break;
			case "select":
				listenToNonDelegatedEvent("invalid", instance);
				break;
			case "textarea": listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
		}
		type = props.children;
		"string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
		instance || throwOnHydrationMismatch(fiber, true);
	}
	function popToNextHostParent(fiber) {
		for (hydrationParentFiber = fiber.return; hydrationParentFiber;) switch (hydrationParentFiber.tag) {
			case 5:
			case 31:
			case 13:
				rootOrSingletonContext = false;
				return;
			case 27:
			case 3:
				rootOrSingletonContext = true;
				return;
			default: hydrationParentFiber = hydrationParentFiber.return;
		}
	}
	function popHydrationState(fiber) {
		if (fiber !== hydrationParentFiber) return false;
		if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
		var tag = fiber.tag, JSCompiler_temp;
		if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
			if (JSCompiler_temp = 5 === tag) JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
			JSCompiler_temp = !JSCompiler_temp;
		}
		JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
		popToNextHostParent(fiber);
		if (13 === tag) {
			fiber = fiber.memoizedState;
			fiber = null !== fiber ? fiber.dehydrated : null;
			if (!fiber) throw Error(formatProdErrorMessage(317));
			nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
		} else if (31 === tag) {
			fiber = fiber.memoizedState;
			fiber = null !== fiber ? fiber.dehydrated : null;
			if (!fiber) throw Error(formatProdErrorMessage(317));
			nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
		} else 27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
		return true;
	}
	function resetHydrationState() {
		nextHydratableInstance = hydrationParentFiber = null;
		isHydrating = false;
	}
	function upgradeHydrationErrorsToRecoverable() {
		var queuedErrors = hydrationErrors;
		null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
		return queuedErrors;
	}
	function queueHydrationError(error) {
		null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
	}
	var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
	function pushProvider(__unused_4187, context, nextValue) {
		push(valueCursor, context._currentValue);
		context._currentValue = nextValue;
	}
	function popProvider(context) {
		context._currentValue = valueCursor.current;
		pop(valueCursor);
	}
	function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
		for (; null !== parent;) {
			var alternate = parent.alternate;
			(parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);
			if (parent === propagationRoot) break;
			parent = parent.return;
		}
	}
	function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {
		var fiber = workInProgress.child;
		null !== fiber && (fiber.return = workInProgress);
		for (; null !== fiber;) {
			var list = fiber.dependencies;
			if (null !== list) {
				var nextFiber = fiber.child;
				list = list.firstContext;
				a: for (; null !== list;) {
					var dependency = list;
					list = fiber;
					for (var i = 0; i < contexts.length; i++) if (dependency.context === contexts[i]) {
						list.lanes |= renderLanes;
						dependency = list.alternate;
						null !== dependency && (dependency.lanes |= renderLanes);
						scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
						forcePropagateEntireTree || (nextFiber = null);
						break a;
					}
					list = dependency.next;
				}
			} else if (18 === fiber.tag) {
				nextFiber = fiber.return;
				if (null === nextFiber) throw Error(formatProdErrorMessage(341));
				nextFiber.lanes |= renderLanes;
				list = nextFiber.alternate;
				null !== list && (list.lanes |= renderLanes);
				scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
				nextFiber = null;
			} else nextFiber = fiber.child;
			if (null !== nextFiber) nextFiber.return = fiber;
			else for (nextFiber = fiber; null !== nextFiber;) {
				if (nextFiber === workInProgress) {
					nextFiber = null;
					break;
				}
				fiber = nextFiber.sibling;
				if (null !== fiber) {
					fiber.return = nextFiber.return;
					nextFiber = fiber;
					break;
				}
				nextFiber = nextFiber.return;
			}
			fiber = nextFiber;
		}
	}
	function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {
		current = null;
		for (var parent = workInProgress, isInsidePropagationBailout = false; null !== parent;) {
			if (!isInsidePropagationBailout) {
				if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
				else if (0 !== (parent.flags & 262144)) break;
			}
			if (10 === parent.tag) {
				var currentParent = parent.alternate;
				if (null === currentParent) throw Error(formatProdErrorMessage(387));
				currentParent = currentParent.memoizedProps;
				if (null !== currentParent) {
					var context = parent.type;
					objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
				}
			} else if (parent === hostTransitionProviderCursor.current) {
				currentParent = parent.alternate;
				if (null === currentParent) throw Error(formatProdErrorMessage(387));
				currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
			}
			parent = parent.return;
		}
		null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
		workInProgress.flags |= 262144;
	}
	function checkIfContextChanged(currentDependencies) {
		for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies;) {
			if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return true;
			currentDependencies = currentDependencies.next;
		}
		return false;
	}
	function prepareToReadContext(workInProgress) {
		currentlyRenderingFiber$1 = workInProgress;
		lastContextDependency = null;
		workInProgress = workInProgress.dependencies;
		null !== workInProgress && (workInProgress.firstContext = null);
	}
	function readContext(context) {
		return readContextForConsumer(currentlyRenderingFiber$1, context);
	}
	function readContextDuringReconciliation(consumer, context) {
		null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
		return readContextForConsumer(consumer, context);
	}
	function readContextForConsumer(consumer, context) {
		var value = context._currentValue;
		context = {
			context,
			memoizedValue: value,
			next: null
		};
		if (null === lastContextDependency) {
			if (null === consumer) throw Error(formatProdErrorMessage(308));
			lastContextDependency = context;
			consumer.dependencies = {
				lanes: 0,
				firstContext: context
			};
			consumer.flags |= 524288;
		} else lastContextDependency = lastContextDependency.next = context;
		return value;
	}
	var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
		var listeners = [], signal = this.signal = {
			aborted: false,
			addEventListener: function(__unused_7CE5, listener) {
				listeners.push(listener);
			}
		};
		this.abort = function() {
			signal.aborted = true;
			listeners.forEach(function(listener) {
				return listener();
			});
		};
	}, scheduleCallback$2 = Scheduler.n, CacheContext = {
		$$typeof: REACT_CONTEXT_TYPE,
		Consumer: null,
		Provider: null,
		_currentValue: null,
		_currentValue2: null,
		_threadCount: 0
	};
	function createCache() {
		return {
			controller: new AbortControllerLocal(),
			data: new Map(),
			refCount: 0
		};
	}
	function releaseCache(cache) {
		cache.refCount--;
		0 === cache.refCount && scheduleCallback$2(3, function() {
			cache.controller.abort();
		});
	}
	var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
	function entangleAsyncAction(__unused_22B5, thenable) {
		if (null === currentEntangledListeners) {
			var entangledListeners = currentEntangledListeners = [];
			currentEntangledPendingCount = 0;
			currentEntangledLane = requestTransitionLane();
			currentEntangledActionThenable = {
				status: "pending",
				value: void 0,
				then: function(resolve) {
					entangledListeners.push(resolve);
				}
			};
		}
		currentEntangledPendingCount++;
		thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
		return;
	}
	function pingEngtangledActionScope() {
		if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
			null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
			var listeners = currentEntangledListeners;
			currentEntangledListeners = null;
			currentEntangledLane = 0;
			currentEntangledActionThenable = null;
			for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
		}
	}
	function chainThenableValue(thenable, result) {
		var listeners = [], thenableWithOverride = {
			status: "pending",
			value: null,
			reason: null,
			then: function(resolve) {
				listeners.push(resolve);
			}
		};
		thenable.then(function() {
			thenableWithOverride.status = "fulfilled";
			thenableWithOverride.value = result;
			for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
		}, function(error) {
			thenableWithOverride.status = "rejected";
			thenableWithOverride.reason = error;
			for (error = 0; error < listeners.length; error++) (0, listeners[error])(void 0);
		});
		return thenableWithOverride;
	}
	var prevOnStartTransitionFinish = ReactSharedInternals.S;
	ReactSharedInternals.S = function(transition, returnValue) {
		globalMostRecentTransitionTime = now();
		"object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(0, returnValue);
		null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
	};
	var resumedCache = createCursor(null);
	function peekCacheFromPool() {
		var cacheResumedFromPreviousRender = resumedCache.current;
		return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
	}
	function pushTransition(__unused_2CCA, prevCachePool) {
		null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
	}
	function getSuspendedCache() {
		var cacheFromPool = peekCacheFromPool();
		return null === cacheFromPool ? null : {
			parent: CacheContext._currentValue,
			pool: cacheFromPool
		};
	}
	var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {} };
	function isThenableResolved(thenable) {
		thenable = thenable.status;
		return "fulfilled" === thenable || "rejected" === thenable;
	}
	function trackUsedThenable(thenableState, thenable, index) {
		index = thenableState[index];
		void 0 === index ? thenableState.push(thenable) : index !== thenable && (thenable.then(noop$1, noop$1), thenable = index);
		switch (thenable.status) {
			case "fulfilled": return thenable.value;
			case "rejected": throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
			default:
				if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
				else {
					thenableState = workInProgressRoot;
					if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(formatProdErrorMessage(482));
					thenableState = thenable;
					thenableState.status = "pending";
					thenableState.then(function(fulfilledValue) {
						if ("pending" === thenable.status) {
							var fulfilledThenable = thenable;
							fulfilledThenable.status = "fulfilled";
							fulfilledThenable.value = fulfilledValue;
						}
					}, function(error) {
						if ("pending" === thenable.status) {
							var rejectedThenable = thenable;
							rejectedThenable.status = "rejected";
							rejectedThenable.reason = error;
						}
					});
				}
				switch (thenable.status) {
					case "fulfilled": return thenable.value;
					case "rejected": throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
				}
				suspendedThenable = thenable;
				throw SuspenseException;
		}
	}
	function resolveLazy(lazyType) {
		try {
			var init = lazyType._init;
			return init(lazyType._payload);
		} catch (x) {
			if (null !== x && "object" === typeof x && "function" === typeof x.then) throw suspendedThenable = x, SuspenseException;
			throw x;
		}
	}
	var suspendedThenable = null;
	function getSuspendedThenable() {
		if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
		var thenable = suspendedThenable;
		suspendedThenable = null;
		return thenable;
	}
	function checkIfUseWrappedInAsyncCatch(rejectedReason) {
		if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) throw Error(formatProdErrorMessage(483));
	}
	var thenableState$1 = null, thenableIndexCounter$1 = 0;
	function unwrapThenable(thenable) {
		var index = thenableIndexCounter$1;
		thenableIndexCounter$1 += 1;
		null === thenableState$1 && (thenableState$1 = []);
		return trackUsedThenable(thenableState$1, thenable, index);
	}
	function coerceRef(workInProgress, element) {
		element = element.props.ref;
		workInProgress.ref = void 0 !== element ? element : null;
	}
	function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
		if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error(formatProdErrorMessage(525));
		returnFiber = Object.prototype.toString.call(newChild);
		throw Error(formatProdErrorMessage(31, "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber));
	}
	function createChildReconciler(shouldTrackSideEffects) {
		function deleteChild(returnFiber, childToDelete) {
			if (shouldTrackSideEffects) {
				var deletions = returnFiber.deletions;
				null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
			}
		}
		function deleteRemainingChildren(returnFiber, currentFirstChild) {
			for (; null !== currentFirstChild;) deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
			return;
		}
		function mapRemainingChildren(currentFirstChild) {
			for (var existingChildren = new Map(); null !== currentFirstChild;) null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
			return existingChildren;
		}
		function useFiber(fiber, pendingProps) {
			fiber = createWorkInProgress(fiber, pendingProps);
			fiber.index = 0;
			fiber.sibling = null;
			return fiber;
		}
		function placeChild(newFiber, lastPlacedIndex, newIndex) {
			newFiber.index = newIndex;
			if (!shouldTrackSideEffects) return newFiber.flags |= 1048576;
			newIndex = newFiber.alternate;
			if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
			newFiber.flags |= 67108866;
			return lastPlacedIndex;
		}
		function placeSingleChild(newFiber) {
			shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
			return newFiber;
		}
		function updateTextNode(returnFiber, current, textContent, lanes) {
			if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
			current = useFiber(current, textContent);
			current.return = returnFiber;
			return current;
		}
		function updateElement(returnFiber, current, element, lanes) {
			var elementType = element.type;
			if (elementType === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
			if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
			current = createFiberFromTypeAndProps(element.type, element.key, element.props, 0, returnFiber.mode, lanes);
			coerceRef(current, element);
			current.return = returnFiber;
			return current;
		}
		function updatePortal(returnFiber, current, portal, lanes) {
			if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
			current = useFiber(current, portal.children || []);
			current.return = returnFiber;
			return current;
		}
		function updateFragment(returnFiber, current, fragment, lanes, key) {
			if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current;
			current = useFiber(current, fragment);
			current.return = returnFiber;
			return current;
		}
		function createChild(returnFiber, newChild, lanes) {
			if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
			if ("object" === typeof newChild && null !== newChild) {
				switch (newChild.$$typeof) {
					case REACT_ELEMENT_TYPE: return lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, 0, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
					case REACT_PORTAL_TYPE: return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
					case REACT_LAZY_TYPE: return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
				}
				if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), newChild.return = returnFiber, newChild;
				if ("function" === typeof newChild.then) return createChild(returnFiber, unwrapThenable(newChild), lanes);
				if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
				throwOnInvalidObjectTypeImpl(0, newChild);
			}
			return null;
		}
		function updateSlot(returnFiber, oldFiber, newChild, lanes) {
			var key = null !== oldFiber ? oldFiber.key : null;
			if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
			if ("object" === typeof newChild && null !== newChild) {
				switch (newChild.$$typeof) {
					case REACT_ELEMENT_TYPE: return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
					case REACT_PORTAL_TYPE: return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
					case REACT_LAZY_TYPE: return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
				}
				if (isArrayImpl(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
				if ("function" === typeof newChild.then) return updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes);
				if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
				throwOnInvalidObjectTypeImpl(0, newChild);
			}
			return null;
		}
		function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
			if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
			if ("object" === typeof newChild && null !== newChild) {
				switch (newChild.$$typeof) {
					case REACT_ELEMENT_TYPE: return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
					case REACT_PORTAL_TYPE: return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
					case REACT_LAZY_TYPE: return newChild = resolveLazy(newChild), updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
				}
				if (isArrayImpl(newChild) || getIteratorFn(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
				if ("function" === typeof newChild.then) return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes);
				if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
				throwOnInvalidObjectTypeImpl(0, newChild);
			}
			return null;
		}
		function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
			for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
				oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
				var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
				if (null === newFiber) {
					null === oldFiber && (oldFiber = nextOldFiber);
					break;
				}
				shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
				currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
				null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
				previousNewFiber = newFiber;
				oldFiber = nextOldFiber;
			}
			if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
			if (null === oldFiber) {
				for (; newIdx < newChildren.length; newIdx++) oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
				isHydrating && pushTreeFork(returnFiber, newIdx);
				return resultingFirstChild;
			}
			for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
			shouldTrackSideEffects && oldFiber.forEach(function(child) {
				return deleteChild(returnFiber, child), void 0;
			});
			isHydrating && pushTreeFork(returnFiber, newIdx);
			return resultingFirstChild;
		}
		function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
			if (null == newChildren) throw Error(formatProdErrorMessage(151));
			for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
				oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
				var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
				if (null === newFiber) {
					null === oldFiber && (oldFiber = nextOldFiber);
					break;
				}
				shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
				currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
				null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
				previousNewFiber = newFiber;
				oldFiber = nextOldFiber;
			}
			if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
			if (null === oldFiber) {
				for (; !step.done; newIdx++, step = newChildren.next()) step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
				isHydrating && pushTreeFork(returnFiber, newIdx);
				return resultingFirstChild;
			}
			for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next()) step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
			shouldTrackSideEffects && oldFiber.forEach(function(child) {
				return deleteChild(returnFiber, child), void 0;
			});
			isHydrating && pushTreeFork(returnFiber, newIdx);
			return resultingFirstChild;
		}
		function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
			"object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
			if ("object" === typeof newChild && null !== newChild) {
				switch (newChild.$$typeof) {
					case REACT_ELEMENT_TYPE:
						a: {
							for (var key = newChild.key; null !== currentFirstChild;) {
								if (currentFirstChild.key === key) {
									key = newChild.type;
									if (key === REACT_FRAGMENT_TYPE) {
										if (7 === currentFirstChild.tag) {
											deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
											lanes = useFiber(currentFirstChild, newChild.props.children);
											lanes.return = returnFiber;
											returnFiber = lanes;
											break a;
										}
									} else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
										deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
										lanes = useFiber(currentFirstChild, newChild.props);
										coerceRef(lanes, newChild);
										lanes.return = returnFiber;
										returnFiber = lanes;
										break a;
									}
									deleteRemainingChildren(returnFiber, currentFirstChild);
									break;
								} else deleteChild(returnFiber, currentFirstChild);
								currentFirstChild = currentFirstChild.sibling;
							}
							newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, 0, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
						}
						return placeSingleChild(returnFiber);
					case REACT_PORTAL_TYPE:
						a: {
							for (key = newChild.key; null !== currentFirstChild;) {
								if (currentFirstChild.key === key) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
									deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
									lanes = useFiber(currentFirstChild, newChild.children || []);
									lanes.return = returnFiber;
									returnFiber = lanes;
									break a;
								} else {
									deleteRemainingChildren(returnFiber, currentFirstChild);
									break;
								}
								else deleteChild(returnFiber, currentFirstChild);
								currentFirstChild = currentFirstChild.sibling;
							}
							lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
							lanes.return = returnFiber;
							returnFiber = lanes;
						}
						return placeSingleChild(returnFiber);
					case REACT_LAZY_TYPE: return newChild = resolveLazy(newChild), reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
				}
				if (isArrayImpl(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
				if (getIteratorFn(newChild)) {
					key = getIteratorFn(newChild);
					if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
					newChild = key.call(newChild);
					return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
				}
				if ("function" === typeof newChild.then) return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes);
				if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
				throwOnInvalidObjectTypeImpl(0, newChild);
			}
			return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : (deleteRemainingChildren(returnFiber, currentFirstChild), null);
		}
		return function(returnFiber, currentFirstChild, newChild, lanes) {
			try {
				thenableIndexCounter$1 = 0;
				var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
				thenableState$1 = null;
				return firstChildFiber;
			} catch (x) {
				if (x === SuspenseException || x === SuspenseActionException) throw x;
				var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
				fiber.lanes = lanes;
				fiber.return = returnFiber;
				return fiber;
			}
		};
	}
	var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), hasForceUpdate = false;
	function initializeUpdateQueue(fiber) {
		fiber.updateQueue = {
			baseState: fiber.memoizedState,
			firstBaseUpdate: null,
			lastBaseUpdate: null,
			shared: {
				pending: null,
				lanes: 0,
				hiddenCallbacks: null
			},
			callbacks: null
		};
	}
	function cloneUpdateQueue(current, workInProgress) {
		current = current.updateQueue;
		workInProgress.updateQueue === current && (workInProgress.updateQueue = {
			baseState: current.baseState,
			firstBaseUpdate: current.firstBaseUpdate,
			lastBaseUpdate: current.lastBaseUpdate,
			shared: current.shared,
			callbacks: null
		});
	}
	function createUpdate(lane) {
		return {
			lane,
			tag: 0,
			payload: null,
			callback: null,
			next: null
		};
	}
	function enqueueUpdate(fiber, update, lane) {
		var updateQueue = fiber.updateQueue;
		if (null === updateQueue) return null;
		updateQueue = updateQueue.shared;
		if (0 !== (executionContext & 2)) {
			var pending = updateQueue.pending;
			null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
			updateQueue.pending = update;
			update = getRootForUpdatedFiber(fiber);
			markUpdateLaneFromFiberToRoot(fiber, null, lane);
			return update;
		}
		enqueueUpdate$1(fiber, updateQueue, update, lane);
		return getRootForUpdatedFiber(fiber);
	}
	function entangleTransitions(root, fiber, lane) {
		fiber = fiber.updateQueue;
		if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
			var queueLanes = fiber.lanes;
			queueLanes &= root.pendingLanes;
			lane |= queueLanes;
			fiber.lanes = lane;
			markRootEntangled(root, lane);
		}
	}
	function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
		var queue = workInProgress.updateQueue, current = workInProgress.alternate;
		if (null !== current && (current = current.updateQueue, queue === current)) {
			var newFirst = null, newLast = null;
			queue = queue.firstBaseUpdate;
			if (null !== queue) {
				do {
					var clone = {
						lane: queue.lane,
						tag: queue.tag,
						payload: queue.payload,
						callback: null,
						next: null
					};
					null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
					queue = queue.next;
				} while (null !== queue);
				null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
			} else newFirst = newLast = capturedUpdate;
			queue = {
				baseState: current.baseState,
				firstBaseUpdate: newFirst,
				lastBaseUpdate: newLast,
				shared: current.shared,
				callbacks: current.callbacks
			};
			workInProgress.updateQueue = queue;
			return;
		}
		workInProgress = queue.lastBaseUpdate;
		null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
		queue.lastBaseUpdate = capturedUpdate;
	}
	var didReadFromEntangledAsyncAction = false;
	function suspendIfUpdateReadFromEntangledAsyncAction() {
		if (didReadFromEntangledAsyncAction) {
			var entangledActionThenable = currentEntangledActionThenable;
			if (null !== entangledActionThenable) throw entangledActionThenable;
		}
	}
	function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes) {
		didReadFromEntangledAsyncAction = false;
		var queue = workInProgress$jscomp$0.updateQueue;
		hasForceUpdate = false;
		var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
		if (null !== pendingQueue) {
			queue.shared.pending = null;
			var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
			lastPendingUpdate.next = null;
			null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
			lastBaseUpdate = lastPendingUpdate;
			var current = workInProgress$jscomp$0.alternate;
			null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
		}
		if (null !== firstBaseUpdate) {
			var newState = queue.baseState;
			lastBaseUpdate = 0;
			current = (firstPendingUpdate = lastPendingUpdate = null, null);
			pendingQueue = firstBaseUpdate;
			do {
				var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
				if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
					0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
					null !== current && (current = current.next = {
						lane: 0,
						tag: pendingQueue.tag,
						payload: pendingQueue.payload,
						callback: null,
						next: null
					});
					a: {
						var workInProgress = workInProgress$jscomp$0, update = pendingQueue;
						updateLane = props;
						var instance = instance$jscomp$0;
						switch (update.tag) {
							case 1:
								workInProgress = update.payload;
								if ("function" === typeof workInProgress) {
									newState = workInProgress.call(instance, newState, updateLane);
									break a;
								}
								newState = workInProgress;
								break a;
							case 3: workInProgress.flags = workInProgress.flags & -65537 | 128;
							case 0:
								workInProgress = update.payload;
								updateLane = "function" === typeof workInProgress ? workInProgress.call(instance, newState, updateLane) : workInProgress;
								if (null === updateLane || void 0 === updateLane) break a;
								newState = assign({}, newState, updateLane);
								break a;
							case 2: hasForceUpdate = true;
						}
					}
					updateLane = pendingQueue.callback;
					null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
				} else isHiddenUpdate = {
					lane: updateLane,
					tag: pendingQueue.tag,
					payload: pendingQueue.payload,
					callback: pendingQueue.callback,
					next: null
				}, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
				pendingQueue = pendingQueue.next;
				if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;
				else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
			} while (1);
			null === current && (lastPendingUpdate = newState);
			queue.baseState = lastPendingUpdate;
			queue.firstBaseUpdate = firstPendingUpdate;
			queue.lastBaseUpdate = current;
			null === firstBaseUpdate && (queue.shared.lanes = 0);
			workInProgressRootSkippedLanes |= lastBaseUpdate;
			workInProgress$jscomp$0.lanes = lastBaseUpdate;
			workInProgress$jscomp$0.memoizedState = newState;
		}
	}
	function callCallback(callback, context) {
		if ("function" !== typeof callback) throw Error(formatProdErrorMessage(191, callback));
		callback.call(context);
	}
	function commitCallbacks(updateQueue, context) {
		var callbacks = updateQueue.callbacks;
		if (null !== callbacks) for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++) callCallback(callbacks[updateQueue], context);
	}
	var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
	function pushHiddenContext(fiber, context) {
		fiber = entangledRenderLanes;
		push(prevEntangledRenderLanesCursor, fiber);
		push(currentTreeHiddenStackCursor, context);
		entangledRenderLanes = fiber | context.baseLanes;
	}
	function reuseHiddenContextOnStack() {
		push(prevEntangledRenderLanesCursor, entangledRenderLanes);
		push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
	}
	function popHiddenContext() {
		entangledRenderLanes = prevEntangledRenderLanesCursor.current;
		pop(currentTreeHiddenStackCursor);
		pop(prevEntangledRenderLanesCursor);
	}
	var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
	function pushPrimaryTreeSuspenseHandler(handler) {
		var current = handler.alternate;
		push(suspenseStackCursor, suspenseStackCursor.current & 1);
		push(suspenseHandlerStackCursor, handler);
		null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
	}
	function pushDehydratedActivitySuspenseHandler(fiber) {
		push(suspenseStackCursor, suspenseStackCursor.current);
		push(suspenseHandlerStackCursor, fiber);
		null === shellBoundary && (shellBoundary = fiber);
	}
	function pushOffscreenSuspenseHandler(fiber) {
		22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack();
	}
	function reuseSuspenseHandlerOnStack() {
		push(suspenseStackCursor, suspenseStackCursor.current);
		push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
	}
	function popSuspenseHandler(fiber) {
		shellBoundary === fiber && (shellBoundary = null);
	}
	var suspenseStackCursor = createCursor(0);
	function findFirstSuspended(row) {
		for (var node = row; null !== node;) {
			if (13 === node.tag) {
				var state = node.memoizedState;
				if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;
			} else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
				if (0 !== (node.flags & 128)) return node;
			} else if (null !== node.child) {
				node.child.return = node;
				node = node.child;
				continue;
			}
			if (node === row) break;
			for (; null === node.sibling;) {
				if (null === node.return || node.return === row) return null;
				node = node.return;
			}
			node.sibling.return = node.return;
			node = node.sibling;
		}
		return null;
	}
	var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
	function throwInvalidHookError() {
		throw Error(formatProdErrorMessage(321));
	}
	function areHookInputsEqual(nextDeps, prevDeps) {
		if (null === prevDeps) return false;
		for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) if (!objectIs(nextDeps[i], prevDeps[i])) return false;
		return true;
	}
	function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
		renderLanes = nextRenderLanes;
		currentlyRenderingFiber = workInProgress;
		workInProgress.memoizedState = null;
		workInProgress.updateQueue = null;
		workInProgress.lanes = 0;
		ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
		shouldDoubleInvokeUserFnsInHooksDEV = false;
		nextRenderLanes = Component(props, secondArg);
		shouldDoubleInvokeUserFnsInHooksDEV = false;
		didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(workInProgress, Component, props, secondArg));
		finishRenderingHooks(current);
		return nextRenderLanes;
	}
	function finishRenderingHooks(current) {
		ReactSharedInternals.H = ContextOnlyDispatcher;
		var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
		renderLanes = 0;
		workInProgressHook = (currentHook = currentlyRenderingFiber = null, null);
		didScheduleRenderPhaseUpdate = false;
		thenableIndexCounter = 0;
		thenableState = null;
		if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
		null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
	}
	function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
		currentlyRenderingFiber = workInProgress;
		var numberOfReRenders = 0;
		do {
			didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
			thenableIndexCounter = 0;
			didScheduleRenderPhaseUpdateDuringThisPass = false;
			if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
			numberOfReRenders += 1;
			workInProgressHook = currentHook = null;
			if (null != workInProgress.updateQueue) {
				var children = workInProgress.updateQueue;
				children.lastEffect = null;
				children.events = null;
				children.stores = null;
				null != children.memoCache && (children.memoCache.index = 0);
			}
			ReactSharedInternals.H = HooksDispatcherOnRerender;
			children = Component(props, secondArg);
		} while (didScheduleRenderPhaseUpdateDuringThisPass);
		return children;
	}
	function TransitionAwareHostComponent() {
		var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
		maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
		dispatcher = dispatcher.useState()[0];
		(null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
		return maybeThenable;
	}
	function checkDidRenderIdHook() {
		var didRenderIdHook = 0 !== localIdCounter;
		localIdCounter = 0;
		return didRenderIdHook;
	}
	function bailoutHooks(current, workInProgress, lanes) {
		workInProgress.updateQueue = current.updateQueue;
		workInProgress.flags &= -2053;
		current.lanes &= ~lanes;
	}
	function resetHooksOnUnwind(workInProgress) {
		if (didScheduleRenderPhaseUpdate) {
			for (workInProgress = workInProgress.memoizedState; null !== workInProgress;) {
				var queue = workInProgress.queue;
				null !== queue && (queue.pending = null);
				workInProgress = workInProgress.next;
			}
			didScheduleRenderPhaseUpdate = false;
		}
		renderLanes = 0;
		workInProgressHook = (currentHook = currentlyRenderingFiber = null, null);
		didScheduleRenderPhaseUpdateDuringThisPass = false;
		thenableIndexCounter = localIdCounter = 0;
		thenableState = null;
	}
	function mountWorkInProgressHook() {
		var hook = {
			memoizedState: null,
			baseState: null,
			baseQueue: null,
			queue: null,
			next: null
		};
		null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
		return workInProgressHook;
	}
	function updateWorkInProgressHook() {
		if (null === currentHook) {
			var nextCurrentHook = currentlyRenderingFiber.alternate;
			nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
		} else nextCurrentHook = currentHook.next;
		var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
		if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
		else {
			if (null === nextCurrentHook) {
				if (null === currentlyRenderingFiber.alternate) throw Error(formatProdErrorMessage(467));
				throw Error(formatProdErrorMessage(310));
			}
			currentHook = nextCurrentHook;
			nextCurrentHook = {
				memoizedState: currentHook.memoizedState,
				baseState: currentHook.baseState,
				baseQueue: currentHook.baseQueue,
				queue: currentHook.queue,
				next: null
			};
			null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
		}
		return workInProgressHook;
	}
	function createFunctionComponentUpdateQueue() {
		return {
			lastEffect: null,
			events: null,
			stores: null,
			memoCache: null
		};
	}
	function useThenable(thenable) {
		var index = thenableIndexCounter;
		thenableIndexCounter += 1;
		null === thenableState && (thenableState = []);
		thenable = trackUsedThenable(thenableState, thenable, index);
		index = currentlyRenderingFiber;
		null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null === index || null === index.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
		return thenable;
	}
	function use(usable) {
		if (null !== usable && "object" === typeof usable) {
			if ("function" === typeof usable.then) return useThenable(usable);
			if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
		}
		throw Error(formatProdErrorMessage(438, String(usable)));
	}
	function useMemoCache(size) {
		var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
		null !== updateQueue && (memoCache = updateQueue.memoCache);
		if (null == memoCache) {
			var current = currentlyRenderingFiber.alternate;
			null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
				data: current.data.map(function(array) {
					return array.slice();
				}),
				index: 0
			})));
		}
		null == memoCache && (memoCache = {
			data: [],
			index: 0
		});
		null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
		updateQueue.memoCache = memoCache;
		updateQueue = memoCache.data[memoCache.index];
		if (void 0 === updateQueue) for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++) updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
		memoCache.index++;
		return updateQueue;
	}
	function basicStateReducer(state, action) {
		return "function" === typeof action ? action(state) : action;
	}
	function updateReducer(reducer) {
		var hook = updateWorkInProgressHook();
		return updateReducerImpl(hook, currentHook, reducer);
	}
	function updateReducerImpl(hook, current, reducer) {
		var queue = hook.queue;
		if (null === queue) throw Error(formatProdErrorMessage(311));
		queue.lastRenderedReducer = reducer;
		var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
		if (null !== pendingQueue) {
			if (null !== baseQueue) {
				var baseFirst = baseQueue.next;
				baseQueue.next = pendingQueue.next;
				pendingQueue.next = baseFirst;
			}
			current.baseQueue = baseQueue = pendingQueue;
			queue.pending = null;
		}
		pendingQueue = hook.baseState;
		if (null === baseQueue) hook.memoizedState = pendingQueue;
		else {
			current = baseQueue.next;
			var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
			do {
				var updateLane = update.lane & -536870913;
				if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
					var revertLane = update.revertLane;
					if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
						lane: 0,
						revertLane: 0,
						gesture: null,
						action: update.action,
						hasEagerState: update.hasEagerState,
						eagerState: update.eagerState,
						next: null
					}), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
					else if ((renderLanes & revertLane) === revertLane) {
						update = update.next;
						revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
						continue;
					} else updateLane = {
						lane: 0,
						revertLane: update.revertLane,
						gesture: null,
						action: update.action,
						hasEagerState: update.hasEagerState,
						eagerState: update.eagerState,
						next: null
					}, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
					updateLane = update.action;
					shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
					pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
				} else revertLane = {
					lane: updateLane,
					revertLane: update.revertLane,
					gesture: update.gesture,
					action: update.action,
					hasEagerState: update.hasEagerState,
					eagerState: update.eagerState,
					next: null
				}, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
				update = update.next;
			} while (null !== update && update !== current);
			null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
			if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;
			hook.memoizedState = pendingQueue;
			hook.baseState = baseFirst;
			hook.baseQueue = newBaseQueueLast;
			queue.lastRenderedState = pendingQueue;
		}
		null === baseQueue && (queue.lanes = 0);
		return [hook.memoizedState, queue.dispatch];
	}
	function rerenderReducer(reducer) {
		var hook = updateWorkInProgressHook(), queue = hook.queue;
		if (null === queue) throw Error(formatProdErrorMessage(311));
		queue.lastRenderedReducer = reducer;
		var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
		if (null !== lastRenderPhaseUpdate) {
			queue.pending = null;
			var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
			do
				newState = reducer(newState, update.action), update = update.next;
			while (update !== lastRenderPhaseUpdate);
			objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
			hook.memoizedState = newState;
			null === hook.baseQueue && (hook.baseState = newState);
			queue.lastRenderedState = newState;
		}
		return [newState, dispatch];
	}
	function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
		var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
		if (isHydrating$jscomp$0) {
			if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
			getServerSnapshot = getServerSnapshot();
		} else getServerSnapshot = getSnapshot();
		var snapshotChanged = !objectIs((currentHook || hook).memoizedState, getServerSnapshot);
		snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
		hook = hook.queue;
		updateEffect(subscribeToStore.bind(0, fiber, hook, subscribe), [subscribe]);
		if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
			fiber.flags |= 2048;
			pushSimpleEffect(9, { destroy: void 0 }, updateStoreInstance.bind(0, fiber, hook, getServerSnapshot, getSnapshot), null);
			if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
			isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
		}
		return getServerSnapshot;
	}
	function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
		fiber.flags |= 16384;
		fiber = {
			getSnapshot,
			value: renderedSnapshot
		};
		getSnapshot = currentlyRenderingFiber.updateQueue;
		null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
	}
	function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
		inst.value = nextSnapshot;
		inst.getSnapshot = getSnapshot;
		checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
	}
	function subscribeToStore(fiber, inst, subscribe) {
		return subscribe(function() {
			checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		});
	}
	function checkIfSnapshotChanged(inst) {
		var latestGetSnapshot = inst.getSnapshot;
		inst = inst.value;
		try {
			var nextValue = latestGetSnapshot();
			return !objectIs(inst, nextValue);
		} catch {
			return true;
		}
	}
	function forceStoreRerender(fiber) {
		var root = enqueueConcurrentRenderForLane(fiber, 2);
		null !== root && scheduleUpdateOnFiber(root, 0, 2);
	}
	function mountStateImpl(initialState) {
		var hook = mountWorkInProgressHook();
		if ("function" === typeof initialState) {
			var initialStateInitializer = initialState;
			initialState = initialStateInitializer();
			if (shouldDoubleInvokeUserFnsInHooksDEV) {
				setIsStrictModeForDevtools(true);
				try {
					initialStateInitializer();
				} finally {
					setIsStrictModeForDevtools(false);
				}
			}
		}
		hook.memoizedState = hook.baseState = initialState;
		hook.queue = {
			pending: null,
			lanes: 0,
			dispatch: null,
			lastRenderedReducer: basicStateReducer,
			lastRenderedState: initialState
		};
		return hook;
	}
	function updateOptimisticImpl(hook, __unused_E2A4, passthrough, reducer) {
		hook.baseState = passthrough;
		return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
	}
	function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
		if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
		fiber = actionQueue.action;
		if (null !== fiber) {
			var actionNode = {
				payload,
				action: fiber,
				next: null,
				isTransition: true,
				status: "pending",
				value: null,
				reason: null,
				listeners: [],
				then: function(listener) {
					actionNode.listeners.push(listener);
				}
			};
			null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
			setState(actionNode);
			setPendingState = actionQueue.pending;
			null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
		}
	}
	function runActionStateAction(actionQueue, node) {
		var action = node.action, payload = node.payload, prevState = actionQueue.state;
		if (node.isTransition) {
			var prevTransition = ReactSharedInternals.T, currentTransition = {};
			ReactSharedInternals.T = currentTransition;
			try {
				var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
				null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
				handleActionReturnValue(actionQueue, node, returnValue);
			} catch (error) {
				onActionError(actionQueue, node, error);
			} finally {
				null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
			}
		} else try {
			prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
		} catch (error$66) {
			onActionError(actionQueue, node, error$66);
		}
	}
	function handleActionReturnValue(actionQueue, node, returnValue) {
		null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(function(nextState) {
			onActionSuccess(actionQueue, node, nextState);
		}, function(error) {
			return onActionError(actionQueue, node, error), void 0;
		}) : onActionSuccess(actionQueue, node, returnValue);
	}
	function onActionSuccess(actionQueue, actionNode, nextState) {
		actionNode.status = "fulfilled";
		actionNode.value = nextState;
		notifyActionListeners(actionNode);
		actionQueue.state = nextState;
		actionNode = actionQueue.pending;
		null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
	}
	function onActionError(actionQueue, actionNode, error) {
		var last = actionQueue.pending;
		actionQueue.pending = null;
		if (null !== last) {
			last = last.next;
			do
				actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
			while (actionNode !== last);
		}
		actionQueue.action = null;
	}
	function notifyActionListeners(actionNode) {
		actionNode = actionNode.listeners;
		for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
	}
	function actionStateReducer(__unused_B2F9, newState) {
		return newState;
	}
	function mountActionState(action, initialStateProp) {
		if (isHydrating) {
			var ssrFormState = workInProgressRoot.formState;
			if (null !== ssrFormState) {
				a: {
					var JSCompiler_inline_result = currentlyRenderingFiber;
					if (isHydrating) {
						if (nextHydratableInstance) {
							b: {
								var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
								for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType;) {
									if (!inRootOrSingleton) {
										JSCompiler_inline_result$jscomp$0 = null;
										break b;
									}
									JSCompiler_inline_result$jscomp$0 = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
									if (null === JSCompiler_inline_result$jscomp$0) {
										JSCompiler_inline_result$jscomp$0 = null;
										break b;
									}
								}
								inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
								JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
							}
							if (JSCompiler_inline_result$jscomp$0) {
								nextHydratableInstance = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
								JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
								break a;
							}
						}
						throwOnHydrationMismatch(JSCompiler_inline_result);
					}
					JSCompiler_inline_result = false;
				}
				JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
			}
		}
		ssrFormState = mountWorkInProgressHook();
		ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
		JSCompiler_inline_result = {
			pending: null,
			lanes: 0,
			dispatch: null,
			lastRenderedReducer: actionStateReducer,
			lastRenderedState: initialStateProp
		};
		ssrFormState.queue = JSCompiler_inline_result;
		ssrFormState = dispatchSetState.bind(0, currentlyRenderingFiber, JSCompiler_inline_result);
		JSCompiler_inline_result.dispatch = ssrFormState;
		JSCompiler_inline_result = mountStateImpl(false);
		inRootOrSingleton = dispatchOptimisticSetState.bind(0, currentlyRenderingFiber, false, JSCompiler_inline_result.queue);
		JSCompiler_inline_result = mountWorkInProgressHook();
		JSCompiler_inline_result$jscomp$0 = {
			state: initialStateProp,
			dispatch: null,
			action,
			pending: null
		};
		JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
		ssrFormState = dispatchActionState.bind(0, currentlyRenderingFiber, JSCompiler_inline_result$jscomp$0, inRootOrSingleton, ssrFormState);
		JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
		JSCompiler_inline_result.memoizedState = action;
		return [
			initialStateProp,
			ssrFormState,
			false
		];
	}
	function updateActionState(action) {
		var stateHook = updateWorkInProgressHook();
		return updateActionStateImpl(stateHook, currentHook, action);
	}
	function updateActionStateImpl(stateHook, currentStateHook, action) {
		currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
		stateHook = updateReducer(basicStateReducer)[0];
		if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then) try {
			var state = useThenable(currentStateHook);
		} catch (x) {
			if (x === SuspenseException) throw SuspenseActionException;
			throw x;
		}
		else state = currentStateHook;
		currentStateHook = updateWorkInProgressHook();
		var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
		action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(9, { destroy: void 0 }, actionStateActionEffect.bind(0, actionQueue, action), null));
		return [
			state,
			dispatch,
			stateHook
		];
	}
	function actionStateActionEffect(actionQueue, action) {
		actionQueue.action = action;
	}
	function rerenderActionState(action) {
		var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
		if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
		updateWorkInProgressHook();
		stateHook = stateHook.memoizedState;
		currentStateHook = updateWorkInProgressHook();
		var dispatch = currentStateHook.queue.dispatch;
		currentStateHook.memoizedState = action;
		return [
			stateHook,
			dispatch,
			false
		];
	}
	function pushSimpleEffect(tag, inst, create, deps) {
		tag = {
			tag,
			create,
			deps,
			inst,
			next: null
		};
		inst = currentlyRenderingFiber.updateQueue;
		null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
		create = inst.lastEffect;
		null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
		return tag;
	}
	function updateRef() {
		return updateWorkInProgressHook().memoizedState;
	}
	function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
		var hook = mountWorkInProgressHook();
		currentlyRenderingFiber.flags |= fiberFlags;
		hook.memoizedState = pushSimpleEffect(1 | hookFlags, { destroy: void 0 }, create, void 0 === deps ? null : deps);
	}
	function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
		var hook = updateWorkInProgressHook();
		deps = void 0 === deps ? null : deps;
		var inst = hook.memoizedState.inst;
		null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(1 | hookFlags, inst, create, deps));
	}
	function mountEffect(create, deps) {
		mountEffectImpl(8390656, 8, create, deps);
	}
	function updateEffect(create, deps) {
		updateEffectImpl(2048, 8, create, deps);
	}
	function useEffectEventImpl(payload) {
		currentlyRenderingFiber.flags |= 4;
		var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
		if (null === componentUpdateQueue) componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
		else {
			var events = componentUpdateQueue.events;
			null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
		}
	}
	function updateEvent(callback) {
		var ref = updateWorkInProgressHook().memoizedState;
		useEffectEventImpl({
			ref,
			nextImpl: callback
		});
		return function() {
			if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
			return ref.impl.apply(void 0, arguments);
		};
	}
	function updateInsertionEffect(create, deps) {
		return updateEffectImpl(4, 2, create, deps), void 0;
	}
	function updateLayoutEffect(create, deps) {
		return updateEffectImpl(4, 4, create, deps), void 0;
	}
	function imperativeHandleEffect(create, ref) {
		if ("function" === typeof ref) {
			create = create();
			var refCleanup = ref(create);
			return function() {
				"function" === typeof refCleanup ? refCleanup() : ref(null);
			};
		}
		if (null !== ref && void 0 !== ref) return create = create(), ref.current = create, function() {
			ref.current = null;
		};
	}
	function updateImperativeHandle(ref, create, deps) {
		deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		updateEffectImpl(4, 4, imperativeHandleEffect.bind(0, create, ref), deps);
	}
	function mountDebugValue() {}
	function updateCallback(callback, deps) {
		var hook = updateWorkInProgressHook();
		deps = void 0 === deps ? null : deps;
		var prevState = hook.memoizedState;
		if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
		hook.memoizedState = [callback, deps];
		return callback;
	}
	function updateMemo(nextCreate, deps) {
		var hook = updateWorkInProgressHook();
		deps = void 0 === deps ? null : deps;
		var prevState = hook.memoizedState;
		if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
		prevState = nextCreate();
		if (shouldDoubleInvokeUserFnsInHooksDEV) {
			setIsStrictModeForDevtools(true);
			try {
				nextCreate();
			} finally {
				setIsStrictModeForDevtools(false);
			}
		}
		hook.memoizedState = [prevState, deps];
		return prevState;
	}
	function mountDeferredValueImpl(hook, value, initialValue) {
		if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930)) return hook.memoizedState = value;
		hook.memoizedState = initialValue;
		hook = requestDeferredLane();
		currentlyRenderingFiber.lanes |= hook;
		workInProgressRootSkippedLanes |= hook;
		return initialValue;
	}
	function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
		if (objectIs(value, prevValue)) return value;
		if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
		if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930)) return didReceiveUpdate = true, hook.memoizedState = value;
		hook = requestDeferredLane();
		currentlyRenderingFiber.lanes |= hook;
		workInProgressRootSkippedLanes |= hook;
		return prevValue;
	}
	function startTransition(fiber, queue, pendingState, finishedState, callback) {
		var previousPriority = ReactDOMSharedInternals.a;
		ReactDOMSharedInternals.a = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
		var prevTransition = ReactSharedInternals.T, currentTransition = {};
		ReactSharedInternals.T = currentTransition;
		dispatchOptimisticSetState(fiber, false, queue, pendingState);
		try {
			var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
			null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
			if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
				var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
				dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane());
			} else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane());
		} catch (error) {
			dispatchSetStateInternal(fiber, queue, {
				then: function() {},
				status: "rejected",
				reason: error
			}, requestUpdateLane());
		} finally {
			ReactDOMSharedInternals.a = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
		}
	}
	function noop() {}
	function startHostTransition(formFiber, pendingState, action, formData) {
		if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
		var queue = ensureFormComponentIsStateful(formFiber).queue;
		startTransition(formFiber, queue, pendingState, sharedNotPendingObject, null === action ? noop : function() {
			requestFormReset$1(formFiber);
			return action(formData);
		});
	}
	function ensureFormComponentIsStateful(formFiber) {
		var existingStateHook = formFiber.memoizedState;
		if (null !== existingStateHook) return existingStateHook;
		existingStateHook = {
			memoizedState: sharedNotPendingObject,
			baseState: sharedNotPendingObject,
			baseQueue: null,
			queue: {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: basicStateReducer,
				lastRenderedState: sharedNotPendingObject
			}
		};
		var initialResetState = {};
		existingStateHook.next = {
			memoizedState: initialResetState,
			baseState: initialResetState,
			baseQueue: null,
			queue: {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: basicStateReducer,
				lastRenderedState: initialResetState
			},
			next: null
		};
		formFiber.memoizedState = existingStateHook;
		formFiber = formFiber.alternate;
		null !== formFiber && (formFiber.memoizedState = existingStateHook);
		return existingStateHook;
	}
	function requestFormReset$1(formFiber) {
		var stateHook = ensureFormComponentIsStateful(formFiber);
		null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
		dispatchSetStateInternal(formFiber, stateHook.next.queue, {}, requestUpdateLane());
	}
	function useHostTransitionStatus() {
		return readContext(HostTransitionContext);
	}
	function updateId() {
		return updateWorkInProgressHook().memoizedState;
	}
	function updateRefresh() {
		return updateWorkInProgressHook().memoizedState;
	}
	function refreshCache(fiber) {
		for (var provider = fiber.return; null !== provider;) {
			switch (provider.tag) {
				case 24:
				case 3:
					var lane = requestUpdateLane();
					fiber = createUpdate(lane);
					var root$69 = enqueueUpdate(provider, fiber, lane);
					null !== root$69 && (scheduleUpdateOnFiber(root$69, 0, lane), entangleTransitions(root$69, provider, lane));
					provider = { cache: createCache() };
					fiber.payload = provider;
					return;
			}
			provider = provider.return;
		}
	}
	function dispatchReducerAction(fiber, queue, action) {
		var lane = requestUpdateLane();
		action = {
			lane,
			revertLane: 0,
			gesture: null,
			action,
			hasEagerState: false,
			eagerState: null,
			next: null
		};
		isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, 0, lane), entangleTransitionUpdate(action, queue, lane)));
	}
	function dispatchSetState(fiber, queue, action) {
		var lane = requestUpdateLane();
		dispatchSetStateInternal(fiber, queue, action, lane);
	}
	function dispatchSetStateInternal(fiber, queue, action, lane) {
		var update = {
			lane,
			revertLane: 0,
			gesture: null,
			action,
			hasEagerState: false,
			eagerState: null,
			next: null
		};
		if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
		else {
			var alternate = fiber.alternate;
			if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) try {
				var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
				update.hasEagerState = true;
				update.eagerState = eagerState;
				if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates();
			} catch {}
			action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
			if (null !== action) return scheduleUpdateOnFiber(action, 0, lane), entangleTransitionUpdate(action, queue, lane);
		}
		return;
	}
	function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
		action = {
			lane: 2,
			revertLane: requestTransitionLane(),
			gesture: null,
			action,
			hasEagerState: false,
			eagerState: null,
			next: null
		};
		if (isRenderPhaseUpdate(fiber)) {
			if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
		} else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, 0, 2);
	}
	function isRenderPhaseUpdate(fiber) {
		var alternate = fiber.alternate;
		return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
	}
	function enqueueRenderPhaseUpdate(queue, update) {
		didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
		var pending = queue.pending;
		null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
		queue.pending = update;
	}
	function entangleTransitionUpdate(root, queue, lane) {
		if (0 !== (lane & 4194048)) {
			var queueLanes = queue.lanes;
			queueLanes &= root.pendingLanes;
			lane |= queueLanes;
			queue.lanes = lane;
			markRootEntangled(root, lane);
		}
	}
	var ContextOnlyDispatcher = {
		readContext,
		use,
		useCallback: throwInvalidHookError,
		useContext: throwInvalidHookError,
		useEffect: throwInvalidHookError,
		useImperativeHandle: throwInvalidHookError,
		useLayoutEffect: throwInvalidHookError,
		useInsertionEffect: throwInvalidHookError,
		useMemo: throwInvalidHookError,
		useReducer: throwInvalidHookError,
		useRef: throwInvalidHookError,
		useState: throwInvalidHookError,
		useDebugValue: throwInvalidHookError,
		useDeferredValue: throwInvalidHookError,
		useTransition: throwInvalidHookError,
		useSyncExternalStore: throwInvalidHookError,
		useId: throwInvalidHookError,
		useHostTransitionStatus: throwInvalidHookError,
		useFormState: throwInvalidHookError,
		useActionState: throwInvalidHookError,
		useOptimistic: throwInvalidHookError,
		useMemoCache: throwInvalidHookError,
		useCacheRefresh: throwInvalidHookError
	};
	ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
	var HooksDispatcherOnMount = {
		readContext,
		use,
		useCallback: function(callback, deps) {
			mountWorkInProgressHook().memoizedState = [callback, void 0 === deps ? null : deps];
			return callback;
		},
		useContext: readContext,
		useEffect: mountEffect,
		useImperativeHandle: function(ref, create, deps) {
			deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
			mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(0, create, ref), deps);
		},
		useLayoutEffect: function(create, deps) {
			return mountEffectImpl(4194308, 4, create, deps), void 0;
		},
		useInsertionEffect: function(create, deps) {
			mountEffectImpl(4, 2, create, deps);
		},
		useMemo: function(nextCreate, deps) {
			var hook = mountWorkInProgressHook();
			deps = void 0 === deps ? null : deps;
			var nextValue = nextCreate();
			if (shouldDoubleInvokeUserFnsInHooksDEV) {
				setIsStrictModeForDevtools(true);
				try {
					nextCreate();
				} finally {
					setIsStrictModeForDevtools(false);
				}
			}
			hook.memoizedState = [nextValue, deps];
			return nextValue;
		},
		useReducer: function(reducer, initialArg, init) {
			var hook = mountWorkInProgressHook();
			if (void 0 !== init) {
				var initialState = init(initialArg);
				if (shouldDoubleInvokeUserFnsInHooksDEV) {
					setIsStrictModeForDevtools(true);
					try {
						init(initialArg);
					} finally {
						setIsStrictModeForDevtools(false);
					}
				}
			} else initialState = initialArg;
			hook.memoizedState = hook.baseState = initialState;
			reducer = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: reducer,
				lastRenderedState: initialState
			};
			hook.queue = reducer;
			reducer = reducer.dispatch = dispatchReducerAction.bind(0, currentlyRenderingFiber, reducer);
			return [hook.memoizedState, reducer];
		},
		useRef: function(initialValue) {
			var hook = mountWorkInProgressHook();
			initialValue = { current: initialValue };
			return hook.memoizedState = initialValue;
		},
		useState: function(initialState) {
			initialState = mountStateImpl(initialState);
			var queue = initialState.queue, dispatch = dispatchSetState.bind(0, currentlyRenderingFiber, queue);
			queue.dispatch = dispatch;
			return [initialState.memoizedState, dispatch];
		},
		useDebugValue: mountDebugValue,
		useDeferredValue: function(value, initialValue) {
			var hook = mountWorkInProgressHook();
			return mountDeferredValueImpl(hook, value, initialValue);
		},
		useTransition: function() {
			var stateHook = mountStateImpl(false);
			stateHook = startTransition.bind(0, currentlyRenderingFiber, stateHook.queue, true, false);
			mountWorkInProgressHook().memoizedState = stateHook;
			return [false, stateHook];
		},
		useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
			var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
			if (isHydrating) {
				if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
				getServerSnapshot = getServerSnapshot();
			} else {
				getServerSnapshot = getSnapshot();
				if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
				0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
			}
			hook.memoizedState = getServerSnapshot;
			var inst = {
				value: getServerSnapshot,
				getSnapshot
			};
			hook.queue = inst;
			mountEffect(subscribeToStore.bind(0, fiber, inst, subscribe), [subscribe]);
			fiber.flags |= 2048;
			pushSimpleEffect(9, { destroy: void 0 }, updateStoreInstance.bind(0, fiber, inst, getServerSnapshot, getSnapshot), null);
			return getServerSnapshot;
		},
		useId: function() {
			var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
			if (isHydrating) {
				var JSCompiler_inline_result = treeContextOverflow;
				var idWithLeadingBit = treeContextId;
				JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
				identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
				JSCompiler_inline_result = localIdCounter++;
				0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
				identifierPrefix += "_";
			} else JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
			return hook.memoizedState = identifierPrefix;
		},
		useHostTransitionStatus,
		useFormState: mountActionState,
		useActionState: mountActionState,
		useOptimistic: function(passthrough) {
			var hook = mountWorkInProgressHook();
			hook.memoizedState = hook.baseState = passthrough;
			var queue = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: null,
				lastRenderedState: null
			};
			hook.queue = queue;
			hook = dispatchOptimisticSetState.bind(0, currentlyRenderingFiber, true, queue);
			queue.dispatch = hook;
			return [passthrough, hook];
		},
		useMemoCache,
		useCacheRefresh: function() {
			return mountWorkInProgressHook().memoizedState = refreshCache.bind(0, currentlyRenderingFiber);
		},
		useEffectEvent: function(callback) {
			var hook = mountWorkInProgressHook(), ref = { impl: callback };
			hook.memoizedState = ref;
			return function() {
				if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
				return ref.impl.apply(void 0, arguments);
			};
		}
	}, HooksDispatcherOnUpdate = {
		readContext,
		use,
		useCallback: updateCallback,
		useContext: readContext,
		useEffect: updateEffect,
		useImperativeHandle: updateImperativeHandle,
		useInsertionEffect: updateInsertionEffect,
		useLayoutEffect: updateLayoutEffect,
		useMemo: updateMemo,
		useReducer: updateReducer,
		useRef: updateRef,
		useState: function() {
			return updateReducer(basicStateReducer);
		},
		useDebugValue: mountDebugValue,
		useDeferredValue: function(value, initialValue) {
			var hook = updateWorkInProgressHook();
			return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
		},
		useTransition: function() {
			var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
			return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
		},
		useSyncExternalStore: updateSyncExternalStore,
		useId: updateId,
		useHostTransitionStatus,
		useFormState: updateActionState,
		useActionState: updateActionState,
		useOptimistic: function(passthrough, reducer) {
			var hook = updateWorkInProgressHook();
			return updateOptimisticImpl(hook, 0, passthrough, reducer);
		},
		useMemoCache,
		useCacheRefresh: updateRefresh
	};
	HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
	var HooksDispatcherOnRerender = {
		readContext,
		use,
		useCallback: updateCallback,
		useContext: readContext,
		useEffect: updateEffect,
		useImperativeHandle: updateImperativeHandle,
		useInsertionEffect: updateInsertionEffect,
		useLayoutEffect: updateLayoutEffect,
		useMemo: updateMemo,
		useReducer: rerenderReducer,
		useRef: updateRef,
		useState: function() {
			return rerenderReducer(basicStateReducer);
		},
		useDebugValue: mountDebugValue,
		useDeferredValue: function(value, initialValue) {
			var hook = updateWorkInProgressHook();
			return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
		},
		useTransition: function() {
			var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
			return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
		},
		useSyncExternalStore: updateSyncExternalStore,
		useId: updateId,
		useHostTransitionStatus,
		useFormState: rerenderActionState,
		useActionState: rerenderActionState,
		useOptimistic: function(passthrough, reducer) {
			var hook = updateWorkInProgressHook();
			if (null !== currentHook) return updateOptimisticImpl(hook, 0, passthrough, reducer);
			hook.baseState = passthrough;
			return [passthrough, hook.queue.dispatch];
		},
		useMemoCache,
		useCacheRefresh: updateRefresh
	};
	HooksDispatcherOnRerender.useEffectEvent = updateEvent;
	function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
		ctor = workInProgress.memoizedState;
		getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
		getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
		workInProgress.memoizedState = getDerivedStateFromProps;
		0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
	}
	var classComponentUpdater = {
		enqueueSetState: function(inst, payload, callback) {
			inst = inst._reactInternals;
			var lane = requestUpdateLane(), update = createUpdate(lane);
			update.payload = payload;
			void 0 !== callback && null !== callback && (update.callback = callback);
			payload = enqueueUpdate(inst, update, lane);
			null !== payload && (scheduleUpdateOnFiber(payload, 0, lane), entangleTransitions(payload, inst, lane));
		},
		enqueueReplaceState: function(inst, payload, callback) {
			inst = inst._reactInternals;
			var lane = requestUpdateLane(), update = createUpdate(lane);
			update.tag = 1;
			update.payload = payload;
			void 0 !== callback && null !== callback && (update.callback = callback);
			payload = enqueueUpdate(inst, update, lane);
			null !== payload && (scheduleUpdateOnFiber(payload, 0, lane), entangleTransitions(payload, inst, lane));
		},
		enqueueForceUpdate: function(inst, callback) {
			inst = inst._reactInternals;
			var lane = requestUpdateLane(), update = createUpdate(lane);
			update.tag = 2;
			void 0 !== callback && null !== callback && (update.callback = callback);
			callback = enqueueUpdate(inst, update, lane);
			null !== callback && (scheduleUpdateOnFiber(callback, 0, lane), entangleTransitions(callback, inst, lane));
		}
	};
	function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
		workInProgress = workInProgress.stateNode;
		return "function" === typeof workInProgress.shouldComponentUpdate ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
	}
	function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
		workInProgress = instance.state;
		"function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
		"function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
		instance.state !== workInProgress && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
	}
	function resolveClassComponentProps(Component, baseProps) {
		var newProps = baseProps;
		if ("ref" in baseProps) {
			newProps = {};
			for (var propName in baseProps) "ref" !== propName && (newProps[propName] = baseProps[propName]);
		}
		if (Component = Component.defaultProps) {
			newProps === baseProps && (newProps = assign({}, newProps));
			for (var propName$73 in Component) void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
		}
		return newProps;
	}
	function defaultOnUncaughtError(error) {
		reportGlobalError(error);
	}
	function defaultOnCaughtError(error) {
		console.error(error);
	}
	function defaultOnRecoverableError(error) {
		reportGlobalError(error);
	}
	function logUncaughtError(root, errorInfo) {
		try {
			var onUncaughtError = root.onUncaughtError;
			onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
		} catch (e$74) {
			setTimeout(function() {
				throw e$74;
			});
		}
	}
	function logCaughtError(root, boundary, errorInfo) {
		try {
			var onCaughtError = root.onCaughtError;
			onCaughtError(errorInfo.value, {
				componentStack: errorInfo.stack,
				errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
			});
		} catch (e$75) {
			setTimeout(function() {
				throw e$75;
			});
		}
	}
	function createRootErrorUpdate(root, errorInfo, lane) {
		lane = createUpdate(lane);
		lane.tag = 3;
		lane.payload = { element: null };
		lane.callback = function() {
			logUncaughtError(root, errorInfo);
		};
		return lane;
	}
	function createClassErrorUpdate(lane) {
		lane = createUpdate(lane);
		lane.tag = 3;
		return lane;
	}
	function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
		var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
		if ("function" === typeof getDerivedStateFromError) {
			var error = errorInfo.value;
			update.payload = function() {
				return getDerivedStateFromError(error);
			};
			update.callback = function() {
				logCaughtError(root, fiber, errorInfo);
			};
		}
		var inst = fiber.stateNode;
		null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
			logCaughtError(root, fiber, errorInfo);
			"function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
			var stack = errorInfo.stack;
			this.componentDidCatch(errorInfo.value, { componentStack: null !== stack ? stack : "" });
		});
	}
	function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
		sourceFiber.flags |= 32768;
		if (null !== value && "object" === typeof value && "function" === typeof value.then) {
			returnFiber = sourceFiber.alternate;
			null !== returnFiber && propagateParentContextChanges(0, sourceFiber, rootRenderLanes, true);
			sourceFiber = suspenseHandlerStackCursor.current;
			if (null !== sourceFiber) {
				switch (sourceFiber.tag) {
					case 31:
					case 13: return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), false;
					case 22: return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
						transitions: null,
						markerInstances: null,
						retryQueue: new Set([value])
					}, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), false;
				}
				throw Error(formatProdErrorMessage(435, sourceFiber.tag));
			}
			attachPingListener(root, value, rootRenderLanes);
			renderDidSuspendDelayIfPossible();
			return false;
		}
		if (isHydrating) return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), { cause: value }), queueHydrationError(createCapturedValueAtFiber(returnFiber, sourceFiber))), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
		var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
		wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
		null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
		4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
		if (null === returnFiber) return true;
		value = createCapturedValueAtFiber(value, sourceFiber);
		sourceFiber = returnFiber;
		do {
			switch (sourceFiber.tag) {
				case 3: return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), false;
				case 1: if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
			}
			sourceFiber = sourceFiber.return;
		} while (null !== sourceFiber);
		return false;
	}
	var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
	function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
		workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
	}
	function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
		Component = Component.render;
		var ref = workInProgress.ref;
		if ("ref" in nextProps) {
			var propsWithoutRef = {};
			for (var key in nextProps) "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
		} else propsWithoutRef = nextProps;
		prepareToReadContext(workInProgress);
		nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);
		key = checkDidRenderIdHook();
		if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		isHydrating && key && pushMaterializedTreeId(workInProgress);
		workInProgress.flags |= 1;
		reconcileChildren(current, workInProgress, nextProps, renderLanes);
		return workInProgress.child;
	}
	function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
		if (null === current) {
			var type = Component.type;
			if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return workInProgress.tag = 15, workInProgress.type = type, updateSimpleMemoComponent(current, workInProgress, type, nextProps, renderLanes);
			current = createFiberFromTypeAndProps(Component.type, null, nextProps, 0, workInProgress.mode, renderLanes);
			current.ref = workInProgress.ref;
			current.return = workInProgress;
			return workInProgress.child = current;
		}
		type = current.child;
		if (!checkScheduledUpdateOrContext(current, renderLanes)) {
			var prevProps = type.memoizedProps;
			Component = Component.compare;
			Component = null !== Component ? Component : shallowEqual;
			if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		}
		workInProgress.flags |= 1;
		current = createWorkInProgress(type, nextProps);
		current.ref = workInProgress.ref;
		current.return = workInProgress;
		return workInProgress.child = current;
	}
	function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
		if (null !== current) {
			var prevProps = current.memoizedProps;
			if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref) if (didReceiveUpdate = false, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = true);
			else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		}
		return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
	}
	function updateOffscreenComponent(current, workInProgress, renderLanes, nextProps) {
		var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
		null === current && null === workInProgress.stateNode && (workInProgress.stateNode = {
			_visibility: 1,
			_pendingMarkers: null,
			_retryCache: null,
			_transitions: null
		});
		if ("hidden" === nextProps.mode) {
			if (0 !== (workInProgress.flags & 128)) {
				prevState = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
				if (null !== current) {
					nextProps = workInProgress.child = current.child;
					for (nextChildren = 0; null !== nextProps;) nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
					nextProps = nextChildren & ~prevState;
				} else nextProps = 0, workInProgress.child = null;
				return deferHiddenOffscreenComponent(current, workInProgress, prevState, renderLanes, nextProps), null;
			}
			if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {
				baseLanes: 0,
				cachePool: null
			}, null !== current && pushTransition(0, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(0, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress);
			else return nextProps = workInProgress.lanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes, nextProps), null;
		} else null !== prevState ? (pushTransition(0, prevState.cachePool), pushHiddenContext(0, prevState), reuseSuspenseHandlerOnStack(), workInProgress.memoizedState = null) : (null !== current && pushTransition(0, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
		reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		return workInProgress.child;
	}
	function bailoutOffscreenComponent(current, workInProgress) {
		null !== current && 22 === current.tag || null !== workInProgress.stateNode || (workInProgress.stateNode = {
			_visibility: 1,
			_pendingMarkers: null,
			_retryCache: null,
			_transitions: null
		});
		return workInProgress.sibling;
	}
	function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes, remainingChildLanes) {
		var JSCompiler_inline_result = peekCacheFromPool();
		JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
			parent: CacheContext._currentValue,
			pool: JSCompiler_inline_result
		};
		workInProgress.memoizedState = {
			baseLanes: nextBaseLanes,
			cachePool: JSCompiler_inline_result
		};
		null !== current && pushTransition(0, null);
		reuseHiddenContextOnStack();
		pushOffscreenSuspenseHandler(workInProgress);
		null !== current && propagateParentContextChanges(0, workInProgress, renderLanes, true);
		workInProgress.childLanes = remainingChildLanes;
		return;
	}
	function mountActivityChildren(workInProgress, nextProps) {
		nextProps = mountWorkInProgressOffscreenFiber({
			mode: nextProps.mode,
			children: nextProps.children
		}, workInProgress.mode);
		nextProps.ref = workInProgress.ref;
		workInProgress.child = nextProps;
		nextProps.return = workInProgress;
		return nextProps;
	}
	function retryActivityComponentWithoutHydrating(current, workInProgress, renderLanes) {
		reconcileChildFibers(workInProgress, current.child, null, renderLanes);
		current = mountActivityChildren(workInProgress, workInProgress.pendingProps);
		current.flags |= 2;
		popSuspenseHandler(workInProgress);
		workInProgress.memoizedState = null;
		return current;
	}
	function updateActivityComponent(current, workInProgress, renderLanes) {
		var nextProps = workInProgress.pendingProps, didSuspend = 0 !== (workInProgress.flags & 128);
		workInProgress.flags &= -129;
		if (null === current) {
			if (isHydrating) {
				if ("hidden" === nextProps.mode) return current = mountActivityChildren(workInProgress, nextProps), workInProgress.lanes = 536870912, bailoutOffscreenComponent(null, current);
				pushDehydratedActivitySuspenseHandler(workInProgress);
				(current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(current, rootOrSingletonContext), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress.memoizedState = {
					dehydrated: current,
					treeContext: null !== treeContextProvider ? {
						id: treeContextId,
						overflow: treeContextOverflow
					} : null,
					retryLane: 536870912,
					hydrationErrors: null
				}, renderLanes = createFiberFromDehydratedFragment(current), renderLanes.return = workInProgress, workInProgress.child = renderLanes, hydrationParentFiber = workInProgress, nextHydratableInstance = null)) : current = null;
				if (null === current) throw throwOnHydrationMismatch(workInProgress);
				workInProgress.lanes = 536870912;
				return null;
			}
			return mountActivityChildren(workInProgress, nextProps);
		}
		var prevState = current.memoizedState;
		if (null !== prevState) {
			var dehydrated = prevState.dehydrated;
			pushDehydratedActivitySuspenseHandler(workInProgress);
			if (didSuspend) if (workInProgress.flags & 256) workInProgress.flags &= -257, workInProgress = retryActivityComponentWithoutHydrating(current, workInProgress, renderLanes);
			else if (null !== workInProgress.memoizedState) workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null;
			else throw Error(formatProdErrorMessage(558));
			else if (didReceiveUpdate || propagateParentContextChanges(0, workInProgress, renderLanes, false), didSuspend = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || didSuspend) {
				nextProps = workInProgressRoot;
				if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes), 0 !== dehydrated && dehydrated !== prevState.retryLane)) throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, 0, dehydrated), SelectiveHydrationException;
				renderDidSuspendDelayIfPossible();
				workInProgress = retryActivityComponentWithoutHydrating(current, workInProgress, renderLanes);
			} else current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress, current), workInProgress = mountActivityChildren(workInProgress, nextProps), workInProgress.flags |= 4096;
			return workInProgress;
		}
		current = createWorkInProgress(current.child, {
			mode: nextProps.mode,
			children: nextProps.children
		});
		current.ref = workInProgress.ref;
		workInProgress.child = current;
		current.return = workInProgress;
		return current;
	}
	function markRef(current, workInProgress) {
		var ref = workInProgress.ref;
		if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 4194816);
		else {
			if ("function" !== typeof ref && "object" !== typeof ref) throw Error(formatProdErrorMessage(284));
			if (null === current || current.ref !== ref) workInProgress.flags |= 4194816;
		}
	}
	function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
		prepareToReadContext(workInProgress);
		Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);
		nextProps = checkDidRenderIdHook();
		if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
		workInProgress.flags |= 1;
		reconcileChildren(current, workInProgress, Component, renderLanes);
		return workInProgress.child;
	}
	function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {
		prepareToReadContext(workInProgress);
		workInProgress.updateQueue = null;
		nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);
		finishRenderingHooks(current);
		Component = checkDidRenderIdHook();
		if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		isHydrating && Component && pushMaterializedTreeId(workInProgress);
		workInProgress.flags |= 1;
		reconcileChildren(current, workInProgress, nextProps, renderLanes);
		return workInProgress.child;
	}
	function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
		prepareToReadContext(workInProgress);
		if (null === workInProgress.stateNode) {
			var context = emptyContextObject, contextType = Component.contextType;
			"object" === typeof contextType && null !== contextType && (context = readContext(contextType));
			context = new Component(nextProps, context);
			workInProgress.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
			context.updater = classComponentUpdater;
			workInProgress.stateNode = context;
			context._reactInternals = workInProgress;
			context = workInProgress.stateNode;
			context.props = nextProps;
			context.state = workInProgress.memoizedState;
			context.refs = {};
			initializeUpdateQueue(workInProgress);
			contextType = Component.contextType;
			context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
			context.state = workInProgress.memoizedState;
			contextType = Component.getDerivedStateFromProps;
			"function" === typeof contextType && (applyDerivedStateFromProps(workInProgress, 0, contextType, nextProps), context.state = workInProgress.memoizedState);
			"function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress, nextProps, context, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress.memoizedState);
			"function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308);
			nextProps = true;
		} else if (null === current) {
			context = workInProgress.stateNode;
			var unresolvedOldProps = workInProgress.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
			context.props = oldProps;
			var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
			contextType = emptyContextObject;
			"object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
			var getDerivedStateFromProps = Component.getDerivedStateFromProps;
			contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
			unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
			contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(0, context, nextProps, contextType);
			hasForceUpdate = false;
			var oldState = workInProgress.memoizedState;
			context.state = oldState;
			processUpdateQueue(workInProgress, nextProps, context, renderLanes);
			suspendIfUpdateReadFromEntangledAsyncAction();
			oldContext = workInProgress.memoizedState;
			unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, 0, getDerivedStateFromProps, nextProps), oldContext = workInProgress.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldState, oldContext, contextType)) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308), nextProps = false);
		} else {
			context = workInProgress.stateNode;
			cloneUpdateQueue(current, workInProgress);
			contextType = workInProgress.memoizedProps;
			contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
			context.props = contextType$jscomp$0;
			getDerivedStateFromProps = workInProgress.pendingProps;
			oldState = context.context;
			oldContext = Component.contextType;
			oldProps = emptyContextObject;
			"object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
			unresolvedOldProps = Component.getDerivedStateFromProps;
			(oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(0, context, nextProps, oldProps);
			hasForceUpdate = false;
			oldState = workInProgress.memoizedState;
			context.state = oldState;
			processUpdateQueue(workInProgress, nextProps, context, renderLanes);
			suspendIfUpdateReadFromEntangledAsyncAction();
			var newState = workInProgress.memoizedState;
			contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, 0, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, contextType$jscomp$0, nextProps, oldState, newState, oldProps) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(nextProps, newState, oldProps)), "function" === typeof context.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), nextProps = false);
		}
		context = nextProps;
		markRef(current, workInProgress);
		nextProps = 0 !== (workInProgress.flags & 128);
		context || nextProps ? (context = workInProgress.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress.flags |= 1, null !== current && nextProps ? (workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current, workInProgress, Component, renderLanes), workInProgress.memoizedState = context.state, current = workInProgress.child) : current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		return current;
	}
	function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {
		resetHydrationState();
		workInProgress.flags |= 256;
		reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		return workInProgress.child;
	}
	var SUSPENDED_MARKER = {
		dehydrated: null,
		treeContext: null,
		retryLane: 0,
		hydrationErrors: null
	};
	function mountSuspenseOffscreenState(renderLanes) {
		return {
			baseLanes: renderLanes,
			cachePool: getSuspendedCache()
		};
	}
	function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {
		current = null !== current ? current.childLanes & ~renderLanes : 0;
		primaryTreeDidDefer && (current |= workInProgressDeferredLane);
		return current;
	}
	function updateSuspenseComponent(current, workInProgress, renderLanes) {
		var nextProps = workInProgress.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress.flags & 128), JSCompiler_temp;
		(JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
		JSCompiler_temp && (showFallback = true, workInProgress.flags &= -129);
		JSCompiler_temp = 0 !== (workInProgress.flags & 32);
		workInProgress.flags &= -33;
		if (null === current) {
			if (isHydrating) {
				showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack();
				(current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(current, rootOrSingletonContext), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress.memoizedState = {
					dehydrated: current,
					treeContext: null !== treeContextProvider ? {
						id: treeContextId,
						overflow: treeContextOverflow
					} : null,
					retryLane: 536870912,
					hydrationErrors: null
				}, renderLanes = createFiberFromDehydratedFragment(current), renderLanes.return = workInProgress, workInProgress.child = renderLanes, hydrationParentFiber = workInProgress, nextHydratableInstance = null)) : current = null;
				if (null === current) throw throwOnHydrationMismatch(workInProgress);
				isSuspenseInstanceFallback(current) ? workInProgress.lanes = 32 : workInProgress.lanes = 536870912;
				return null;
			}
			var nextPrimaryChildren = nextProps.children;
			nextProps = nextProps.fallback;
			if (showFallback) return reuseSuspenseHandlerOnStack(), showFallback = workInProgress.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber({
				mode: "hidden",
				children: nextPrimaryChildren
			}, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextPrimaryChildren.return = workInProgress, nextProps.return = workInProgress, nextPrimaryChildren.sibling = nextProps, workInProgress.child = nextPrimaryChildren, nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
			pushPrimaryTreeSuspenseHandler(workInProgress);
			return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);
		}
		var prevState = current.memoizedState;
		if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
			if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({
				mode: "visible",
				children: nextProps.children
			}, showFallback), nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes, null), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress, nextPrimaryChildren.return = workInProgress, nextProps.sibling = nextPrimaryChildren, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = bailoutOffscreenComponent(null, nextProps));
			else if (pushPrimaryTreeSuspenseHandler(workInProgress), isSuspenseInstanceFallback(nextPrimaryChildren)) {
				JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
				if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
				JSCompiler_temp = digest;
				nextProps = Error(formatProdErrorMessage(419));
				nextProps.stack = "";
				nextProps.digest = JSCompiler_temp;
				queueHydrationError({
					value: nextProps,
					source: null,
					stack: null
				});
				workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
			} else if (didReceiveUpdate || propagateParentContextChanges(0, workInProgress, renderLanes, false), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
				JSCompiler_temp = workInProgressRoot;
				if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes), 0 !== nextProps && nextProps !== prevState.retryLane)) throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, 0, nextProps), SelectiveHydrationException;
				isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
				workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
			} else isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress.flags |= 192, workInProgress.child = current.child, workInProgress = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(nextPrimaryChildren.nextSibling), hydrationParentFiber = workInProgress, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress, current), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);
			return workInProgress;
		}
		if (showFallback) return reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
			mode: "hidden",
			children: nextProps.children
		}), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(digest, nextPrimaryChildren) : (nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes, null), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = nextPrimaryChildren, workInProgress.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? {
			parent: prevState,
			pool: prevState
		} : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
			baseLanes: nextPrimaryChildren.baseLanes | renderLanes,
			cachePool: showFallback
		}), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
		pushPrimaryTreeSuspenseHandler(workInProgress);
		renderLanes = current.child;
		current = renderLanes.sibling;
		renderLanes = createWorkInProgress(renderLanes, {
			mode: "visible",
			children: nextProps.children
		});
		renderLanes.return = workInProgress;
		renderLanes.sibling = null;
		null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [current], workInProgress.flags |= 16) : JSCompiler_temp.push(current));
		workInProgress.child = renderLanes;
		workInProgress.memoizedState = null;
		return renderLanes;
	}
	function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
		primaryChildren = mountWorkInProgressOffscreenFiber({
			mode: "visible",
			children: primaryChildren
		}, workInProgress.mode);
		primaryChildren.return = workInProgress;
		return workInProgress.child = primaryChildren;
	}
	function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
		offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
		offscreenProps.lanes = 0;
		return offscreenProps;
	}
	function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {
		reconcileChildFibers(workInProgress, current.child, null, renderLanes);
		current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);
		current.flags |= 2;
		workInProgress.memoizedState = null;
		return current;
	}
	function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
		fiber.lanes |= renderLanes;
		var alternate = fiber.alternate;
		null !== alternate && (alternate.lanes |= renderLanes);
		scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
	}
	function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, treeForkCount) {
		var renderState = workInProgress.memoizedState;
		null === renderState ? workInProgress.memoizedState = {
			isBackwards,
			rendering: null,
			renderingStartTime: 0,
			last: lastContentRow,
			tail,
			tailMode,
			treeForkCount
		} : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount);
	}
	function updateSuspenseListComponent(current, workInProgress, renderLanes) {
		var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
		nextProps = nextProps.children;
		var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
		shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress.flags |= 128) : suspenseContext &= 1;
		push(suspenseStackCursor, suspenseContext);
		reconcileChildren(current, workInProgress, nextProps, renderLanes);
		nextProps = isHydrating ? treeForkCount : 0;
		if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress.child; null !== current;) {
			if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
			else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
			else if (null !== current.child) {
				current.child.return = current;
				current = current.child;
				continue;
			}
			if (current === workInProgress) break a;
			for (; null === current.sibling;) {
				if (null === current.return || current.return === workInProgress) break a;
				current = current.return;
			}
			current.sibling.return = current.return;
			current = current.sibling;
		}
		switch (revealOrder) {
			case "forwards":
				renderLanes = workInProgress.child;
				for (revealOrder = null; null !== renderLanes;) current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;
				renderLanes = revealOrder;
				null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);
				initSuspenseListRenderState(workInProgress, false, revealOrder, renderLanes, tailMode, nextProps);
				break;
			case "backwards":
			case "unstable_legacy-backwards":
				renderLanes = null;
				revealOrder = workInProgress.child;
				for (workInProgress.child = null; null !== revealOrder;) {
					current = revealOrder.alternate;
					if (null !== current && null === findFirstSuspended(current)) {
						workInProgress.child = revealOrder;
						break;
					}
					current = revealOrder.sibling;
					revealOrder.sibling = renderLanes;
					renderLanes = revealOrder;
					revealOrder = current;
				}
				initSuspenseListRenderState(workInProgress, true, renderLanes, null, tailMode, nextProps);
				break;
			case "together":
				initSuspenseListRenderState(workInProgress, false, null, null, void 0, nextProps);
				break;
			default: workInProgress.memoizedState = null;
		}
		return workInProgress.child;
	}
	function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
		null !== current && (workInProgress.dependencies = current.dependencies);
		workInProgressRootSkippedLanes |= workInProgress.lanes;
		if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {
			if (propagateParentContextChanges(0, workInProgress, renderLanes, false), 0 === (renderLanes & workInProgress.childLanes)) return null;
		} else return null;
		if (null !== current && workInProgress.child !== current.child) throw Error(formatProdErrorMessage(153));
		if (null !== workInProgress.child) {
			current = workInProgress.child;
			renderLanes = createWorkInProgress(current, current.pendingProps);
			workInProgress.child = renderLanes;
			for (renderLanes.return = workInProgress; null !== current.sibling;) current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;
			renderLanes.sibling = null;
		}
		return workInProgress.child;
	}
	function checkScheduledUpdateOrContext(current, renderLanes) {
		if (0 !== (current.lanes & renderLanes)) return true;
		current = current.dependencies;
		return null !== current && checkIfContextChanged(current) ? true : false;
	}
	function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
		switch (workInProgress.tag) {
			case 3:
				pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
				pushProvider(0, CacheContext, current.memoizedState.cache);
				resetHydrationState();
				break;
			case 27:
			case 5:
				pushHostContext(workInProgress);
				break;
			case 4:
				pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
				break;
			case 10:
				pushProvider(0, workInProgress.type, workInProgress.memoizedProps.value);
				break;
			case 31:
				if (null !== workInProgress.memoizedState) return workInProgress.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress), null;
				break;
			case 13:
				var state$102 = workInProgress.memoizedState;
				if (null !== state$102) {
					if (null !== state$102.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;
					if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
					pushPrimaryTreeSuspenseHandler(workInProgress);
					current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
					return null !== current ? current.sibling : null;
				}
				pushPrimaryTreeSuspenseHandler(workInProgress);
				break;
			case 19:
				var didSuspendBefore = 0 !== (current.flags & 128);
				state$102 = 0 !== (renderLanes & workInProgress.childLanes);
				state$102 || (propagateParentContextChanges(0, workInProgress, renderLanes, false), state$102 = 0 !== (renderLanes & workInProgress.childLanes));
				if (didSuspendBefore) {
					if (state$102) return updateSuspenseListComponent(current, workInProgress, renderLanes);
					workInProgress.flags |= 128;
				}
				didSuspendBefore = workInProgress.memoizedState;
				null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
				push(suspenseStackCursor, suspenseStackCursor.current);
				if (state$102) break;
				else return null;
			case 22: return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes, workInProgress.pendingProps);
			case 24: pushProvider(0, CacheContext, current.memoizedState.cache);
		}
		return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
	}
	function beginWork(current, workInProgress, renderLanes) {
		if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps) didReceiveUpdate = true;
		else {
			if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);
			didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
		}
		else didReceiveUpdate = false, isHydrating && 0 !== (workInProgress.flags & 1048576) && pushTreeId(workInProgress, treeForkCount, workInProgress.index);
		workInProgress.lanes = 0;
		switch (workInProgress.tag) {
			case 16:
				a: {
					var props = workInProgress.pendingProps;
					current = resolveLazy(workInProgress.elementType);
					workInProgress.type = current;
					if ("function" === typeof current) shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress.tag = 1, workInProgress = updateClassComponent(null, workInProgress, current, props, renderLanes)) : (workInProgress.tag = 0, workInProgress = updateFunctionComponent(null, workInProgress, current, props, renderLanes));
					else {
						if (void 0 !== current && null !== current) {
							var $$typeof = current.$$typeof;
							if ($$typeof === REACT_FORWARD_REF_TYPE) {
								workInProgress.tag = 11;
								workInProgress = updateForwardRef(null, workInProgress, current, props, renderLanes);
								break a;
							} else if ($$typeof === REACT_MEMO_TYPE) {
								workInProgress.tag = 14;
								workInProgress = updateMemoComponent(null, workInProgress, current, props, renderLanes);
								break a;
							}
						}
						workInProgress = getComponentNameFromType(current) || current;
						throw Error(formatProdErrorMessage(306, workInProgress, ""));
					}
				}
				return workInProgress;
			case 0: return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
			case 1: return props = workInProgress.type, $$typeof = resolveClassComponentProps(props, workInProgress.pendingProps), updateClassComponent(current, workInProgress, props, $$typeof, renderLanes);
			case 3:
				a: {
					pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
					if (null === current) throw Error(formatProdErrorMessage(387));
					props = workInProgress.pendingProps;
					var prevState = workInProgress.memoizedState;
					$$typeof = prevState.element;
					cloneUpdateQueue(current, workInProgress);
					processUpdateQueue(workInProgress, props, null, renderLanes);
					var nextState = workInProgress.memoizedState;
					props = nextState.cache;
					pushProvider(0, CacheContext, props);
					props !== prevState.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, true);
					suspendIfUpdateReadFromEntangledAsyncAction();
					props = nextState.element;
					if (prevState.isDehydrated) if (prevState = {
						element: props,
						isDehydrated: false,
						cache: nextState.cache
					}, workInProgress.updateQueue.baseState = prevState, workInProgress.memoizedState = prevState, workInProgress.flags & 256) {
						workInProgress = mountHostRootWithoutHydrating(current, workInProgress, props, renderLanes);
						break a;
					} else if (props !== $$typeof) {
						$$typeof = createCapturedValueAtFiber(Error(formatProdErrorMessage(424)), workInProgress);
						queueHydrationError($$typeof);
						workInProgress = mountHostRootWithoutHydrating(current, workInProgress, props, renderLanes);
						break a;
					} else {
						current = workInProgress.stateNode.containerInfo;
						switch (current.nodeType) {
							case 9:
								current = current.body;
								break;
							default: current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
						}
						nextHydratableInstance = getNextHydratable(current.firstChild);
						hydrationParentFiber = workInProgress;
						isHydrating = true;
						hydrationErrors = null;
						rootOrSingletonContext = true;
						renderLanes = mountChildFibers(workInProgress, null, props, renderLanes);
						for (workInProgress.child = renderLanes; renderLanes;) renderLanes.flags = renderLanes.flags & -3 | 4096, renderLanes = renderLanes.sibling;
					}
					else {
						resetHydrationState();
						if (props === $$typeof) {
							workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
							break a;
						}
						reconcileChildren(current, workInProgress, props, renderLanes);
					}
					workInProgress = workInProgress.child;
				}
				return workInProgress;
			case 26: return markRef(current, workInProgress), null === current ? (renderLanes = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = renderLanes : isHydrating || (renderLanes = workInProgress.type, current = workInProgress.pendingProps, props = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(renderLanes), props[internalInstanceKey] = workInProgress, props[internalPropsKey] = current, setInitialProperties(props, renderLanes, current), markNodeAsHoistable(props), workInProgress.stateNode = props) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;
			case 27: return pushHostContext(workInProgress), null === current && isHydrating && (props = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, 0, rootInstanceStackCursor.current), hydrationParentFiber = workInProgress, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), markRef(current, workInProgress), null === current && (workInProgress.flags |= 4194304), workInProgress.child;
			case 5:
				if (null === current && isHydrating) {
					if ($$typeof = props = nextHydratableInstance) props = canHydrateInstance(props, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== props ? (workInProgress.stateNode = props, hydrationParentFiber = workInProgress, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
					$$typeof || throwOnHydrationMismatch(workInProgress);
				}
				pushHostContext(workInProgress);
				$$typeof = workInProgress.type;
				prevState = workInProgress.pendingProps;
				nextState = null !== current ? current.memoizedProps : null;
				props = prevState.children;
				shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress.flags |= 32);
				null !== workInProgress.memoizedState && ($$typeof = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, 0, 0, renderLanes), HostTransitionContext._currentValue = $$typeof);
				markRef(current, workInProgress);
				reconcileChildren(current, workInProgress, props, renderLanes);
				return workInProgress.child;
			case 6:
				if (null === current && isHydrating) {
					if (current = renderLanes = nextHydratableInstance) renderLanes = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== renderLanes ? (workInProgress.stateNode = renderLanes, hydrationParentFiber = workInProgress, nextHydratableInstance = null, current = true) : current = false;
					current || throwOnHydrationMismatch(workInProgress);
				}
				return null;
			case 13: return updateSuspenseComponent(current, workInProgress, renderLanes);
			case 4: return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), props = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, props, renderLanes) : reconcileChildren(current, workInProgress, props, renderLanes), workInProgress.child;
			case 11: return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
			case 7: return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;
			case 8: return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
			case 12: return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
			case 10: return props = workInProgress.pendingProps, pushProvider(0, workInProgress.type, props.value), reconcileChildren(current, workInProgress, props.children, renderLanes), workInProgress.child;
			case 9: return $$typeof = workInProgress.type._context, props = workInProgress.pendingProps.children, prepareToReadContext(workInProgress), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, props, renderLanes), workInProgress.child;
			case 14: return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
			case 15: return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
			case 19: return updateSuspenseListComponent(current, workInProgress, renderLanes);
			case 31: return updateActivityComponent(current, workInProgress, renderLanes);
			case 22: return updateOffscreenComponent(current, workInProgress, renderLanes, workInProgress.pendingProps);
			case 24: return prepareToReadContext(workInProgress), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes), $$typeof = prevState), workInProgress.memoizedState = {
				parent: props,
				cache: $$typeof
			}, initializeUpdateQueue(workInProgress), pushProvider(0, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress.memoizedState, $$typeof.parent !== props ? ($$typeof = {
				parent: props,
				cache: props
			}, workInProgress.memoizedState = $$typeof, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = $$typeof), pushProvider(0, CacheContext, props)) : (props = prevState.cache, pushProvider(0, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, true))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
			case 29: throw workInProgress.pendingProps;
		}
		throw Error(formatProdErrorMessage(156, workInProgress.tag));
	}
	function markUpdate(workInProgress) {
		workInProgress.flags |= 4;
	}
	function preloadInstanceAndSuspendIfNeeded(workInProgress, type, __unused_9837, __unused_ED90, renderLanes) {
		if (type = 0 !== (workInProgress.mode & 32)) type = false;
		if (type) {
			if (workInProgress.flags |= 16777216, (renderLanes & 335544128) === renderLanes) if (workInProgress.stateNode.complete) workInProgress.flags |= 8192;
			else if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
			else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
		} else workInProgress.flags &= -16777217;
	}
	function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
		if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4)) workInProgress.flags &= -16777217;
		else if (workInProgress.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
		else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
	}
	function scheduleRetryEffect(workInProgress, retryQueue) {
		null !== retryQueue && (workInProgress.flags |= 4);
		workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
	}
	function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
		if (!isHydrating) switch (renderState.tailMode) {
			case "hidden":
				hasRenderedATailFallback = renderState.tail;
				for (var lastTailNode = null; null !== hasRenderedATailFallback;) null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
				null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
				break;
			case "collapsed":
				lastTailNode = renderState.tail;
				for (var lastTailNode$106 = null; null !== lastTailNode;) null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
				null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
		}
	}
	function bubbleProperties(completedWork) {
		var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
		if (didBailout) for (var child$107 = completedWork.child; null !== child$107;) newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
		else for (child$107 = completedWork.child; null !== child$107;) newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
		completedWork.subtreeFlags |= subtreeFlags;
		completedWork.childLanes = newChildLanes;
		return;
	}
	function completeWork(current, workInProgress, renderLanes) {
		var newProps = workInProgress.pendingProps;
		popTreeContext(workInProgress);
		switch (workInProgress.tag) {
			case 16:
			case 15:
			case 0:
			case 11:
			case 7:
			case 8:
			case 12:
			case 9:
			case 14: return bubbleProperties(workInProgress), null;
			case 1: return bubbleProperties(workInProgress), null;
			case 3:
				renderLanes = workInProgress.stateNode;
				newProps = null;
				null !== current && (newProps = current.memoizedState.cache);
				workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);
				popProvider(CacheContext);
				popHostContainer();
				renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);
				if (null === current || null === current.child) popHydrationState(workInProgress) ? markUpdate(workInProgress) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, upgradeHydrationErrorsToRecoverable());
				bubbleProperties(workInProgress);
				return null;
			case 26:
				var type = workInProgress.type, nextResource = workInProgress.memoizedState;
				null === current ? (markUpdate(workInProgress), null !== nextResource ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, 0, 0, 0, renderLanes))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, 0, 0, 0, renderLanes));
				return null;
			case 27:
				popHostContext(workInProgress);
				renderLanes = rootInstanceStackCursor.current;
				type = workInProgress.type;
				if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);
				else {
					if (!newProps) {
						if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
						bubbleProperties(workInProgress);
						return null;
					}
					current = contextStackCursor.current;
					popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress) : (current = resolveSingletonInstance(type, 0, renderLanes), workInProgress.stateNode = current, markUpdate(workInProgress));
				}
				bubbleProperties(workInProgress);
				return null;
			case 5:
				popHostContext(workInProgress);
				type = workInProgress.type;
				if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);
				else {
					if (!newProps) {
						if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
						bubbleProperties(workInProgress);
						return null;
					}
					nextResource = contextStackCursor.current;
					if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress);
					else {
						var ownerDocument = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current);
						switch (nextResource) {
							case 1:
								nextResource = ownerDocument.createElementNS("http://www.w3.org/2000/svg", type);
								break;
							case 2:
								nextResource = ownerDocument.createElementNS("http://www.w3.org/1998/Math/MathML", type);
								break;
							default: switch (type) {
								case "svg":
									nextResource = ownerDocument.createElementNS("http://www.w3.org/2000/svg", type);
									break;
								case "math":
									nextResource = ownerDocument.createElementNS("http://www.w3.org/1998/Math/MathML", type);
									break;
								case "script":
									nextResource = ownerDocument.createElement("div");
									nextResource.innerHTML = "<script><\/script>";
									nextResource = nextResource.removeChild(nextResource.firstChild);
									break;
								case "select":
									nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", { is: newProps.is }) : ownerDocument.createElement("select");
									newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
									break;
								default: nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
							}
						}
						nextResource[internalInstanceKey] = workInProgress;
						nextResource[internalPropsKey] = newProps;
						a: for (ownerDocument = workInProgress.child; null !== ownerDocument;) {
							if (5 === ownerDocument.tag || 6 === ownerDocument.tag) nextResource.appendChild(ownerDocument.stateNode);
							else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
								ownerDocument.child.return = ownerDocument;
								ownerDocument = ownerDocument.child;
								continue;
							}
							if (ownerDocument === workInProgress) break a;
							for (; null === ownerDocument.sibling;) {
								if (null === ownerDocument.return || ownerDocument.return === workInProgress) break a;
								ownerDocument = ownerDocument.return;
							}
							ownerDocument.sibling.return = ownerDocument.return;
							ownerDocument = ownerDocument.sibling;
						}
						workInProgress.stateNode = nextResource;
						a: switch (setInitialProperties(nextResource, type, newProps), type) {
							case "button":
							case "input":
							case "select":
							case "textarea":
								newProps = !!newProps.autoFocus;
								break a;
							case "img":
								newProps = true;
								break a;
							default: newProps = false;
						}
						newProps && markUpdate(workInProgress);
					}
				}
				bubbleProperties(workInProgress);
				preloadInstanceAndSuspendIfNeeded(workInProgress, 0, 0, 0, renderLanes);
				return null;
			case 6:
				if (current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);
				else {
					if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
					current = rootInstanceStackCursor.current;
					if (popHydrationState(workInProgress)) {
						current = workInProgress.stateNode;
						renderLanes = workInProgress.memoizedProps;
						newProps = null;
						type = hydrationParentFiber;
						if (null !== type) switch (type.tag) {
							case 27:
							case 5: newProps = type.memoizedProps;
						}
						current[internalInstanceKey] = workInProgress;
						current = current.nodeValue === renderLanes || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes) ? true : false;
						current || throwOnHydrationMismatch(workInProgress, true);
					} else current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress, workInProgress.stateNode = current;
				}
				bubbleProperties(workInProgress);
				return null;
			case 31:
				renderLanes = workInProgress.memoizedState;
				if (null === current || null !== current.memoizedState) {
					newProps = popHydrationState(workInProgress);
					if (null !== renderLanes) {
						if (null === current) {
							if (!newProps) throw Error(formatProdErrorMessage(318));
							current = workInProgress.memoizedState;
							current = null !== current ? current.dehydrated : null;
							if (!current) throw Error(formatProdErrorMessage(557));
							current[internalInstanceKey] = workInProgress;
						} else resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4;
						bubbleProperties(workInProgress);
						current = false;
					} else renderLanes = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes), current = true;
					if (!current) {
						if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;
						popSuspenseHandler(workInProgress);
						return null;
					}
					if (0 !== (workInProgress.flags & 128)) throw Error(formatProdErrorMessage(558));
				}
				bubbleProperties(workInProgress);
				return null;
			case 13:
				newProps = workInProgress.memoizedState;
				if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
					type = popHydrationState(workInProgress);
					if (null !== newProps && null !== newProps.dehydrated) {
						if (null === current) {
							if (!type) throw Error(formatProdErrorMessage(318));
							type = workInProgress.memoizedState;
							type = null !== type ? type.dehydrated : null;
							if (!type) throw Error(formatProdErrorMessage(317));
							type[internalInstanceKey] = workInProgress;
						} else resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4;
						bubbleProperties(workInProgress);
						type = false;
					} else type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
					if (!type) {
						if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;
						popSuspenseHandler(workInProgress);
						return null;
					}
				}
				popSuspenseHandler(workInProgress);
				if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, workInProgress;
				renderLanes = null !== newProps;
				current = null !== current && null !== current.memoizedState;
				renderLanes && (newProps = workInProgress.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
				renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);
				scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
				bubbleProperties(workInProgress);
				return null;
			case 4: return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;
			case 10: return popProvider(workInProgress.type), bubbleProperties(workInProgress), null;
			case 19:
				pop(suspenseStackCursor);
				newProps = workInProgress.memoizedState;
				if (null === newProps) return bubbleProperties(workInProgress), null;
				type = 0 !== (workInProgress.flags & 128);
				nextResource = newProps.rendering;
				if (null === nextResource) if (type) cutOffTailIfNeeded(newProps, false);
				else {
					if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress.child; null !== current;) {
						nextResource = findFirstSuspended(current);
						if (null !== nextResource) {
							workInProgress.flags |= 128;
							cutOffTailIfNeeded(newProps, false);
							current = nextResource.updateQueue;
							workInProgress.updateQueue = current;
							scheduleRetryEffect(workInProgress, current);
							workInProgress.subtreeFlags = 0;
							current = renderLanes;
							for (renderLanes = workInProgress.child; null !== renderLanes;) resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;
							push(suspenseStackCursor, suspenseStackCursor.current & 1 | 2);
							isHydrating && pushTreeFork(workInProgress, newProps.treeForkCount);
							return workInProgress.child;
						}
						current = current.sibling;
					}
					null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress.lanes = 4194304);
				}
				else {
					if (!type) if (current = findFirstSuspended(nextResource), null !== current) {
						if (workInProgress.flags |= 128, type = true, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating) return bubbleProperties(workInProgress), null;
					} else 2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress.lanes = 4194304);
					newProps.isBackwards ? (nextResource.sibling = workInProgress.child, workInProgress.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress.child = nextResource, newProps.last = nextResource);
				}
				if (null !== newProps.tail) return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes = suspenseStackCursor.current, push(suspenseStackCursor, type ? renderLanes & 1 | 2 : renderLanes & 1), isHydrating && pushTreeFork(workInProgress, newProps.treeForkCount), current;
				bubbleProperties(workInProgress);
				return null;
			case 22:
			case 23: return popSuspenseHandler(workInProgress), popHiddenContext(), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache), null;
			case 24: return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress), null;
			case 25: return null;
			case 30: return null;
		}
		throw Error(formatProdErrorMessage(156, workInProgress.tag));
	}
	function unwindWork(current, workInProgress) {
		popTreeContext(workInProgress);
		switch (workInProgress.tag) {
			case 1: return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
			case 3: return popProvider(CacheContext), popHostContainer(), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
			case 26:
			case 27:
			case 5: return popHostContext(workInProgress), null;
			case 31:
				if (null !== workInProgress.memoizedState) {
					popSuspenseHandler(workInProgress);
					if (null === workInProgress.alternate) throw Error(formatProdErrorMessage(340));
					resetHydrationState();
				}
				current = workInProgress.flags;
				return current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
			case 13:
				popSuspenseHandler(workInProgress);
				current = workInProgress.memoizedState;
				if (null !== current && null !== current.dehydrated) {
					if (null === workInProgress.alternate) throw Error(formatProdErrorMessage(340));
					resetHydrationState();
				}
				current = workInProgress.flags;
				return current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
			case 19: return pop(suspenseStackCursor), null;
			case 4: return popHostContainer(), null;
			case 10: return popProvider(workInProgress.type), null;
			case 22:
			case 23: return popSuspenseHandler(workInProgress), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
			case 24: return popProvider(CacheContext), null;
			case 25: return null;
			default: return null;
		}
	}
	function unwindInterruptedWork(current, interruptedWork) {
		popTreeContext(interruptedWork);
		switch (interruptedWork.tag) {
			case 3:
				popProvider(CacheContext);
				popHostContainer();
				break;
			case 26:
			case 27:
			case 5:
				popHostContext(interruptedWork);
				break;
			case 4:
				popHostContainer();
				break;
			case 31:
				null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
				break;
			case 13:
				popSuspenseHandler(interruptedWork);
				break;
			case 19:
				pop(suspenseStackCursor);
				break;
			case 10:
				popProvider(interruptedWork.type);
				break;
			case 22:
			case 23:
				popSuspenseHandler(interruptedWork);
				popHiddenContext();
				null !== current && pop(resumedCache);
				break;
			case 24: popProvider(CacheContext);
		}
	}
	function commitHookEffectListMount(flags, finishedWork) {
		try {
			var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
			if (null !== lastEffect) {
				var firstEffect = lastEffect.next;
				updateQueue = firstEffect;
				do {
					if ((updateQueue.tag & flags) === flags) {
						lastEffect = void 0;
						var create = updateQueue.create, inst = updateQueue.inst;
						lastEffect = create();
						inst.destroy = lastEffect;
					}
					updateQueue = updateQueue.next;
				} while (updateQueue !== firstEffect);
			}
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
		try {
			var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
			if (null !== lastEffect) {
				var firstEffect = lastEffect.next;
				updateQueue = firstEffect;
				do {
					if ((updateQueue.tag & flags) === flags) {
						var inst = updateQueue.inst, destroy = inst.destroy;
						if (void 0 !== destroy) {
							inst.destroy = void 0;
							lastEffect = finishedWork;
							var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
							try {
								destroy_();
							} catch (error) {
								captureCommitPhaseError(lastEffect, nearestMountedAncestor, error);
							}
						}
					}
					updateQueue = updateQueue.next;
				} while (updateQueue !== firstEffect);
			}
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function commitClassCallbacks(finishedWork) {
		var updateQueue = finishedWork.updateQueue;
		if (null !== updateQueue) {
			var instance = finishedWork.stateNode;
			try {
				commitCallbacks(updateQueue, instance);
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
	}
	function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
		instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
		instance.state = current.memoizedState;
		try {
			instance.componentWillUnmount();
		} catch (error) {
			captureCommitPhaseError(current, nearestMountedAncestor, error);
		}
	}
	function safelyAttachRef(current, nearestMountedAncestor) {
		try {
			var ref = current.ref;
			if (null !== ref) {
				switch (current.tag) {
					case 26:
					case 27:
					case 5:
						var instanceToUse = current.stateNode;
						break;
					case 30:
						instanceToUse = current.stateNode;
						break;
					default: instanceToUse = current.stateNode;
				}
				"function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
			}
		} catch (error) {
			captureCommitPhaseError(current, nearestMountedAncestor, error);
		}
	}
	function safelyDetachRef(current, nearestMountedAncestor) {
		var ref = current.ref, refCleanup = current.refCleanup;
		if (null !== ref) if ("function" === typeof refCleanup) try {
			refCleanup();
		} catch (error) {
			captureCommitPhaseError(current, nearestMountedAncestor, error);
		} finally {
			current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
		}
		else if ("function" === typeof ref) try {
			ref(null);
		} catch (error$140) {
			captureCommitPhaseError(current, nearestMountedAncestor, error$140);
		}
		else ref.current = null;
	}
	function commitHostMount(finishedWork) {
		var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
		try {
			a: switch (type) {
				case "button":
				case "input":
				case "select":
				case "textarea":
					props.autoFocus && instance.focus();
					break a;
				case "img": props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
			}
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function commitHostUpdate(finishedWork, newProps, oldProps) {
		try {
			var domElement = finishedWork.stateNode;
			updateProperties(domElement, finishedWork.type, oldProps, newProps);
			domElement[internalPropsKey] = newProps;
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function isHostParent(fiber) {
		return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
	}
	function getHostSibling(fiber) {
		a: for (;;) {
			for (; null === fiber.sibling;) {
				if (null === fiber.return || isHostParent(fiber.return)) return null;
				fiber = fiber.return;
			}
			fiber.sibling.return = fiber.return;
			for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;) {
				if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
				if (fiber.flags & 2) continue a;
				if (null === fiber.child || 4 === fiber.tag) continue a;
				else fiber.child.return = fiber, fiber = fiber.child;
			}
			if (!(fiber.flags & 2)) return fiber.stateNode;
		}
	}
	function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
		var tag = node.tag;
		if (5 === tag || 6 === tag) node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
		else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node)) for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
	}
	function insertOrAppendPlacementNode(node, before, parent) {
		var tag = node.tag;
		if (5 === tag || 6 === tag) node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
		else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node)) for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
	}
	function commitHostSingletonAcquisition(finishedWork) {
		var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
		try {
			for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length;) singleton.removeAttributeNode(attributes[0]);
			setInitialProperties(singleton, type, props);
			singleton[internalInstanceKey] = finishedWork;
			singleton[internalPropsKey] = props;
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = WeakSet, nextEffect = null;
	function commitBeforeMutationEffects(root, firstChild) {
		root = root.containerInfo;
		eventsEnabled = _enabled;
		root = getActiveElementDeep(root);
		if (hasSelectionCapabilities(root)) {
			if ("selectionStart" in root) var JSCompiler_temp = {
				start: root.selectionStart,
				end: root.selectionEnd
			};
			else a: {
				JSCompiler_temp = (JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView || window;
				var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
				if (selection && 0 !== selection.rangeCount) {
					JSCompiler_temp = selection.anchorNode;
					var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
					selection = selection.focusOffset;
					var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root, parentNode = null;
					b: for (;;) {
						for (var next;;) {
							node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
							node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
							3 === node.nodeType && (length += node.nodeValue.length);
							if (null === (next = node.firstChild)) break;
							parentNode = node;
							node = next;
						}
						for (;;) {
							if (node === root) break b;
							parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
							parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
							if (null !== (next = node.nextSibling)) break;
							node = parentNode;
							parentNode = node.parentNode;
						}
						node = next;
					}
					JSCompiler_temp = -1 === start || -1 === end ? null : {
						start,
						end
					};
				} else JSCompiler_temp = null;
			}
			JSCompiler_temp = JSCompiler_temp || {
				start: 0,
				end: 0
			};
		} else JSCompiler_temp = null;
		selectionInformation = {
			focusedElem: root,
			selectionRange: JSCompiler_temp
		};
		_enabled = false;
		for (nextEffect = firstChild; null !== nextEffect;) if (firstChild = nextEffect, root = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root) root.return = firstChild, nextEffect = root;
		else for (; null !== nextEffect;) {
			firstChild = nextEffect;
			focusNode = firstChild.alternate;
			root = firstChild.flags;
			switch (firstChild.tag) {
				case 0:
					if (0 !== (root & 4) && (root = firstChild.updateQueue, root = null !== root ? root.events : null, null !== root)) for (JSCompiler_temp = 0; JSCompiler_temp < root.length; JSCompiler_temp++) anchorOffset = root[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
					break;
				case 11:
				case 15: break;
				case 1:
					if (0 !== (root & 1024) && null !== focusNode) {
						root = void 0;
						JSCompiler_temp = firstChild;
						anchorOffset = focusNode.memoizedProps;
						focusNode = focusNode.memoizedState;
						selection = JSCompiler_temp.stateNode;
						try {
							var resolvedPrevProps = resolveClassComponentProps(JSCompiler_temp.type, anchorOffset);
							root = selection.getSnapshotBeforeUpdate(resolvedPrevProps, focusNode);
							selection.__reactInternalSnapshotBeforeUpdate = root;
						} catch (error) {
							captureCommitPhaseError(JSCompiler_temp, JSCompiler_temp.return, error);
						}
					}
					break;
				case 3:
					if (0 !== (root & 1024)) {
						if (root = firstChild.stateNode.containerInfo, JSCompiler_temp = root.nodeType, 9 === JSCompiler_temp) clearContainerSparingly(root);
						else if (1 === JSCompiler_temp) switch (root.nodeName) {
							case "HEAD":
							case "HTML":
							case "BODY":
								clearContainerSparingly(root);
								break;
							default: root.textContent = "";
						}
					}
					break;
				case 5:
				case 26:
				case 27:
				case 6:
				case 4:
				case 17: break;
				default: if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
			}
			root = firstChild.sibling;
			if (null !== root) {
				root.return = firstChild.return;
				nextEffect = root;
				break;
			}
			nextEffect = firstChild.return;
		}
	}
	function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
		var flags = finishedWork.flags;
		switch (finishedWork.tag) {
			case 0:
			case 11:
			case 15:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				flags & 4 && commitHookEffectListMount(5, finishedWork);
				break;
			case 1:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) try {
					finishedRoot.componentDidMount();
				} catch (error) {
					captureCommitPhaseError(finishedWork, finishedWork.return, error);
				}
				else {
					var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
					current = current.memoizedState;
					try {
						finishedRoot.componentDidUpdate(prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
					} catch (error$139) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error$139);
					}
				}
				flags & 64 && commitClassCallbacks(finishedWork);
				flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
				break;
			case 3:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
					current = null;
					if (null !== finishedWork.child) switch (finishedWork.child.tag) {
						case 27:
						case 5:
							current = finishedWork.child.stateNode;
							break;
						case 1: current = finishedWork.child.stateNode;
					}
					try {
						commitCallbacks(finishedRoot, current);
					} catch (error) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error);
					}
				}
				break;
			case 27: null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
			case 26:
			case 5:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				null === current && flags & 4 && commitHostMount(finishedWork);
				flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
				break;
			case 12:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				break;
			case 31:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
				break;
			case 13:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
				flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(0, finishedWork), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
				break;
			case 22:
				flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
				if (!flags) {
					current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
					prevProps = offscreenSubtreeIsHidden;
					var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
					offscreenSubtreeIsHidden = flags;
					(offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
					offscreenSubtreeIsHidden = prevProps;
					offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
				}
				break;
			case 30: break;
			default: recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		}
	}
	function detachFiberAfterEffects(fiber) {
		var alternate = fiber.alternate;
		null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
		fiber.child = null;
		fiber.deletions = null;
		fiber.sibling = null;
		5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
		fiber.stateNode = null;
		fiber.return = null;
		fiber.dependencies = null;
		fiber.memoizedProps = null;
		fiber.memoizedState = null;
		fiber.pendingProps = null;
		fiber.stateNode = null;
		fiber.updateQueue = null;
	}
	var hostParent = null, hostParentIsContainer = false;
	function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
		for (parent = parent.child; null !== parent;) commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
	}
	function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
		if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
			injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
		} catch {}
		switch (deletedFiber.tag) {
			case 26:
				offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
				break;
			case 27:
				offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
				var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
				isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				releaseSingletonInstance(deletedFiber.stateNode);
				hostParent = prevHostParent;
				hostParentIsContainer = prevHostParentIsContainer;
				break;
			case 5: offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
			case 6:
				prevHostParent = hostParent;
				prevHostParentIsContainer = hostParentIsContainer;
				hostParent = null;
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				hostParent = prevHostParent;
				hostParentIsContainer = prevHostParentIsContainer;
				if (null !== hostParent) if (hostParentIsContainer) try {
					(9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
				} catch (error) {
					captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
				}
				else try {
					hostParent.removeChild(deletedFiber.stateNode);
				} catch (error) {
					captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
				}
				break;
			case 18:
				null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot, deletedFiber.stateNode), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
				break;
			case 4:
				prevHostParent = hostParent;
				prevHostParentIsContainer = hostParentIsContainer;
				hostParent = deletedFiber.stateNode.containerInfo;
				hostParentIsContainer = true;
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				hostParent = prevHostParent;
				hostParentIsContainer = prevHostParentIsContainer;
				break;
			case 0:
			case 11:
			case 14:
			case 15:
				commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
				offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				break;
			case 1:
				offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				break;
			case 21:
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				break;
			case 22:
				offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				offscreenSubtreeWasHidden = prevHostParent;
				break;
			default: recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
		}
	}
	function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
		if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
			finishedRoot = finishedRoot.dehydrated;
			try {
				retryIfBlockedOn(finishedRoot);
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
	}
	function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
		if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {
			retryIfBlockedOn(finishedRoot);
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function getRetryCache(finishedWork) {
		switch (finishedWork.tag) {
			case 31:
			case 13:
			case 19:
				var retryCache = finishedWork.stateNode;
				null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
				return retryCache;
			case 22: return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
			default: throw Error(formatProdErrorMessage(435, finishedWork.tag));
		}
	}
	function attachSuspenseRetryListeners(finishedWork, wakeables) {
		var retryCache = getRetryCache(finishedWork);
		wakeables.forEach(function(wakeable) {
			if (!retryCache.has(wakeable)) {
				retryCache.add(wakeable);
				var retry = resolveRetryWakeable.bind(0, finishedWork, wakeable);
				wakeable.then(retry, retry);
			}
		});
	}
	function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
		var deletions = parentFiber.deletions;
		if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
			var childToDelete = deletions[i], root = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
			a: for (; null !== parent;) {
				switch (parent.tag) {
					case 27:
						if (isSingletonScope(parent.type)) {
							hostParent = parent.stateNode;
							hostParentIsContainer = false;
							break a;
						}
						break;
					case 5:
						hostParent = parent.stateNode;
						hostParentIsContainer = false;
						break a;
					case 3:
					case 4:
						hostParent = parent.stateNode.containerInfo;
						hostParentIsContainer = true;
						break a;
				}
				parent = parent.return;
			}
			if (null === hostParent) throw Error(formatProdErrorMessage(160));
			commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
			hostParent = null;
			hostParentIsContainer = false;
			root = childToDelete.alternate;
			null !== root && (root.return = null);
			childToDelete.return = null;
		}
		if (parentFiber.subtreeFlags & 13886) for (parentFiber = parentFiber.child; null !== parentFiber;) commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
	}
	var currentHoistableRoot = null;
	function commitMutationEffectsOnFiber(finishedWork, root) {
		var current = finishedWork.alternate, flags = finishedWork.flags;
		switch (finishedWork.tag) {
			case 0:
			case 11:
			case 14:
			case 15:
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
				break;
			case 1:
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
				flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
				break;
			case 26:
				var hoistableRoot = currentHoistableRoot;
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
				if (flags & 4) {
					var currentResource = null !== current ? current.memoizedState : null;
					flags = finishedWork.memoizedState;
					if (null === current) if (null === flags) if (null === finishedWork.stateNode) {
						a: {
							flags = finishedWork.type;
							current = finishedWork.memoizedProps;
							hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
							b: switch (flags) {
								case "title":
									currentResource = hoistableRoot.getElementsByTagName("title")[0];
									if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop")) currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(currentResource, hoistableRoot.querySelector("head > title"));
									setInitialProperties(currentResource, flags, current);
									currentResource[internalInstanceKey] = finishedWork;
									markNodeAsHoistable(currentResource);
									flags = currentResource;
									break a;
								case "link":
									var maybeNodes = getHydratableHoistableCache("link", "href", hoistableRoot).get(flags + (current.href || ""));
									if (maybeNodes) {
										for (var i = 0; i < maybeNodes.length; i++) if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
											maybeNodes.splice(i, 1);
											break b;
										}
									}
									currentResource = hoistableRoot.createElement(flags);
									setInitialProperties(currentResource, flags, current);
									hoistableRoot.head.appendChild(currentResource);
									break;
								case "meta":
									if (maybeNodes = getHydratableHoistableCache("meta", "content", hoistableRoot).get(flags + (current.content || ""))) {
										for (i = 0; i < maybeNodes.length; i++) if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
											maybeNodes.splice(i, 1);
											break b;
										}
									}
									currentResource = hoistableRoot.createElement(flags);
									setInitialProperties(currentResource, flags, current);
									hoistableRoot.head.appendChild(currentResource);
									break;
								default: throw Error(formatProdErrorMessage(468, flags));
							}
							currentResource[internalInstanceKey] = finishedWork;
							markNodeAsHoistable(currentResource);
							flags = currentResource;
						}
						finishedWork.stateNode = flags;
					} else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
					else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
					else currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
				}
				break;
			case 27:
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
				null !== current && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
				break;
			case 5:
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
				if (finishedWork.flags & 32) {
					hoistableRoot = finishedWork.stateNode;
					try {
						setTextContent(hoistableRoot, "");
					} catch (error) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error);
					}
				}
				flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(finishedWork, hoistableRoot, null !== current ? current.memoizedProps : hoistableRoot));
				flags & 1024 && (needsFormReset = true);
				break;
			case 6:
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				if (flags & 4) {
					if (null === finishedWork.stateNode) throw Error(formatProdErrorMessage(162));
					flags = finishedWork.memoizedProps;
					current = finishedWork.stateNode;
					try {
						current.nodeValue = flags;
					} catch (error) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error);
					}
				}
				break;
			case 3:
				tagCaches = null;
				hoistableRoot = currentHoistableRoot;
				currentHoistableRoot = getHoistableRoot(root.containerInfo);
				recursivelyTraverseMutationEffects(root, finishedWork);
				currentHoistableRoot = hoistableRoot;
				commitReconciliationEffects(finishedWork);
				if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {
					retryIfBlockedOn(root.containerInfo);
				} catch (error) {
					captureCommitPhaseError(finishedWork, finishedWork.return, error);
				}
				needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
				break;
			case 4:
				flags = currentHoistableRoot;
				currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				currentHoistableRoot = flags;
				break;
			case 12:
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				break;
			case 31:
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
				break;
			case 13:
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
				flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
				break;
			case 22:
				hoistableRoot = null !== finishedWork.memoizedState;
				var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
				offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
				offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
				recursivelyTraverseMutationEffects(root, finishedWork);
				offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
				offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
				commitReconciliationEffects(finishedWork);
				if (flags & 8192) a: for (root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root = finishedWork;;) {
					if (5 === root.tag || 26 === root.tag) {
						if (null === current) {
							wasHidden = current = root;
							try {
								if (currentResource = wasHidden.stateNode, hoistableRoot) maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
								else {
									i = wasHidden.stateNode;
									var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
									i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
								}
							} catch (error) {
								captureCommitPhaseError(wasHidden, wasHidden.return, error);
							}
						}
					} else if (6 === root.tag) {
						if (null === current) {
							wasHidden = root;
							try {
								wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
							} catch (error) {
								captureCommitPhaseError(wasHidden, wasHidden.return, error);
							}
						}
					} else if (18 === root.tag) {
						if (null === current) {
							wasHidden = root;
							try {
								var instance = wasHidden.stateNode;
								hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
							} catch (error) {
								captureCommitPhaseError(wasHidden, wasHidden.return, error);
							}
						}
					} else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
						root.child.return = root;
						root = root.child;
						continue;
					}
					if (root === finishedWork) break a;
					for (; null === root.sibling;) {
						if (null === root.return || root.return === finishedWork) break a;
						current === root && (current = null);
						root = root.return;
					}
					current === root && (current = null);
					root.sibling.return = root.return;
					root = root.sibling;
				}
				flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
				break;
			case 19:
				recursivelyTraverseMutationEffects(root, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
				break;
			case 30: break;
			case 21: break;
			default: recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
		}
	}
	function commitReconciliationEffects(finishedWork) {
		var flags = finishedWork.flags;
		if (flags & 2) {
			try {
				for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber;) {
					if (isHostParent(parentFiber)) {
						hostParentFiber = parentFiber;
						break;
					}
					parentFiber = parentFiber.return;
				}
				if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
				switch (hostParentFiber.tag) {
					case 27:
						var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
						insertOrAppendPlacementNode(finishedWork, before, parent);
						break;
					case 5:
						var parent$141 = hostParentFiber.stateNode;
						hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
						var before$142 = getHostSibling(finishedWork);
						insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
						break;
					case 3:
					case 4:
						var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
						insertOrAppendPlacementNodeIntoContainer(finishedWork, before$144, parent$143);
						break;
					default: throw Error(formatProdErrorMessage(161));
				}
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
			finishedWork.flags &= -3;
		}
		flags & 4096 && (finishedWork.flags &= -4097);
	}
	function recursivelyResetForms(parentFiber) {
		if (parentFiber.subtreeFlags & 1024) for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var fiber = parentFiber;
			recursivelyResetForms(fiber);
			5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
			parentFiber = parentFiber.sibling;
		}
	}
	function recursivelyTraverseLayoutEffects(root, parentFiber) {
		if (parentFiber.subtreeFlags & 8772) for (parentFiber = parentFiber.child; null !== parentFiber;) commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
	}
	function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
		for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var finishedWork = parentFiber;
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 14:
				case 15:
					commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
					recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				case 1:
					safelyDetachRef(finishedWork, finishedWork.return);
					var instance = finishedWork.stateNode;
					"function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
					recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				case 27: releaseSingletonInstance(finishedWork.stateNode);
				case 26:
				case 5:
					safelyDetachRef(finishedWork, finishedWork.return);
					recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				case 22:
					null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				case 30:
					recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				default: recursivelyTraverseDisappearLayoutEffects(finishedWork);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
		includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
		for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 15:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					commitHookEffectListMount(4, finishedWork);
					break;
				case 1:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					current = finishedWork;
					finishedRoot = current.stateNode;
					if ("function" === typeof finishedRoot.componentDidMount) try {
						finishedRoot.componentDidMount();
					} catch (error) {
						captureCommitPhaseError(current, current.return, error);
					}
					current = finishedWork;
					finishedRoot = current.updateQueue;
					if (null !== finishedRoot) {
						var instance = current.stateNode;
						try {
							var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
							if (null !== hiddenCallbacks) for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++) callCallback(hiddenCallbacks[finishedRoot], instance);
						} catch (error) {
							captureCommitPhaseError(current, current.return, error);
						}
					}
					includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
					safelyAttachRef(finishedWork, finishedWork.return);
					break;
				case 27: commitHostSingletonAcquisition(finishedWork);
				case 26:
				case 5:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
					safelyAttachRef(finishedWork, finishedWork.return);
					break;
				case 12:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					break;
				case 31:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
					break;
				case 13:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
					break;
				case 22:
					null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					safelyAttachRef(finishedWork, finishedWork.return);
					break;
				case 30: break;
				default: recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	function commitOffscreenPassiveMountEffects(current, finishedWork) {
		var previousCache = null;
		null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
		current = null;
		null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
		current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
	}
	function commitCachePassiveMountEffect(current, finishedWork) {
		current = null;
		null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
		finishedWork = finishedWork.memoizedState.cache;
		finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
	}
	function recursivelyTraversePassiveMountEffects(root, parentFiber) {
		if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveMountOnFiber(root, parentFiber), parentFiber = parentFiber.sibling;
	}
	function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
		var flags = finishedWork.flags;
		switch (finishedWork.tag) {
			case 0:
			case 11:
			case 15:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
				flags & 2048 && commitHookEffectListMount(9, finishedWork);
				break;
			case 1:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
				break;
			case 3:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
				flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
				break;
			case 12:
				if (flags & 2048) {
					recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
					finishedRoot = finishedWork.stateNode;
					try {
						var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
						"function" === typeof onPostCommit && onPostCommit(id, null === finishedWork.alternate ? "mount" : "update", finishedRoot.passiveEffectDuration, -0);
					} catch (error) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error);
					}
				} else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
				break;
			case 31:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
				break;
			case 13:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
				break;
			case 23: break;
			case 22:
				_finishedWork$memoize2 = finishedWork.stateNode;
				id = finishedWork.alternate;
				null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork) : recursivelyTraverseAtomicPassiveEffects(0, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(0, finishedWork, 0, 0, 0 !== (finishedWork.subtreeFlags & 10256) || false));
				flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
				break;
			case 24:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
				flags & 2048 && commitCachePassiveMountEffect(0, finishedWork);
				break;
			default: recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
		}
	}
	function recursivelyTraverseReconnectPassiveEffects(__unused_E330, parentFiber, __unused_A503, __unused_E58D, includeWorkInProgressEffects) {
		includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
		for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var finishedWork = parentFiber, flags = finishedWork.flags;
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 15:
					recursivelyTraverseReconnectPassiveEffects(0, finishedWork, 0, 0, includeWorkInProgressEffects);
					commitHookEffectListMount(8, finishedWork);
					break;
				case 23: break;
				case 22:
					var instance = finishedWork.stateNode;
					null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(0, finishedWork, 0, 0, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(0, finishedWork) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(0, finishedWork, 0, 0, includeWorkInProgressEffects));
					includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
					break;
				case 24:
					recursivelyTraverseReconnectPassiveEffects(0, finishedWork, 0, 0, includeWorkInProgressEffects);
					includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(0, finishedWork);
					break;
				default: recursivelyTraverseReconnectPassiveEffects(0, finishedWork, 0, 0, includeWorkInProgressEffects);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	function recursivelyTraverseAtomicPassiveEffects(__unused_E330_0, parentFiber) {
		if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var finishedWork = parentFiber, flags = finishedWork.flags;
			switch (finishedWork.tag) {
				case 22:
					recursivelyTraverseAtomicPassiveEffects(0, finishedWork);
					flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
					break;
				case 24:
					recursivelyTraverseAtomicPassiveEffects(0, finishedWork);
					flags & 2048 && commitCachePassiveMountEffect(0, finishedWork);
					break;
				default: recursivelyTraverseAtomicPassiveEffects(0, finishedWork);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	var suspenseyCommitFlag = 8192;
	function recursivelyAccumulateSuspenseyCommit(parentFiber, __unused_DD38_1, suspendedState) {
		if (parentFiber.subtreeFlags & suspenseyCommitFlag) for (parentFiber = parentFiber.child; null !== parentFiber;) accumulateSuspenseyCommitOnFiber(parentFiber, 0, suspendedState), parentFiber = parentFiber.sibling;
	}
	function accumulateSuspenseyCommitOnFiber(fiber, __unused_DD38_2, suspendedState) {
		switch (fiber.tag) {
			case 26:
				recursivelyAccumulateSuspenseyCommit(fiber, 0, suspendedState);
				fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(suspendedState, currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
				break;
			case 5:
				recursivelyAccumulateSuspenseyCommit(fiber, 0, suspendedState);
				break;
			case 3:
			case 4:
				var previousHoistableRoot = currentHoistableRoot;
				currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
				recursivelyAccumulateSuspenseyCommit(fiber, 0, suspendedState);
				currentHoistableRoot = previousHoistableRoot;
				break;
			case 22:
				null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber, 0, suspendedState), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber, 0, suspendedState));
				break;
			default: recursivelyAccumulateSuspenseyCommit(fiber, 0, suspendedState);
		}
	}
	function detachAlternateSiblings(parentFiber) {
		var previousFiber = parentFiber.alternate;
		if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
			previousFiber.child = null;
			do
				previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
			while (null !== parentFiber);
		}
	}
	function recursivelyTraversePassiveUnmountEffects(parentFiber) {
		var deletions = parentFiber.deletions;
		if (0 !== (parentFiber.flags & 16)) {
			if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
				var childToDelete = deletions[i];
				nextEffect = childToDelete;
				commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
			}
			detachAlternateSiblings(parentFiber);
		}
		if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
	}
	function commitPassiveUnmountOnFiber(finishedWork) {
		switch (finishedWork.tag) {
			case 0:
			case 11:
			case 15:
				recursivelyTraversePassiveUnmountEffects(finishedWork);
				finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
				break;
			case 3:
				recursivelyTraversePassiveUnmountEffects(finishedWork);
				break;
			case 12:
				recursivelyTraversePassiveUnmountEffects(finishedWork);
				break;
			case 22:
				var instance = finishedWork.stateNode;
				null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
				break;
			default: recursivelyTraversePassiveUnmountEffects(finishedWork);
		}
	}
	function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
		var deletions = parentFiber.deletions;
		if (0 !== (parentFiber.flags & 16)) {
			if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
				var childToDelete = deletions[i];
				nextEffect = childToDelete;
				commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
			}
			detachAlternateSiblings(parentFiber);
		}
		for (parentFiber = parentFiber.child; null !== parentFiber;) {
			deletions = parentFiber;
			switch (deletions.tag) {
				case 0:
				case 11:
				case 15:
					commitHookEffectListUnmount(8, deletions, deletions.return);
					recursivelyTraverseDisconnectPassiveEffects(deletions);
					break;
				case 22:
					i = deletions.stateNode;
					i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
					break;
				default: recursivelyTraverseDisconnectPassiveEffects(deletions);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
		for (; null !== nextEffect;) {
			var fiber = nextEffect;
			switch (fiber.tag) {
				case 0:
				case 11:
				case 15:
					commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
					break;
				case 23:
				case 22:
					if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
						var cache = fiber.memoizedState.cachePool.pool;
						null != cache && cache.refCount++;
					}
					break;
				case 24: releaseCache(fiber.memoizedState.cache);
			}
			cache = fiber.child;
			if (null !== cache) cache.return = fiber, nextEffect = cache;
			else a: for (fiber = deletedSubtreeRoot; null !== nextEffect;) {
				cache = nextEffect;
				var sibling = cache.sibling, returnFiber = cache.return;
				detachFiberAfterEffects(cache);
				if (cache === fiber) {
					nextEffect = null;
					break a;
				}
				if (null !== sibling) {
					sibling.return = returnFiber;
					nextEffect = sibling;
					break a;
				}
				nextEffect = returnFiber;
			}
		}
	}
	var DefaultAsyncDispatcher = {
		getCacheForType: function(resourceType) {
			var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
			void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
			return cacheForType;
		},
		cacheSignal: function() {
			return readContext(CacheContext).controller.signal;
		}
	}, PossiblyWeakMap = WeakMap, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
	function requestUpdateLane() {
		return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
	}
	function requestDeferredLane() {
		if (0 === workInProgressDeferredLane) if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
			var lane = nextTransitionDeferredLane;
			nextTransitionDeferredLane <<= 1;
			0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
			workInProgressDeferredLane = lane;
		} else workInProgressDeferredLane = 536870912;
		lane = suspenseHandlerStackCursor.current;
		null !== lane && (lane.flags |= 32);
		return workInProgressDeferredLane;
	}
	function scheduleUpdateOnFiber(root, __unused_BDE4, lane) {
		if (root === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
		markRootUpdated$1(root, lane);
		if (0 === (executionContext & 2) || root !== workInProgressRoot) root === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false)), ensureRootIsScheduled(root);
	}
	function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
		if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
		do {
			if (0 === exitStatus) {
				workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
				break;
			} else {
				forceSync = root$jscomp$0.current.alternate;
				if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
					exitStatus = renderRootSync(root$jscomp$0, lanes, false);
					renderWasConcurrent = false;
					continue;
				}
				if (2 === exitStatus) {
					renderWasConcurrent = lanes;
					if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent) var JSCompiler_inline_result = 0;
					else JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
					if (0 !== JSCompiler_inline_result) {
						lanes = JSCompiler_inline_result;
						a: {
							var root = root$jscomp$0;
							exitStatus = workInProgressRootConcurrentErrors;
							var wasRootDehydrated = root.current.memoizedState.isDehydrated;
							wasRootDehydrated && (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
							JSCompiler_inline_result = renderRootSync(root, JSCompiler_inline_result, false);
							if (2 !== JSCompiler_inline_result) {
								if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
									root.errorRecoveryDisabledLanes |= renderWasConcurrent;
									workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
									exitStatus = 4;
									break a;
								}
								renderWasConcurrent = workInProgressRootRecoverableErrors;
								workInProgressRootRecoverableErrors = exitStatus;
								null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, renderWasConcurrent));
							}
							exitStatus = JSCompiler_inline_result;
						}
						renderWasConcurrent = false;
						if (2 !== exitStatus) continue;
					}
				}
				if (1 === exitStatus) {
					prepareFreshStack(root$jscomp$0, 0);
					markRootSuspended(root$jscomp$0, lanes, 0, true);
					break;
				}
				a: {
					shouldTimeSlice = root$jscomp$0;
					renderWasConcurrent = exitStatus;
					switch (renderWasConcurrent) {
						case 0:
						case 1: throw Error(formatProdErrorMessage(345));
						case 4: if ((lanes & 4194048) !== lanes) break;
						case 6:
							markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
							break a;
						case 2:
							workInProgressRootRecoverableErrors = null;
							break;
						case 3:
						case 5: break;
						default: throw Error(formatProdErrorMessage(329));
					}
					if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
						markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
						if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
						pendingEffectsLanes = lanes;
						shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(0, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, 0, 0, 0, 0), exitStatus);
						break a;
					}
					commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings);
				}
			}
			break;
		} while (1);
		ensureRootIsScheduled(root$jscomp$0);
	}
	function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, __unused_6C43, suspendedCommitReason) {
		root.timeoutHandle = -1;
		suspendedCommitReason = finishedWork.subtreeFlags;
		if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
			suspendedCommitReason = {
				stylesheets: null,
				count: 0,
				imgCount: 0,
				imgBytes: 0,
				suspenseyImages: [],
				waitingForImages: true,
				waitingForViewTransition: false,
				unsuspend: noop$1
			};
			accumulateSuspenseyCommitOnFiber(finishedWork, 0, suspendedCommitReason);
			var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
			timeoutOffset = waitForCommitToBeReady(suspendedCommitReason, timeoutOffset);
			if (null !== timeoutOffset) {
				pendingEffectsLanes = lanes;
				root.cancelPendingCommit = timeoutOffset(commitRoot.bind(0, root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, 0, 0, 0, 0, 0));
				markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
				return;
			}
		}
		commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
	}
	function isRenderConsistentWithExternalStores(finishedWork) {
		for (var node = finishedWork;;) {
			var tag = node.tag;
			if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for (var i = 0; i < tag.length; i++) {
				var check = tag[i], getSnapshot = check.getSnapshot;
				check = check.value;
				try {
					if (!objectIs(getSnapshot(), check)) return false;
				} catch {
					return false;
				}
			}
			tag = node.child;
			if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;
			else {
				if (node === finishedWork) break;
				for (; null === node.sibling;) {
					if (null === node.return || node.return === finishedWork) return true;
					node = node.return;
				}
				node.sibling.return = node.return;
				node = node.sibling;
			}
		}
		return true;
	}
	function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
		suspendedLanes &= ~workInProgressRootPingedLanes;
		suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
		root.suspendedLanes |= suspendedLanes;
		root.pingedLanes &= ~suspendedLanes;
		didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
		didAttemptEntireTree = root.expirationTimes;
		for (var lanes = suspendedLanes; 0 < lanes;) {
			var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
			didAttemptEntireTree[index$6] = -1;
			lanes &= ~lane;
		}
		0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
	}
	function flushSyncWork$1() {
		return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
	}
	function resetWorkInProgressStack() {
		if (null !== workInProgress) {
			if (0 === workInProgressSuspendedReason) var interruptedWork = workInProgress.return;
			else interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
			for (; null !== interruptedWork;) unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
			workInProgress = null;
		}
	}
	function prepareFreshStack(root, lanes) {
		var timeoutHandle = root.timeoutHandle;
		-1 !== timeoutHandle && (root.timeoutHandle = -1, cancelTimeout(timeoutHandle));
		timeoutHandle = root.cancelPendingCommit;
		null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
		pendingEffectsLanes = 0;
		resetWorkInProgressStack();
		workInProgressRoot = root;
		workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
		workInProgressRootRenderLanes = lanes;
		workInProgressSuspendedReason = 0;
		workInProgressThrownValue = null;
		workInProgressRootDidSkipSuspendedSiblings = false;
		workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
		workInProgressRootDidAttachPingListener = false;
		workInProgressSuspendedRetryLanes = (workInProgressDeferredLane = (workInProgressRootPingedLanes = (workInProgressRootInterleavedUpdatedLanes = (workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0, 0), 0), 0), 0);
		workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
		workInProgressRootDidIncludeRecursiveRenderUpdate = false;
		0 !== (lanes & 8) && (lanes |= lanes & 32);
		var allEntangledLanes = root.entangledLanes;
		if (0 !== allEntangledLanes) for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;) {
			var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
			lanes |= root[index$4];
			allEntangledLanes &= ~lane;
		}
		entangledRenderLanes = lanes;
		finishQueueingConcurrentUpdates();
		return timeoutHandle;
	}
	function handleThrow(root, thrownValue) {
		currentlyRenderingFiber = null;
		ReactSharedInternals.H = ContextOnlyDispatcher;
		thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
		workInProgressThrownValue = thrownValue;
		null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current)));
	}
	function shouldRemainOnPreviousScreen() {
		var handler = suspenseHandlerStackCursor.current;
		return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
	}
	function pushDispatcher() {
		var prevDispatcher = ReactSharedInternals.H;
		ReactSharedInternals.H = ContextOnlyDispatcher;
		return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
	}
	function pushAsyncDispatcher() {
		var prevAsyncDispatcher = ReactSharedInternals.A;
		ReactSharedInternals.A = DefaultAsyncDispatcher;
		return prevAsyncDispatcher;
	}
	function renderDidSuspendDelayIfPossible() {
		workInProgressRootExitStatus = 4;
		workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
		0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
	}
	function renderRootSync(root, lanes, shouldYieldForPrerendering) {
		var prevExecutionContext = executionContext;
		executionContext |= 2;
		var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
		if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) workInProgressTransitions = null, prepareFreshStack(root, lanes);
		lanes = false;
		var exitStatus = workInProgressRootExitStatus;
		a: do
			try {
				if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
					var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
					switch (workInProgressSuspendedReason) {
						case 8:
							resetWorkInProgressStack();
							exitStatus = 6;
							break a;
						case 3:
						case 2:
						case 9:
						case 6:
							null === suspenseHandlerStackCursor.current && (lanes = true);
							var reason = workInProgressSuspendedReason;
							workInProgressSuspendedReason = 0;
							workInProgressThrownValue = null;
							throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
							if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
								exitStatus = 0;
								break a;
							}
							break;
						default: reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
					}
				}
				workLoopSync();
				exitStatus = workInProgressRootExitStatus;
				break;
			} catch (thrownValue$165) {
				handleThrow(root, thrownValue$165);
			}
		while (1);
		lanes && root.shellSuspendCounter++;
		lastContextDependency = currentlyRenderingFiber$1 = null;
		executionContext = prevExecutionContext;
		ReactSharedInternals.H = prevDispatcher;
		ReactSharedInternals.A = prevAsyncDispatcher;
		null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
		return exitStatus;
	}
	function workLoopSync() {
		for (; null !== workInProgress;) performUnitOfWork(workInProgress);
	}
	function renderRootConcurrent(root, lanes) {
		var prevExecutionContext = executionContext;
		executionContext |= 2;
		var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
		workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
		a: do
			try {
				if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
					lanes = workInProgress;
					var thrownValue = workInProgressThrownValue;
					b: switch (workInProgressSuspendedReason) {
						case 1:
							workInProgressSuspendedReason = 0;
							workInProgressThrownValue = null;
							throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
							break;
						case 2:
						case 9:
							if (isThenableResolved(thrownValue)) {
								workInProgressSuspendedReason = 0;
								workInProgressThrownValue = null;
								replaySuspendedUnitOfWork(lanes);
								break;
							}
							lanes = function() {
								2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root || (workInProgressSuspendedReason = 7);
								ensureRootIsScheduled(root);
							};
							thrownValue.then(lanes, lanes);
							break a;
						case 3:
							workInProgressSuspendedReason = 7;
							break a;
						case 4:
							workInProgressSuspendedReason = 5;
							break a;
						case 7:
							isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
							break;
						case 5:
							var resource = null;
							switch (workInProgress.tag) {
								case 26: resource = workInProgress.memoizedState;
								case 5:
								case 27:
									var hostFiber = workInProgress;
									if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
										workInProgressSuspendedReason = 0;
										workInProgressThrownValue = null;
										var sibling = hostFiber.sibling;
										if (null !== sibling) workInProgress = sibling;
										else {
											var returnFiber = hostFiber.return;
											null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
										}
										break b;
									}
							}
							workInProgressSuspendedReason = 0;
							workInProgressThrownValue = null;
							throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
							break;
						case 6:
							workInProgressSuspendedReason = 0;
							workInProgressThrownValue = null;
							throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
							break;
						case 8:
							resetWorkInProgressStack();
							workInProgressRootExitStatus = 6;
							break a;
						default: throw Error(formatProdErrorMessage(462));
					}
				}
				workLoopConcurrentByScheduler();
				break;
			} catch (thrownValue$167) {
				handleThrow(root, thrownValue$167);
			}
		while (1);
		lastContextDependency = currentlyRenderingFiber$1 = null;
		ReactSharedInternals.H = prevDispatcher;
		ReactSharedInternals.A = prevAsyncDispatcher;
		executionContext = prevExecutionContext;
		if (null !== workInProgress) return 0;
		workInProgressRoot = null;
		workInProgressRootRenderLanes = 0;
		finishQueueingConcurrentUpdates();
		return workInProgressRootExitStatus;
	}
	function workLoopConcurrentByScheduler() {
		for (; null !== workInProgress && !shouldYield();) performUnitOfWork(workInProgress);
	}
	function performUnitOfWork(unitOfWork) {
		var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
		unitOfWork.memoizedProps = unitOfWork.pendingProps;
		null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
	}
	function replaySuspendedUnitOfWork(unitOfWork) {
		var next = unitOfWork;
		var current = next.alternate;
		switch (next.tag) {
			case 15:
			case 0:
				next = replayFunctionComponent(current, next, next.pendingProps, next.type, void 0, workInProgressRootRenderLanes);
				break;
			case 11:
				next = replayFunctionComponent(current, next, next.pendingProps, next.type.render, next.ref, workInProgressRootRenderLanes);
				break;
			case 5: resetHooksOnUnwind(next);
			default: unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
		}
		unitOfWork.memoizedProps = unitOfWork.pendingProps;
		null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
	}
	function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
		lastContextDependency = currentlyRenderingFiber$1 = null;
		resetHooksOnUnwind(unitOfWork);
		thenableState$1 = null;
		thenableIndexCounter$1 = 0;
		var returnFiber = unitOfWork.return;
		try {
			if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
				workInProgressRootExitStatus = 1;
				logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
				workInProgress = null;
				return;
			}
		} catch (error) {
			if (null !== returnFiber) throw workInProgress = returnFiber, error;
			workInProgressRootExitStatus = 1;
			logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
			workInProgress = null;
			return;
		}
		if (unitOfWork.flags & 32768) {
			if (isHydrating || 1 === suspendedReason) root = true;
			else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = false;
			else if (workInProgressRootDidSkipSuspendedSiblings = root = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
			unwindUnitOfWork(unitOfWork, root);
		} else completeUnitOfWork(unitOfWork);
	}
	function completeUnitOfWork(unitOfWork) {
		var completedWork = unitOfWork;
		do {
			if (0 !== (completedWork.flags & 32768)) {
				unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
				return;
			}
			unitOfWork = completedWork.return;
			var next = completeWork(completedWork.alternate, completedWork, entangledRenderLanes);
			if (null !== next) {
				workInProgress = next;
				return;
			}
			completedWork = completedWork.sibling;
			if (null !== completedWork) {
				workInProgress = completedWork;
				return;
			}
			workInProgress = completedWork = unitOfWork;
		} while (null !== completedWork);
		0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
	}
	function unwindUnitOfWork(unitOfWork, skipSiblings) {
		do {
			var next = unwindWork(unitOfWork.alternate, unitOfWork);
			if (null !== next) {
				next.flags &= 32767;
				workInProgress = next;
				return;
			}
			next = unitOfWork.return;
			null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
			if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
				workInProgress = unitOfWork;
				return;
			}
			workInProgress = unitOfWork = next;
		} while (null !== unitOfWork);
		workInProgressRootExitStatus = 6;
		workInProgress = null;
	}
	function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
		root.cancelPendingCommit = null;
		do
			flushPendingEffects();
		while (0 !== pendingEffectsStatus);
		if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		if (null !== finishedWork) {
			if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
			didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
			didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
			markRootFinished(root, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
			root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
			pendingFinishedWork = finishedWork;
			pendingEffectsRoot = root;
			pendingEffectsLanes = lanes;
			pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
			pendingRecoverableErrors = recoverableErrors;
			0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback$1(0, function() {
				flushPassiveEffects();
				return null;
			})) : (root.callbackNode = null, root.callbackPriority = 0);
			recoverableErrors = 0 !== (finishedWork.flags & 13878);
			if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
				recoverableErrors = ReactSharedInternals.T;
				ReactSharedInternals.T = null;
				transitions = ReactDOMSharedInternals.a;
				ReactDOMSharedInternals.a = 2;
				spawnedLane = executionContext;
				executionContext |= 4;
				try {
					commitBeforeMutationEffects(root, finishedWork);
				} finally {
					executionContext = spawnedLane, ReactDOMSharedInternals.a = transitions, ReactSharedInternals.T = recoverableErrors;
				}
			}
			pendingEffectsStatus = 1;
			flushMutationEffects();
			flushLayoutEffects();
			flushSpawnedWork();
		}
	}
	function flushMutationEffects() {
		if (1 === pendingEffectsStatus) {
			pendingEffectsStatus = 0;
			var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
			if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
				rootMutationHasEffect = ReactSharedInternals.T;
				ReactSharedInternals.T = null;
				var previousPriority = ReactDOMSharedInternals.a;
				ReactDOMSharedInternals.a = 2;
				var prevExecutionContext = executionContext;
				executionContext |= 4;
				try {
					commitMutationEffectsOnFiber(finishedWork, root);
					var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
					if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)) {
						if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
							var start = priorSelectionRange.start, end = priorSelectionRange.end;
							void 0 === end && (end = start);
							if ("selectionStart" in priorFocusedElem) priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(end, priorFocusedElem.value.length);
							else {
								var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
								if (win.getSelection) {
									var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
									!selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
									var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0), endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);
									if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
										var range = doc.createRange();
										range.setStart(startMarker.node, startMarker.offset);
										selection.removeAllRanges();
										start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
									}
								}
							}
						}
						doc = [];
						for (selection = priorFocusedElem; selection = selection.parentNode;) 1 === selection.nodeType && doc.push({
							element: selection,
							left: selection.scrollLeft,
							top: selection.scrollTop
						});
						"function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
						for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
							var info = doc[priorFocusedElem];
							info.element.scrollLeft = info.left;
							info.element.scrollTop = info.top;
						}
					}
					_enabled = !!eventsEnabled;
					selectionInformation = eventsEnabled = null;
				} finally {
					executionContext = prevExecutionContext, ReactDOMSharedInternals.a = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
				}
			}
			root.current = finishedWork;
			pendingEffectsStatus = 2;
		}
	}
	function flushLayoutEffects() {
		if (2 === pendingEffectsStatus) {
			pendingEffectsStatus = 0;
			var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
			if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
				rootHasLayoutEffect = ReactSharedInternals.T;
				ReactSharedInternals.T = null;
				var previousPriority = ReactDOMSharedInternals.a;
				ReactDOMSharedInternals.a = 2;
				var prevExecutionContext = executionContext;
				executionContext |= 4;
				try {
					commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
				} finally {
					executionContext = prevExecutionContext, ReactDOMSharedInternals.a = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
				}
			}
			pendingEffectsStatus = 3;
		}
	}
	function flushSpawnedWork() {
		if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
			pendingEffectsStatus = 0;
			requestPaint();
			var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
			0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root, root.pendingLanes));
			var remainingLanes = root.pendingLanes;
			0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
			lanesToEventPriority(lanes);
			finishedWork = finishedWork.stateNode;
			if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
				injectedHook.onCommitFiberRoot(rendererID, finishedWork, void 0, 128 === (finishedWork.current.flags & 128));
			} catch {}
			if (null !== recoverableErrors) {
				finishedWork = ReactSharedInternals.T;
				remainingLanes = ReactDOMSharedInternals.a;
				ReactDOMSharedInternals.a = 2;
				ReactSharedInternals.T = null;
				try {
					for (var onRecoverableError = root.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
						var recoverableError = recoverableErrors[i];
						onRecoverableError(recoverableError.value, { componentStack: recoverableError.stack });
					}
				} finally {
					ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.a = remainingLanes;
				}
			}
			0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
			ensureRootIsScheduled(root);
			remainingLanes = root.pendingLanes;
			0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root) : nestedUpdateCount = 0;
			flushSyncWorkAcrossRoots_impl(0);
		}
	}
	function releaseRootPooledCache(root, remainingLanes) {
		0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
	}
	function flushPendingEffects() {
		flushMutationEffects();
		flushLayoutEffects();
		flushSpawnedWork();
		return flushPassiveEffects();
	}
	function flushPassiveEffects() {
		if (5 !== pendingEffectsStatus) return false;
		var root = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
		pendingEffectsRemainingLanes = 0;
		var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.a;
		try {
			ReactDOMSharedInternals.a = 32 > renderPriority ? 32 : renderPriority;
			ReactSharedInternals.T = null;
			var root$jscomp$0 = pendingEffectsRoot;
			pendingEffectsStatus = 0;
			pendingFinishedWork = pendingEffectsRoot = null;
			pendingEffectsLanes = 0;
			if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
			var prevExecutionContext = executionContext;
			executionContext |= 4;
			commitPassiveUnmountOnFiber(root$jscomp$0.current);
			commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current);
			executionContext = prevExecutionContext;
			flushSyncWorkAcrossRoots_impl(0);
			if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
				injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
			} catch {}
			return true;
		} finally {
			ReactDOMSharedInternals.a = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root, remainingLanes);
		}
	}
	function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
		sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
		rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
		null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
	}
	function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
		if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
		else for (; null !== nearestMountedAncestor;) {
			if (3 === nearestMountedAncestor.tag) {
				captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
				break;
			} else if (1 === nearestMountedAncestor.tag) {
				var instance = nearestMountedAncestor.stateNode;
				if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
					sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
					error = createClassErrorUpdate(2);
					instance = enqueueUpdate(nearestMountedAncestor, error, 2);
					null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
					break;
				}
			}
			nearestMountedAncestor = nearestMountedAncestor.return;
		}
	}
	function attachPingListener(root, wakeable, lanes) {
		var pingCache = root.pingCache;
		if (null === pingCache) {
			pingCache = root.pingCache = new PossiblyWeakMap();
			var threadIDs = new Set();
			pingCache.set(wakeable, threadIDs);
		} else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));
		threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root = pingSuspendedRoot.bind(0, root, wakeable, lanes), wakeable.then(root, root));
	}
	function pingSuspendedRoot(root, wakeable, pingedLanes) {
		var pingCache = root.pingCache;
		null !== pingCache && pingCache.delete(wakeable);
		root.pingedLanes |= root.suspendedLanes & pingedLanes;
		root.warmLanes &= ~pingedLanes;
		workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
		ensureRootIsScheduled(root);
	}
	function retryTimedOutBoundary(boundaryFiber, retryLane) {
		0 === retryLane && (retryLane = claimNextRetryLane());
		boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
		null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
	}
	function retryDehydratedSuspenseBoundary(boundaryFiber) {
		var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
		null !== suspenseState && (retryLane = suspenseState.retryLane);
		retryTimedOutBoundary(boundaryFiber, retryLane);
	}
	function resolveRetryWakeable(boundaryFiber, wakeable) {
		var retryLane = 0;
		switch (boundaryFiber.tag) {
			case 31:
			case 13:
				var retryCache = boundaryFiber.stateNode;
				var suspenseState = boundaryFiber.memoizedState;
				null !== suspenseState && (retryLane = suspenseState.retryLane);
				break;
			case 19:
				retryCache = boundaryFiber.stateNode;
				break;
			case 22:
				retryCache = boundaryFiber.stateNode._retryCache;
				break;
			default: throw Error(formatProdErrorMessage(314));
		}
		null !== retryCache && retryCache.delete(wakeable);
		retryTimedOutBoundary(boundaryFiber, retryLane);
	}
	function scheduleCallback$1(__unused_2146, callback) {
		return scheduleCallback$3(3, callback);
	}
	var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
	function ensureRootIsScheduled(root) {
		root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
		mightHavePendingSyncWork = true;
		didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
	}
	function flushSyncWorkAcrossRoots_impl(syncTransitionLanes) {
		if (!isFlushingWork && mightHavePendingSyncWork) {
			isFlushingWork = true;
			do {
				var didPerformSomeWork = false;
				for (var root$170 = firstScheduledRoot; null !== root$170;) {
					if (0 !== syncTransitionLanes) {
						var pendingLanes = root$170.pendingLanes;
						if (0 === pendingLanes) var JSCompiler_inline_result = 0;
						else {
							var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
							JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
							JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
							JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
						}
						0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
					} else JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(root$170, root$170 === workInProgressRoot ? JSCompiler_inline_result : 0, null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
					root$170 = root$170.next;
				}
			} while (didPerformSomeWork);
			isFlushingWork = false;
		}
	}
	function processRootScheduleInImmediateTask() {
		processRootScheduleInMicrotask();
	}
	function processRootScheduleInMicrotask() {
		mightHavePendingSyncWork = didScheduleMicrotask = false;
		var syncTransitionLanes = 0;
		0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
		for (var currentTime = now(), prev = null, root = firstScheduledRoot; null !== root;) {
			var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
			if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
			else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = true;
			root = next;
		}
		0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
		0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
	}
	function scheduleTaskForRootDuringMicrotask(root, currentTime) {
		for (var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;) {
			var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
			if (-1 === expirationTime) {
				if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
			} else expirationTime <= currentTime && (root.expiredLanes |= lane);
			lanes &= ~lane;
		}
		currentTime = workInProgressRoot;
		suspendedLanes = workInProgressRootRenderLanes;
		suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0, null !== root.cancelPendingCommit || -1 !== root.timeoutHandle);
		pingedLanes = root.callbackNode;
		if (0 === suspendedLanes || root === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root.cancelPendingCommit) return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
		if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
			currentTime = suspendedLanes & -suspendedLanes;
			if (currentTime === root.callbackPriority) return currentTime;
			null !== pingedLanes && cancelCallback$1(pingedLanes);
			switch (lanesToEventPriority(suspendedLanes)) {
				case 2:
				case 8:
					suspendedLanes = 2;
					break;
				case 32:
					suspendedLanes = 3;
					break;
				case 268435456:
					suspendedLanes = 5;
					break;
				default: suspendedLanes = 3;
			}
			pingedLanes = performWorkOnRootViaSchedulerTask.bind(0, root);
			suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
			root.callbackPriority = currentTime;
			root.callbackNode = suspendedLanes;
			return currentTime;
		}
		null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
		root.callbackPriority = 2;
		root.callbackNode = null;
		return 2;
	}
	function performWorkOnRootViaSchedulerTask(root, didTimeout) {
		if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) return root.callbackNode = null, root.callbackPriority = 0, null;
		var originalCallbackNode = root.callbackNode;
		if (flushPendingEffects() && root.callbackNode !== originalCallbackNode) return null;
		var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
		workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, null !== root.cancelPendingCommit || -1 !== root.timeoutHandle);
		if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
		performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
		scheduleTaskForRootDuringMicrotask(root, now());
		return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(0, root) : null;
	}
	function performSyncWorkOnRoot(root, lanes) {
		performWorkOnRoot(root, lanes, true);
	}
	function scheduleImmediateRootScheduleTask() {
		scheduleMicrotask(function() {
			0 !== (executionContext & 6) ? scheduleCallback$3(1, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
		});
	}
	function requestTransitionLane() {
		if (0 === currentEventTransitionLane) {
			var actionScopeLane = currentEntangledLane;
			0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
			currentEventTransitionLane = actionScopeLane;
		}
		return currentEventTransitionLane;
	}
	function coerceFormActionProp(actionProp) {
		return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
	}
	function createFormDataWithSubmitter(form, submitter) {
		var temp = submitter.ownerDocument.createElement("input");
		temp.name = submitter.name;
		temp.value = submitter.value;
		form.id && temp.setAttribute("form", form.id);
		submitter.parentNode.insertBefore(temp, submitter);
		form = new FormData(form);
		temp.parentNode.removeChild(temp);
		return form;
	}
	function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
		if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
			var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action), submitter = nativeEvent.submitter;
			submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
			var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
			dispatchQueue.push({
				event,
				listeners: [{
					instance: null,
					listener: function() {
						if (nativeEvent.defaultPrevented) {
							if (0 !== currentEventTransitionLane) {
								var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
								startHostTransition(maybeTargetInst, {
									pending: true,
									data: formData,
									method: nativeEventTarget.method,
									action
								}, null);
							}
						} else "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(maybeTargetInst, {
							pending: true,
							data: formData,
							method: nativeEventTarget.method,
							action
						}, action, formData));
					},
					currentTarget: nativeEventTarget
				}]
			});
		}
	}
	for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
		var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
		registerSimpleEvent(domEventName$jscomp$inline_1579, "on" + capitalizedEvent$jscomp$inline_1580);
	}
	registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
	registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
	registerSimpleEvent(ANIMATION_START, "onAnimationStart");
	registerSimpleEvent("dblclick", "onDoubleClick");
	registerSimpleEvent("focusin", "onFocus");
	registerSimpleEvent("focusout", "onBlur");
	registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
	registerSimpleEvent(TRANSITION_START, "onTransitionStart");
	registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
	registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
	registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
	registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
	registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
	registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
	registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
	registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
	registerTwoPhaseEvent("onBeforeInput", [
		"compositionend",
		"keypress",
		"textInput",
		"paste"
	]);
	registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
	registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
	registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
	var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes));
	function processDispatchQueue(dispatchQueue, eventSystemFlags) {
		eventSystemFlags = 0 !== (eventSystemFlags & 4);
		for (var i = 0; i < dispatchQueue.length; i++) {
			var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
			_dispatchQueue$i = _dispatchQueue$i.listeners;
			a: {
				var previousInstance = void 0;
				if (eventSystemFlags) for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
					var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
					_dispatchListeners$i = _dispatchListeners$i.listener;
					if (instance !== previousInstance && event.isPropagationStopped()) break a;
					previousInstance = _dispatchListeners$i;
					event.currentTarget = currentTarget;
					try {
						previousInstance(event);
					} catch (error) {
						reportGlobalError(error);
					}
					event.currentTarget = null;
					previousInstance = instance;
				}
				else for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
					_dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
					instance = _dispatchListeners$i.instance;
					currentTarget = _dispatchListeners$i.currentTarget;
					_dispatchListeners$i = _dispatchListeners$i.listener;
					if (instance !== previousInstance && event.isPropagationStopped()) break a;
					previousInstance = _dispatchListeners$i;
					event.currentTarget = currentTarget;
					try {
						previousInstance(event);
					} catch (error) {
						reportGlobalError(error);
					}
					event.currentTarget = null;
					previousInstance = instance;
				}
			}
		}
	}
	function listenToNonDelegatedEvent(domEventName, targetElement) {
		var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
		void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = new Set());
		var listenerSetKey = domEventName + "__bubble";
		JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
	}
	function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
		var eventSystemFlags = 0;
		isCapturePhaseListener && (eventSystemFlags |= 4);
		addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
	}
	var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
	function listenToAllSupportedEvents(rootContainerElement) {
		if (!rootContainerElement[listeningMarker]) {
			rootContainerElement[listeningMarker] = true;
			allNativeEvents.forEach(function(domEventName) {
				"selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
			});
			var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
			null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
		}
	}
	function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
		switch (getEventPriority(domEventName)) {
			case 2:
				var listenerWrapper = dispatchDiscreteEvent;
				break;
			case 8:
				listenerWrapper = dispatchContinuousEvent;
				break;
			default: listenerWrapper = dispatchEvent;
		}
		eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
		listenerWrapper = void 0;
		!passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
		isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
			capture: true,
			passive: listenerWrapper
		}) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, { passive: listenerWrapper }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
	}
	function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
		var ancestorInst = targetInst$jscomp$0;
		if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for (;;) {
			if (null === targetInst$jscomp$0) return;
			var nodeTag = targetInst$jscomp$0.tag;
			if (3 === nodeTag || 4 === nodeTag) {
				var container = targetInst$jscomp$0.stateNode.containerInfo;
				if (container === targetContainer) break;
				if (4 === nodeTag) for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag;) {
					var grandTag = nodeTag.tag;
					if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer) return;
					nodeTag = nodeTag.return;
				}
				for (; null !== container;) {
					nodeTag = getClosestInstanceFromNode(container);
					if (null === nodeTag) return;
					grandTag = nodeTag.tag;
					if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
						targetInst$jscomp$0 = ancestorInst = nodeTag;
						continue a;
					}
					container = container.parentNode;
				}
			}
			targetInst$jscomp$0 = targetInst$jscomp$0.return;
		}
		batchedUpdates$1(function() {
			var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
			a: {
				var reactName = topLevelEventsToReactNames.get(domEventName);
				if (void 0 !== reactName) {
					var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
					switch (domEventName) {
						case "keypress": if (0 === getEventCharCode(nativeEvent)) break a;
						case "keydown":
						case "keyup":
							SyntheticEventCtor = SyntheticKeyboardEvent;
							break;
						case "focusin":
							reactEventType = "focus";
							SyntheticEventCtor = SyntheticFocusEvent;
							break;
						case "focusout":
							reactEventType = "blur";
							SyntheticEventCtor = SyntheticFocusEvent;
							break;
						case "beforeblur":
						case "afterblur":
							SyntheticEventCtor = SyntheticFocusEvent;
							break;
						case "click": if (2 === nativeEvent.button) break a;
						case "auxclick":
						case "dblclick":
						case "mousedown":
						case "mousemove":
						case "mouseup":
						case "mouseout":
						case "mouseover":
						case "contextmenu":
							SyntheticEventCtor = SyntheticMouseEvent;
							break;
						case "drag":
						case "dragend":
						case "dragenter":
						case "dragexit":
						case "dragleave":
						case "dragover":
						case "dragstart":
						case "drop":
							SyntheticEventCtor = SyntheticDragEvent;
							break;
						case "touchcancel":
						case "touchend":
						case "touchmove":
						case "touchstart":
							SyntheticEventCtor = SyntheticTouchEvent;
							break;
						case ANIMATION_END:
						case ANIMATION_ITERATION:
						case ANIMATION_START:
							SyntheticEventCtor = SyntheticAnimationEvent;
							break;
						case TRANSITION_END:
							SyntheticEventCtor = SyntheticTransitionEvent;
							break;
						case "scroll":
						case "scrollend":
							SyntheticEventCtor = SyntheticUIEvent;
							break;
						case "wheel":
							SyntheticEventCtor = SyntheticWheelEvent;
							break;
						case "copy":
						case "cut":
						case "paste":
							SyntheticEventCtor = SyntheticClipboardEvent;
							break;
						case "gotpointercapture":
						case "lostpointercapture":
						case "pointercancel":
						case "pointerdown":
						case "pointermove":
						case "pointerout":
						case "pointerover":
						case "pointerup":
							SyntheticEventCtor = SyntheticPointerEvent;
							break;
						case "toggle":
						case "beforetoggle": SyntheticEventCtor = SyntheticToggleEvent;
					}
					var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
					inCapturePhase = [];
					for (var instance = targetInst, lastHostComponent; null !== instance;) {
						var _instance = instance;
						lastHostComponent = _instance.stateNode;
						_instance = _instance.tag;
						5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(createDispatchListener(instance, _instance, lastHostComponent)));
						if (accumulateTargetOnly) break;
						instance = instance.return;
					}
					0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
						event: reactName,
						listeners: inCapturePhase
					}));
				}
			}
			if (0 === (eventSystemFlags & 7)) {
				a: {
					reactName = "mouseover" === domEventName || "pointerover" === domEventName;
					SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
					if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;
					if (SyntheticEventCtor || reactName) {
						reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
						if (SyntheticEventCtor) {
							if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)) reactEventType = null;
						} else SyntheticEventCtor = null, reactEventType = targetInst;
						if (SyntheticEventCtor !== reactEventType) {
							inCapturePhase = SyntheticMouseEvent;
							_instance = "onMouseLeave";
							reactEventName = "onMouseEnter";
							instance = "mouse";
							if ("pointerout" === domEventName || "pointerover" === domEventName) inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
							accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
							lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
							reactName = new inCapturePhase(_instance, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
							reactName.target = accumulateTargetOnly;
							reactName.relatedTarget = lastHostComponent;
							_instance = null;
							getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
							accumulateTargetOnly = _instance;
							if (SyntheticEventCtor && reactEventType) b: {
								inCapturePhase = getParent;
								reactEventName = SyntheticEventCtor;
								instance = reactEventType;
								lastHostComponent = 0;
								for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance)) lastHostComponent++;
								_instance = 0;
								for (var tempB = instance; tempB; tempB = inCapturePhase(tempB)) _instance++;
								for (; 0 < lastHostComponent - _instance;) reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
								for (; 0 < _instance - lastHostComponent;) instance = inCapturePhase(instance), _instance--;
								for (; lastHostComponent--;) {
									if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
										inCapturePhase = reactEventName;
										break b;
									}
									reactEventName = inCapturePhase(reactEventName);
									instance = inCapturePhase(instance);
								}
								inCapturePhase = null;
							}
							else inCapturePhase = null;
							null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, false);
							null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, true);
						}
					}
				}
				a: {
					reactName = targetInst ? getNodeFromInstance(targetInst) : window;
					SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
					if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type) var getTargetInstFunc = getTargetInstForChangeEvent;
					else if (isTextInputElement(reactName)) if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;
					else {
						getTargetInstFunc = getTargetInstForInputEventPolyfill;
						var handleEventFunc = handleEventsForInputEventPolyfill;
					}
					else SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
					if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
						createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
						break a;
					}
					handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
					"focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
				}
				handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
				switch (domEventName) {
					case "focusin":
						if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable) activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
						break;
					case "focusout":
						lastSelection = (activeElementInst = activeElement = null, null);
						break;
					case "mousedown":
						mouseDown = true;
						break;
					case "contextmenu":
					case "mouseup":
					case "dragend":
						mouseDown = false;
						constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
						break;
					case "selectionchange": if (skipSelectionChangeEvent) break;
					case "keydown":
					case "keyup": constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
				}
				var fallbackData;
				if (canUseCompositionEvent) b: {
					switch (domEventName) {
						case "compositionstart":
							var eventType = "onCompositionStart";
							break b;
						case "compositionend":
							eventType = "onCompositionEnd";
							break b;
						case "compositionupdate":
							eventType = "onCompositionUpdate";
							break b;
					}
					eventType = void 0;
				}
				else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
				eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
					event: eventType,
					listeners: handleEventFunc
				}), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
				if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent)) eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
					event: handleEventFunc,
					listeners: eventType
				}), handleEventFunc.data = fallbackData);
				extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
			}
			processDispatchQueue(dispatchQueue, eventSystemFlags);
		});
	}
	function createDispatchListener(instance, listener, currentTarget) {
		return {
			instance,
			listener,
			currentTarget
		};
	}
	function accumulateTwoPhaseListeners(targetFiber, reactName) {
		for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber;) {
			var _instance2 = targetFiber, stateNode = _instance2.stateNode;
			_instance2 = _instance2.tag;
			5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(createDispatchListener(targetFiber, _instance2, stateNode)), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(createDispatchListener(targetFiber, _instance2, stateNode)));
			if (3 === targetFiber.tag) return listeners;
			targetFiber = targetFiber.return;
		}
		return [];
	}
	function getParent(inst) {
		if (null === inst) return null;
		do
			inst = inst.return;
		while (inst && 5 !== inst.tag && 27 !== inst.tag);
		return inst ? inst : null;
	}
	function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
		for (var registrationName = event._reactName, listeners = []; null !== target && target !== common;) {
			var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
			_instance3 = _instance3.tag;
			if (null !== alternate && alternate === common) break;
			5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));
			target = target.return;
		}
		0 !== listeners.length && dispatchQueue.push({
			event,
			listeners
		});
	}
	var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
	function normalizeMarkupForTextOrAttribute(markup) {
		return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
	}
	function checkForUnmatchedText(serverText, clientText) {
		clientText = normalizeMarkupForTextOrAttribute(clientText);
		return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
	}
	function setProp(domElement, tag, key, value, props, prevValue) {
		switch (key) {
			case "children":
				"string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
				break;
			case "className":
				setValueForKnownAttribute(domElement, "class", value);
				break;
			case "tabIndex":
				setValueForKnownAttribute(domElement, "tabindex", value);
				break;
			case "dir":
			case "role":
			case "viewBox":
			case "width":
			case "height":
				setValueForKnownAttribute(domElement, key, value);
				break;
			case "style":
				setValueForStyles(domElement, value, prevValue);
				break;
			case "data": if ("object" !== tag) {
				setValueForKnownAttribute(domElement, "data", value);
				break;
			}
			case "src":
			case "href":
				if ("" === value && ("a" !== tag || "href" !== key)) {
					domElement.removeAttribute(key);
					break;
				}
				if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
					domElement.removeAttribute(key);
					break;
				}
				value = sanitizeURL("" + value);
				domElement.setAttribute(key, value);
				break;
			case "action":
			case "formAction":
				if ("function" === typeof value) {
					domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
					break;
				} else "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, 0, "name", props.name), setProp(domElement, 0, "formEncType", props.formEncType), setProp(domElement, 0, "formMethod", props.formMethod), setProp(domElement, 0, "formTarget", props.formTarget)) : (setProp(domElement, 0, "encType", props.encType), setProp(domElement, 0, "method", props.method), setProp(domElement, 0, "target", props.target)));
				if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
					domElement.removeAttribute(key);
					break;
				}
				value = sanitizeURL("" + value);
				domElement.setAttribute(key, value);
				break;
			case "onClick":
				null != value && (domElement.onclick = noop$1);
				break;
			case "onScroll":
				null != value && listenToNonDelegatedEvent("scroll", domElement);
				break;
			case "onScrollEnd":
				null != value && listenToNonDelegatedEvent("scrollend", domElement);
				break;
			case "dangerouslySetInnerHTML":
				if (null != value) {
					if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
					key = value.__html;
					if (null != key) {
						if (null != props.children) throw Error(formatProdErrorMessage(60));
						domElement.innerHTML = key;
					}
				}
				break;
			case "multiple":
				domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
				break;
			case "muted":
				domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
				break;
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "defaultValue":
			case "defaultChecked":
			case "innerHTML":
			case "ref": break;
			case "autoFocus": break;
			case "xlinkHref":
				if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
					domElement.removeAttribute("xlink:href");
					break;
				}
				key = sanitizeURL("" + value);
				domElement.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", key);
				break;
			case "contentEditable":
			case "spellCheck":
			case "draggable":
			case "value":
			case "autoReverse":
			case "externalResourcesRequired":
			case "focusable":
			case "preserveAlpha":
				null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
				break;
			case "inert":
			case "allowFullScreen":
			case "async":
			case "autoPlay":
			case "controls":
			case "default":
			case "defer":
			case "disabled":
			case "disablePictureInPicture":
			case "disableRemotePlayback":
			case "formNoValidate":
			case "hidden":
			case "loop":
			case "noModule":
			case "noValidate":
			case "open":
			case "playsInline":
			case "readOnly":
			case "required":
			case "reversed":
			case "scoped":
			case "seamless":
			case "itemScope":
				value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
				break;
			case "capture":
			case "download":
				true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
				break;
			case "cols":
			case "rows":
			case "size":
			case "span":
				null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
				break;
			case "rowSpan":
			case "start":
				null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
				break;
			case "popover":
				listenToNonDelegatedEvent("beforetoggle", domElement);
				listenToNonDelegatedEvent("toggle", domElement);
				setValueForAttribute(domElement, "popover", value);
				break;
			case "xlinkActuate":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:actuate", value);
				break;
			case "xlinkArcrole":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:arcrole", value);
				break;
			case "xlinkRole":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:role", value);
				break;
			case "xlinkShow":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:show", value);
				break;
			case "xlinkTitle":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:title", value);
				break;
			case "xlinkType":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:type", value);
				break;
			case "xmlBase":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:base", value);
				break;
			case "xmlLang":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:lang", value);
				break;
			case "xmlSpace":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:space", value);
				break;
			case "is":
				setValueForAttribute(domElement, "is", value);
				break;
			case "innerText":
			case "textContent": break;
			default: if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1]) key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
		}
	}
	function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
		switch (key) {
			case "style":
				setValueForStyles(domElement, value, prevValue);
				break;
			case "dangerouslySetInnerHTML":
				if (null != value) {
					if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
					key = value.__html;
					if (null != key) {
						if (null != props.children) throw Error(formatProdErrorMessage(60));
						domElement.innerHTML = key;
					}
				}
				break;
			case "children":
				"string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
				break;
			case "onScroll":
				null != value && listenToNonDelegatedEvent("scroll", domElement);
				break;
			case "onScrollEnd":
				null != value && listenToNonDelegatedEvent("scrollend", domElement);
				break;
			case "onClick":
				null != value && (domElement.onclick = noop$1);
				break;
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "innerHTML":
			case "ref": break;
			case "innerText":
			case "textContent": break;
			default: if (!registrationNameDependencies.hasOwnProperty(key)) a: {
				if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
					"function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
					domElement.addEventListener(tag, value, props);
					break a;
				}
				key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
			}
		}
	}
	function setInitialProperties(domElement, tag, props) {
		switch (tag) {
			case "div":
			case "span":
			case "svg":
			case "path":
			case "a":
			case "g":
			case "p":
			case "li": break;
			case "img":
				listenToNonDelegatedEvent("error", domElement);
				listenToNonDelegatedEvent("load", domElement);
				var hasSrc = false, hasSrcSet = false, propKey;
				for (propKey in props) if (props.hasOwnProperty(propKey)) {
					var propValue = props[propKey];
					if (null != propValue) switch (propKey) {
						case "src":
							hasSrc = true;
							break;
						case "srcSet":
							hasSrcSet = true;
							break;
						case "children":
						case "dangerouslySetInnerHTML": throw Error(formatProdErrorMessage(137, tag));
						default: setProp(domElement, tag, propKey, propValue, props, null);
					}
				}
				hasSrcSet && setProp(domElement, 0, "srcSet", props.srcSet);
				hasSrc && setProp(domElement, tag, "src", props.src);
				return;
			case "input":
				listenToNonDelegatedEvent("invalid", domElement);
				var defaultValue = (propKey = (propValue = hasSrcSet = null, null), null), checked = null, defaultChecked = null;
				for (hasSrc in props) if (props.hasOwnProperty(hasSrc)) {
					var propValue$184 = props[hasSrc];
					if (null != propValue$184) switch (hasSrc) {
						case "name":
							hasSrcSet = propValue$184;
							break;
						case "type":
							propValue = propValue$184;
							break;
						case "checked":
							checked = propValue$184;
							break;
						case "defaultChecked":
							defaultChecked = propValue$184;
							break;
						case "value":
							propKey = propValue$184;
							break;
						case "defaultValue":
							defaultValue = propValue$184;
							break;
						case "children":
						case "dangerouslySetInnerHTML":
							if (null != propValue$184) throw Error(formatProdErrorMessage(137, tag));
							break;
						default: setProp(domElement, tag, hasSrc, propValue$184, props, null);
					}
				}
				initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, false);
				return;
			case "select":
				listenToNonDelegatedEvent("invalid", domElement);
				hasSrc = (propValue = propKey = null, null);
				for (hasSrcSet in props) if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue)) switch (hasSrcSet) {
					case "value":
						propKey = defaultValue;
						break;
					case "defaultValue":
						propValue = defaultValue;
						break;
					case "multiple": hasSrc = defaultValue;
					default: setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
				}
				tag = propKey;
				props = propValue;
				domElement.multiple = !!hasSrc;
				null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
				return;
			case "textarea":
				listenToNonDelegatedEvent("invalid", domElement);
				propKey = (hasSrcSet = hasSrc = null, null);
				for (propValue in props) if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue)) switch (propValue) {
					case "value":
						hasSrc = defaultValue;
						break;
					case "defaultValue":
						hasSrcSet = defaultValue;
						break;
					case "children":
						propKey = defaultValue;
						break;
					case "dangerouslySetInnerHTML":
						if (null != defaultValue) throw Error(formatProdErrorMessage(91));
						break;
					default: setProp(domElement, tag, propValue, defaultValue, props, null);
				}
				initTextarea(domElement, hasSrc, hasSrcSet, propKey);
				return;
			case "option":
				for (checked in props) if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc)) switch (checked) {
					case "selected":
						domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
						break;
					default: setProp(domElement, tag, checked, hasSrc, props, null);
				}
				return;
			case "dialog":
				listenToNonDelegatedEvent("beforetoggle", domElement);
				listenToNonDelegatedEvent("toggle", domElement);
				listenToNonDelegatedEvent("cancel", domElement);
				listenToNonDelegatedEvent("close", domElement);
				break;
			case "iframe":
			case "object":
				listenToNonDelegatedEvent("load", domElement);
				break;
			case "video":
			case "audio":
				for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++) listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
				break;
			case "image":
				listenToNonDelegatedEvent("error", domElement);
				listenToNonDelegatedEvent("load", domElement);
				break;
			case "details":
				listenToNonDelegatedEvent("toggle", domElement);
				break;
			case "embed":
			case "source":
			case "link": listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
			case "area":
			case "base":
			case "br":
			case "col":
			case "hr":
			case "keygen":
			case "meta":
			case "param":
			case "track":
			case "wbr":
			case "menuitem":
				for (defaultChecked in props) if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc)) switch (defaultChecked) {
					case "children":
					case "dangerouslySetInnerHTML": throw Error(formatProdErrorMessage(137, tag));
					default: setProp(domElement, tag, defaultChecked, hasSrc, props, null);
				}
				return;
			default: if (isCustomElement(tag)) {
				for (propValue$184 in props) props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(domElement, tag, propValue$184, hasSrc, props, void 0));
				return;
			}
		}
		for (defaultValue in props) props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
	}
	function updateProperties(domElement, tag, lastProps, nextProps) {
		switch (tag) {
			case "div":
			case "span":
			case "svg":
			case "path":
			case "a":
			case "g":
			case "p":
			case "li": break;
			case "input":
				var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
				for (propKey in lastProps) {
					var lastProp = lastProps[propKey];
					if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch (propKey) {
						case "checked": break;
						case "value": break;
						case "defaultValue": lastDefaultValue = lastProp;
						default: nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
					}
				}
				for (var propKey$201 in nextProps) {
					var propKey = nextProps[propKey$201];
					lastProp = lastProps[propKey$201];
					if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp)) switch (propKey$201) {
						case "type":
							type = propKey;
							break;
						case "name":
							name = propKey;
							break;
						case "checked":
							checked = propKey;
							break;
						case "defaultChecked":
							defaultChecked = propKey;
							break;
						case "value":
							value = propKey;
							break;
						case "defaultValue":
							defaultValue = propKey;
							break;
						case "children":
						case "dangerouslySetInnerHTML":
							if (null != propKey) throw Error(formatProdErrorMessage(137, tag));
							break;
						default: propKey !== lastProp && setProp(domElement, tag, propKey$201, propKey, nextProps, lastProp);
					}
				}
				updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
				return;
			case "select":
				propKey = (value = (defaultValue = propKey$201 = null, null), null);
				for (type in lastProps) if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue) switch (type) {
					case "value": break;
					case "multiple": propKey = lastDefaultValue;
					default: nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
				}
				for (name in nextProps) if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue)) switch (name) {
					case "value":
						propKey$201 = type;
						break;
					case "defaultValue":
						defaultValue = type;
						break;
					case "multiple": value = type;
					default: type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
				}
				tag = defaultValue;
				lastProps = value;
				nextProps = propKey;
				null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
				return;
			case "textarea":
				propKey = propKey$201 = null;
				for (defaultValue in lastProps) if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue)) switch (defaultValue) {
					case "value": break;
					case "children": break;
					default: setProp(domElement, tag, defaultValue, null, nextProps, name);
				}
				for (value in nextProps) if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type)) switch (value) {
					case "value":
						propKey$201 = name;
						break;
					case "defaultValue":
						propKey = name;
						break;
					case "children": break;
					case "dangerouslySetInnerHTML":
						if (null != name) throw Error(formatProdErrorMessage(91));
						break;
					default: name !== type && setProp(domElement, tag, value, name, nextProps, type);
				}
				updateTextarea(domElement, propKey$201, propKey);
				return;
			case "option":
				for (var propKey$217 in lastProps) if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217)) switch (propKey$217) {
					case "selected":
						domElement.selected = false;
						break;
					default: setProp(domElement, tag, propKey$217, null, nextProps, propKey$201);
				}
				for (lastDefaultValue in nextProps) if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey)) switch (lastDefaultValue) {
					case "selected":
						domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
						break;
					default: setProp(domElement, tag, lastDefaultValue, propKey$201, nextProps, propKey);
				}
				return;
			case "img":
			case "link":
			case "area":
			case "base":
			case "br":
			case "col":
			case "embed":
			case "hr":
			case "keygen":
			case "meta":
			case "param":
			case "source":
			case "track":
			case "wbr":
			case "menuitem":
				for (var propKey$222 in lastProps) propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
				for (checked in nextProps) if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey)) switch (checked) {
					case "children":
					case "dangerouslySetInnerHTML":
						if (null != propKey$201) throw Error(formatProdErrorMessage(137, tag));
						break;
					default: setProp(domElement, tag, checked, propKey$201, nextProps, propKey);
				}
				return;
			default: if (isCustomElement(tag)) {
				for (var propKey$227 in lastProps) propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(domElement, tag, propKey$227, void 0, nextProps, propKey$201);
				for (defaultChecked in nextProps) propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(domElement, tag, defaultChecked, propKey$201, nextProps, propKey);
				return;
			}
		}
		for (var propKey$232 in lastProps) propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
		for (lastProp in nextProps) propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
	}
	function isLikelyStaticResource(initiatorType) {
		switch (initiatorType) {
			case "css":
			case "script":
			case "font":
			case "img":
			case "image":
			case "input":
			case "link": return true;
			default: return false;
		}
	}
	function estimateBandwidth() {
		if ("function" === typeof performance.getEntriesByType) {
			for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
				var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
				if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
					initiatorType = 0;
					duration = entry.responseEnd;
					for (i += 1; i < resourceEntries.length; i++) {
						var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
						if (overlapStartTime > duration) break;
						var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
						overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
					}
					--i;
					bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
					count++;
					if (10 < count) break;
				}
			}
			if (0 < count) return bits / count / 1e6;
		}
		return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
	}
	var eventsEnabled = null, selectionInformation = null;
	function getOwnerDocumentFromRootContainer(rootContainerElement) {
		return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
	}
	function getOwnHostContext(namespaceURI) {
		switch (namespaceURI) {
			case "http://www.w3.org/2000/svg": return 1;
			case "http://www.w3.org/1998/Math/MathML": return 2;
			default: return 0;
		}
	}
	function getChildHostContextProd(parentNamespace, type) {
		if (0 === parentNamespace) switch (type) {
			case "svg": return 1;
			case "math": return 2;
			default: return 0;
		}
		return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
	}
	function shouldSetTextContent(type, props) {
		return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
	}
	var currentPopstateTransitionEvent = null;
	function shouldAttemptEagerTransition() {
		var event = window.event;
		if (event && "popstate" === event.type) {
			if (event === currentPopstateTransitionEvent) return false;
			currentPopstateTransitionEvent = event;
			return true;
		}
		currentPopstateTransitionEvent = null;
		return false;
	}
	var scheduleTimeout = setTimeout, cancelTimeout = clearTimeout, scheduleMicrotask = queueMicrotask;
	function isSingletonScope(type) {
		return "head" === type;
	}
	function clearHydrationBoundary(parentInstance, hydrationInstance) {
		var node = hydrationInstance, depth = 0;
		do {
			var nextNode = node.nextSibling;
			parentInstance.removeChild(node);
			if (nextNode && 8 === nextNode.nodeType) if (node = nextNode.data, "/$" === node || "/&" === node) {
				if (0 === depth) {
					parentInstance.removeChild(nextNode);
					retryIfBlockedOn(hydrationInstance);
					return;
				}
				depth--;
			} else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node) depth++;
			else if ("html" === node) releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
			else if ("head" === node) {
				node = parentInstance.ownerDocument.head;
				releaseSingletonInstance(node);
				for (var node$jscomp$0 = node.firstChild; node$jscomp$0;) {
					var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
					node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
					node$jscomp$0 = nextNode$jscomp$0;
				}
			} else "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
			node = nextNode;
		} while (node);
		retryIfBlockedOn(hydrationInstance);
	}
	function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
		var node = suspenseInstance;
		suspenseInstance = 0;
		do {
			var nextNode = node.nextSibling;
			1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
			if (nextNode && 8 === nextNode.nodeType) if (node = nextNode.data, "/$" === node) if (0 === suspenseInstance) break;
			else suspenseInstance--;
			else "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
			node = nextNode;
		} while (node);
	}
	function clearContainerSparingly(container) {
		var nextNode = container.firstChild;
		nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
		for (; nextNode;) {
			var node = nextNode;
			nextNode = nextNode.nextSibling;
			switch (node.nodeName) {
				case "HTML":
				case "HEAD":
				case "BODY":
					clearContainerSparingly(node);
					detachDeletedInstance(node);
					continue;
				case "SCRIPT":
				case "STYLE": continue;
				case "LINK": if ("stylesheet" === node.rel.toLowerCase()) continue;
			}
			container.removeChild(node);
		}
	}
	function canHydrateInstance(instance, type, props, inRootOrSingleton) {
		for (; 1 === instance.nodeType;) {
			var anyProps = props;
			if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
				if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type)) break;
			} else if (!inRootOrSingleton) if ("input" === type && "hidden" === instance.type) {
				var name = null == anyProps.name ? null : "" + anyProps.name;
				if ("hidden" === anyProps.type && instance.getAttribute("name") === name) return instance;
			} else return instance;
			else if (!instance[internalHoistableMarker]) switch (type) {
				case "meta":
					if (!instance.hasAttribute("itemprop")) break;
					return instance;
				case "link":
					name = instance.getAttribute("rel");
					if ("stylesheet" === name && instance.hasAttribute("data-precedence")) break;
					else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title)) break;
					return instance;
				case "style":
					if (instance.hasAttribute("data-precedence")) break;
					return instance;
				case "script":
					name = instance.getAttribute("src");
					if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop")) break;
					return instance;
				default: return instance;
			}
			instance = getNextHydratable(instance.nextSibling);
			if (null === instance) break;
		}
		return null;
	}
	function canHydrateTextInstance(instance, text, inRootOrSingleton) {
		if ("" === text) return null;
		for (; 3 !== instance.nodeType;) {
			if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
			instance = getNextHydratable(instance.nextSibling);
			if (null === instance) return null;
		}
		return instance;
	}
	function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
		for (; 8 !== instance.nodeType;) {
			if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
			instance = getNextHydratable(instance.nextSibling);
			if (null === instance) return null;
		}
		return instance;
	}
	function isSuspenseInstancePending(instance) {
		return "$?" === instance.data || "$~" === instance.data;
	}
	function isSuspenseInstanceFallback(instance) {
		return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
	}
	function registerSuspenseInstanceRetry(instance, callback) {
		var ownerDocument = instance.ownerDocument;
		if ("$~" === instance.data) instance._reactRetry = callback;
		else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState) callback();
		else {
			var listener = function() {
				callback();
				ownerDocument.removeEventListener("DOMContentLoaded", listener);
			};
			ownerDocument.addEventListener("DOMContentLoaded", listener);
			instance._reactRetry = listener;
		}
	}
	function getNextHydratable(node) {
		for (; null != node; node = node.nextSibling) {
			var nodeType = node.nodeType;
			if (1 === nodeType || 3 === nodeType) break;
			if (8 === nodeType) {
				nodeType = node.data;
				if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType) break;
				if ("/$" === nodeType || "/&" === nodeType) return null;
			}
		}
		return node;
	}
	var previousHydratableOnEnteringScopedSingleton = null;
	function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
		hydrationInstance = hydrationInstance.nextSibling;
		for (var depth = 0; hydrationInstance;) {
			if (8 === hydrationInstance.nodeType) {
				var data = hydrationInstance.data;
				if ("/$" === data || "/&" === data) {
					if (0 === depth) return getNextHydratable(hydrationInstance.nextSibling);
					depth--;
				} else "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
			}
			hydrationInstance = hydrationInstance.nextSibling;
		}
		return null;
	}
	function getParentHydrationBoundary(targetInstance) {
		targetInstance = targetInstance.previousSibling;
		for (var depth = 0; targetInstance;) {
			if (8 === targetInstance.nodeType) {
				var data = targetInstance.data;
				if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
					if (0 === depth) return targetInstance;
					depth--;
				} else "/$" !== data && "/&" !== data || depth++;
			}
			targetInstance = targetInstance.previousSibling;
		}
		return null;
	}
	function resolveSingletonInstance(type, props, rootContainerInstance) {
		props = getOwnerDocumentFromRootContainer(rootContainerInstance);
		switch (type) {
			case "html":
				type = props.documentElement;
				if (!type) throw Error(formatProdErrorMessage(452));
				return type;
			case "head":
				type = props.head;
				if (!type) throw Error(formatProdErrorMessage(453));
				return type;
			case "body":
				type = props.body;
				if (!type) throw Error(formatProdErrorMessage(454));
				return type;
			default: throw Error(formatProdErrorMessage(451));
		}
	}
	function releaseSingletonInstance(instance) {
		for (var attributes = instance.attributes; attributes.length;) instance.removeAttributeNode(attributes[0]);
		detachDeletedInstance(instance);
	}
	var preloadPropsMap = new Map(), __unused_5B68 = new Set();
	function getHoistableRoot(container) {
		return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
	}
	ReactDOMSharedInternals.b = { a: flushSyncWork };
	function flushSyncWork() {
		var __unused_0697 = flushSyncWork$1();
		return;
	}
	function getResource(type, currentProps, pendingProps, currentResource) {
		var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
		if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
		switch (type) {
			case "meta":
			case "title": return null;
			case "style": return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
				type: "style",
				instance: null,
				count: 0,
				state: null
			}, pendingProps.set(currentProps, currentResource)), currentResource) : {
				type: "void",
				instance: null,
				count: 0,
				state: null
			};
			case "link":
				if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
					type = getStyleKey(pendingProps.href);
					var styles$243 = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles, resource$244 = styles$243.get(type);
					resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
						type: "stylesheet",
						instance: null,
						count: 0,
						state: {
							loading: 0,
							preload: null
						}
					}, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(getStylesheetSelectorFromKey(type))) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
						rel: "preload",
						as: "style",
						href: pendingProps.href,
						crossOrigin: pendingProps.crossOrigin,
						integrity: pendingProps.integrity,
						media: pendingProps.media,
						hrefLang: pendingProps.hrefLang,
						referrerPolicy: pendingProps.referrerPolicy
					}, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(JSCompiler_inline_result, type, pendingProps, resource$244.state)));
					if (currentProps && null === currentResource) throw Error(formatProdErrorMessage(528, ""));
					return resource$244;
				}
				if (currentProps && null !== currentResource) throw Error(formatProdErrorMessage(529, ""));
				return null;
			case "script": return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
				type: "script",
				instance: null,
				count: 0,
				state: null
			}, pendingProps.set(currentProps, currentResource)), currentResource) : {
				type: "void",
				instance: null,
				count: 0,
				state: null
			};
			default: throw Error(formatProdErrorMessage(444, type));
		}
	}
	function getStyleKey(href) {
		return "href=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(href) + "\"";
	}
	function getStylesheetSelectorFromKey(key) {
		return "link[rel=\"stylesheet\"][" + key + "]";
	}
	function stylesheetPropsFromRawProps(rawProps) {
		return assign({}, rawProps, {
			"data-precedence": rawProps.precedence,
			precedence: null
		});
	}
	function preloadStylesheet(ownerDocument, key, preloadProps, state) {
		ownerDocument.querySelector("link[rel=\"preload\"][as=\"style\"][" + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
			return state.loading |= 1;
		}), key.addEventListener("error", function() {
			return state.loading |= 2;
		}), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
	}
	function getScriptKey(src) {
		return "[src=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(src) + "\"]";
	}
	function getScriptSelectorFromKey(key) {
		return "script[async]" + key;
	}
	function acquireResource(hoistableRoot, resource, props) {
		resource.count++;
		if (null === resource.instance) switch (resource.type) {
			case "style":
				var instance = hoistableRoot.querySelector("style[data-href~=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + "\"]");
				if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance;
				var styleProps = assign({}, props, {
					"data-href": props.href,
					"data-precedence": props.precedence,
					href: null,
					precedence: null
				});
				instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
				markNodeAsHoistable(instance);
				setInitialProperties(instance, "style", styleProps);
				insertStylesheet(instance, props.precedence, hoistableRoot);
				return resource.instance = instance;
			case "stylesheet":
				styleProps = getStyleKey(props.href);
				var instance$249 = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
				if (instance$249) return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
				instance = stylesheetPropsFromRawProps(props);
				(styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
				instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
				markNodeAsHoistable(instance$249);
				var linkInstance = instance$249;
				linkInstance._p = new Promise(function(resolve, reject) {
					linkInstance.onload = resolve;
					linkInstance.onerror = reject;
				});
				setInitialProperties(instance$249, "link", instance);
				resource.state.loading |= 4;
				insertStylesheet(instance$249, props.precedence, hoistableRoot);
				return resource.instance = instance$249;
			case "script":
				instance$249 = getScriptKey(props.src);
				if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(instance$249))) return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
				instance = props;
				if (styleProps = preloadPropsMap.get(instance$249)) instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
				hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
				styleProps = hoistableRoot.createElement("script");
				markNodeAsHoistable(styleProps);
				setInitialProperties(styleProps, "link", instance);
				hoistableRoot.head.appendChild(styleProps);
				return resource.instance = styleProps;
			case "void": return null;
			default: throw Error(formatProdErrorMessage(443, resource.type));
		}
		else "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
		return resource.instance;
	}
	function insertStylesheet(instance, precedence, root) {
		for (var nodes = root.querySelectorAll("link[rel=\"stylesheet\"][data-precedence],style[data-precedence]"), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
			var node = nodes[i];
			if (node.dataset.precedence === precedence) prior = node;
			else if (prior !== last) break;
		}
		prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root.nodeType ? root.head : root, precedence.insertBefore(instance, precedence.firstChild));
	}
	function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
		null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
		null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
		null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
	}
	function adoptPreloadPropsForScript(scriptProps, preloadProps) {
		null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
		null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
		null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
	}
	var tagCaches = null;
	function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
		if (null === tagCaches) {
			var cache = new Map();
			var caches = tagCaches = new Map();
			caches.set(ownerDocument, cache);
		} else caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map(), caches.set(ownerDocument, cache));
		if (cache.has(type)) return cache;
		cache.set(type, null);
		ownerDocument = ownerDocument.getElementsByTagName(type);
		for (caches = 0; caches < ownerDocument.length; caches++) {
			var node = ownerDocument[caches];
			if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
				var nodeKey = node.getAttribute(keyAttribute) || "";
				nodeKey = type + nodeKey;
				var existing = cache.get(nodeKey);
				existing ? existing.push(node) : cache.set(nodeKey, [node]);
			}
		}
		return cache;
	}
	function mountHoistable(hoistableRoot, type, instance) {
		hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
		hoistableRoot.head.insertBefore(instance, "title" === type ? hoistableRoot.querySelector("head > title") : null);
	}
	function isHostHoistableType(type, props, hostContext) {
		if (1 === hostContext || null != props.itemProp) return false;
		switch (type) {
			case "meta":
			case "title": return true;
			case "style":
				if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) break;
				return true;
			case "link":
				if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) break;
				switch (props.rel) {
					case "stylesheet": return type = props.disabled, "string" === typeof props.precedence && null == type;
					default: return true;
				}
			case "script": if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src) return true;
		}
		return false;
	}
	function preloadResource(resource) {
		return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
	}
	function suspendResource(state, hoistableRoot, resource, props) {
		if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
			if (null === resource.instance) {
				var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
				if (instance) {
					hoistableRoot = instance._p;
					null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
					resource.state.loading |= 4;
					resource.instance = instance;
					markNodeAsHoistable(instance);
					return;
				}
				instance = hoistableRoot.ownerDocument || hoistableRoot;
				props = stylesheetPropsFromRawProps(props);
				(key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
				instance = instance.createElement("link");
				markNodeAsHoistable(instance);
				var linkInstance = instance;
				linkInstance._p = new Promise(function(resolve, reject) {
					linkInstance.onload = resolve;
					linkInstance.onerror = reject;
				});
				setInitialProperties(instance, "link", props);
				resource.instance = instance;
			}
			null === state.stylesheets && (state.stylesheets = new Map());
			state.stylesheets.set(resource, hoistableRoot);
			(hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
		}
	}
	var estimatedBytesWithinLimit = 0;
	function waitForCommitToBeReady(state, timeoutOffset) {
		state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
		return 0 < state.count || 0 < state.imgCount ? function(commit) {
			var stylesheetTimer = setTimeout(function() {
				state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
				if (state.unsuspend) {
					var unsuspend = state.unsuspend;
					state.unsuspend = null;
					unsuspend();
				}
			}, 6e4 + timeoutOffset);
			0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
			var imgTimer = setTimeout(function() {
				state.waitingForImages = false;
				if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
					var unsuspend = state.unsuspend;
					state.unsuspend = null;
					unsuspend();
				}
			}, (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset);
			state.unsuspend = commit;
			return function() {
				state.unsuspend = null;
				clearTimeout(stylesheetTimer);
				clearTimeout(imgTimer);
			};
		} : null;
	}
	function onUnsuspend() {
		this.count--;
		if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
			if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
			else if (this.unsuspend) {
				var unsuspend = this.unsuspend;
				this.unsuspend = null;
				unsuspend();
			}
		}
	}
	var precedencesByRoot = null;
	function insertSuspendedStylesheets(state, resources) {
		state.stylesheets = null;
		null !== state.unsuspend && (state.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
	}
	function insertStylesheetIntoRoot(root, resource) {
		if (!(resource.state.loading & 4)) {
			var precedences = precedencesByRoot.get(root);
			if (precedences) var last = precedences.get(null);
			else {
				precedences = new Map();
				precedencesByRoot.set(root, precedences);
				for (var nodes = root.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < nodes.length; i++) {
					var node = nodes[i];
					if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media")) precedences.set(node.dataset.precedence, node), last = node;
				}
				last && precedences.set(null, last);
			}
			nodes = resource.instance;
			node = nodes.getAttribute("data-precedence");
			i = precedences.get(node) || last;
			i === last && precedences.set(null, nodes);
			precedences.set(node, nodes);
			this.count++;
			last = onUnsuspend.bind(this);
			nodes.addEventListener("load", last);
			nodes.addEventListener("error", last);
			i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root = 9 === root.nodeType ? root.head : root, root.insertBefore(nodes, root.firstChild));
			resource.state.loading |= 4;
		}
	}
	var HostTransitionContext = {
		$$typeof: REACT_CONTEXT_TYPE,
		Provider: null,
		Consumer: null,
		_currentValue: sharedNotPendingObject,
		_currentValue2: sharedNotPendingObject,
		_threadCount: 0
	};
	function FiberRootNode(containerInfo, __unused_FCC2, __unused_659A, __unused_0B9F, onUncaughtError, onCaughtError, onRecoverableError) {
		this.tag = 1;
		this.containerInfo = containerInfo;
		this.pingCache = this.pendingChildren = null;
		this.timeoutHandle = -1;
		this.callbackNode = (this.next = (this.pendingContext = (this.context = this.cancelPendingCommit = null, null), null), null);
		this.callbackPriority = 0;
		this.expirationTimes = createLaneMap(-1);
		this.entangledLanes = (this.shellSuspendCounter = (this.errorRecoveryDisabledLanes = (this.expiredLanes = (this.warmLanes = (this.pingedLanes = (this.suspendedLanes = this.pendingLanes = 0, 0), 0), 0), 0), 0), 0);
		this.entanglements = createLaneMap(0);
		this.hiddenUpdates = createLaneMap(null);
		this.identifierPrefix = "";
		this.onUncaughtError = onUncaughtError;
		this.onCaughtError = onCaughtError;
		this.onRecoverableError = onRecoverableError;
		this.pooledCacheLanes = 0;
		this.formState = null;
		this.incompleteTransitions = new Map();
	}
	function createFiberRoot(containerInfo, tag, __unused_659A_0, __unused_947B, __unused_796C, isStrictMode, __unused_0B9F_0, __unused_EFCE, onUncaughtError, onCaughtError, onRecoverableError) {
		containerInfo = new FiberRootNode(containerInfo, 0, 0, 0, onUncaughtError, onCaughtError, onRecoverableError);
		isStrictMode = createFiberImplClass(3, null, null, 1);
		containerInfo.current = isStrictMode;
		isStrictMode.stateNode = containerInfo;
		tag = createCache();
		tag.refCount++;
		containerInfo.pooledCache = tag;
		tag.refCount++;
		isStrictMode.memoizedState = {
			element: null,
			isDehydrated: false,
			cache: tag
		};
		initializeUpdateQueue(isStrictMode);
		return containerInfo;
	}
	function getContextForSubtree() {
		{
			return emptyContextObject;
		}
	}
	function updateContainerImpl(rootFiber, lane, element, container, parentComponent) {
		parentComponent = getContextForSubtree();
		null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
		container = createUpdate(lane);
		container.payload = { element };
		element = enqueueUpdate(rootFiber, container, lane);
		null !== element && (scheduleUpdateOnFiber(element, 0, lane), entangleTransitions(element, rootFiber, lane));
	}
	function markRetryLaneImpl(fiber, retryLane) {
		fiber = fiber.memoizedState;
		if (null !== fiber && null !== fiber.dehydrated) {
			var a = fiber.retryLane;
			fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
		}
	}
	function markRetryLaneIfNotHydrated(fiber, retryLane) {
		markRetryLaneImpl(fiber, retryLane);
		(fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
	}
	function attemptContinuousHydration(fiber) {
		if (13 === fiber.tag || 31 === fiber.tag) {
			var root = enqueueConcurrentRenderForLane(fiber, 67108864);
			null !== root && scheduleUpdateOnFiber(root, 0, 67108864);
			markRetryLaneIfNotHydrated(fiber, 67108864);
		}
	}
	var _enabled = true;
	function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
		var prevTransition = ReactSharedInternals.T;
		ReactSharedInternals.T = null;
		var previousPriority = ReactDOMSharedInternals.a;
		try {
			ReactDOMSharedInternals.a = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
		} finally {
			ReactDOMSharedInternals.a = previousPriority, ReactSharedInternals.T = prevTransition;
		}
	}
	function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
		var prevTransition = ReactSharedInternals.T;
		ReactSharedInternals.T = null;
		var previousPriority = ReactDOMSharedInternals.a;
		try {
			ReactDOMSharedInternals.a = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
		} finally {
			ReactDOMSharedInternals.a = previousPriority, ReactSharedInternals.T = prevTransition;
		}
	}
	function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
		if (_enabled) {
			var blockedOn = findInstanceBlockingEvent(nativeEvent);
			if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);
			else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();
			else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
				for (; null !== blockedOn;) {
					var fiber = getInstanceFromNode(blockedOn);
					if (null !== fiber) switch (fiber.tag) {
						case 3:
							fiber = fiber.stateNode;
							if (fiber.current.memoizedState.isDehydrated) {
								var lanes = getHighestPriorityLanes(fiber.pendingLanes);
								if (0 !== lanes) {
									var root = fiber;
									root.pendingLanes |= 2;
									for (root.entangledLanes |= 2; lanes;) {
										var lane = 1 << 31 - clz32(lanes);
										root.entanglements[1] |= lane;
										lanes &= ~lane;
									}
									ensureRootIsScheduled(fiber);
									0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
								}
							}
							break;
						case 31:
						case 13: root = enqueueConcurrentRenderForLane(fiber, 2), null !== root && scheduleUpdateOnFiber(root, 0, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
					}
					fiber = findInstanceBlockingEvent(nativeEvent);
					null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
					if (fiber === blockedOn) break;
					blockedOn = fiber;
				}
				null !== blockedOn && nativeEvent.stopPropagation();
			} else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
		}
	}
	function findInstanceBlockingEvent(nativeEvent) {
		nativeEvent = getEventTarget(nativeEvent);
		return findInstanceBlockingTarget(nativeEvent);
	}
	var return_targetInst = null;
	function findInstanceBlockingTarget(targetNode) {
		return_targetInst = null;
		targetNode = getClosestInstanceFromNode(targetNode);
		if (null !== targetNode) {
			var nearestMounted = getNearestMountedFiber(targetNode);
			if (null === nearestMounted) targetNode = null;
			else {
				var tag = nearestMounted.tag;
				if (13 === tag) {
					targetNode = getSuspenseInstanceFromFiber(nearestMounted);
					if (null !== targetNode) return targetNode;
					targetNode = null;
				} else if (31 === tag) {
					targetNode = getActivityInstanceFromFiber(nearestMounted);
					if (null !== targetNode) return targetNode;
					targetNode = null;
				} else if (3 === tag) {
					if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
					targetNode = null;
				} else nearestMounted !== targetNode && (targetNode = null);
			}
		}
		return_targetInst = targetNode;
		return null;
	}
	function getEventPriority(domEventName) {
		switch (domEventName) {
			case "beforetoggle":
			case "cancel":
			case "click":
			case "close":
			case "contextmenu":
			case "copy":
			case "cut":
			case "auxclick":
			case "dblclick":
			case "dragend":
			case "dragstart":
			case "drop":
			case "focusin":
			case "focusout":
			case "input":
			case "invalid":
			case "keydown":
			case "keypress":
			case "keyup":
			case "mousedown":
			case "mouseup":
			case "paste":
			case "pause":
			case "play":
			case "pointercancel":
			case "pointerdown":
			case "pointerup":
			case "ratechange":
			case "reset":
			case "resize":
			case "seeked":
			case "submit":
			case "toggle":
			case "touchcancel":
			case "touchend":
			case "touchstart":
			case "volumechange":
			case "change":
			case "selectionchange":
			case "textInput":
			case "compositionstart":
			case "compositionend":
			case "compositionupdate":
			case "beforeblur":
			case "afterblur":
			case "beforeinput":
			case "blur":
			case "fullscreenchange":
			case "focus":
			case "hashchange":
			case "popstate":
			case "select":
			case "selectstart": return 2;
			case "drag":
			case "dragenter":
			case "dragexit":
			case "dragleave":
			case "dragover":
			case "mousemove":
			case "mouseout":
			case "mouseover":
			case "pointermove":
			case "pointerout":
			case "pointerover":
			case "scroll":
			case "touchmove":
			case "wheel":
			case "mouseenter":
			case "mouseleave":
			case "pointerenter":
			case "pointerleave": return 8;
			case "message": switch (getCurrentPriorityLevel()) {
				case 1: return 2;
				case 2: return 8;
				case 3:
				case 4: return 32;
				case 5: return 268435456;
				default: return 32;
			}
			default: return 32;
		}
	}
	var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = new Map(), queuedPointerCaptures = new Map(), discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
	function clearIfContinuousEvent(domEventName, nativeEvent) {
		switch (domEventName) {
			case "focusin":
			case "focusout":
				queuedFocus = null;
				break;
			case "dragenter":
			case "dragleave":
				queuedDrag = null;
				break;
			case "mouseover":
			case "mouseout":
				queuedMouse = null;
				break;
			case "pointerover":
			case "pointerout":
				queuedPointers.delete(nativeEvent.pointerId);
				break;
			case "gotpointercapture":
			case "lostpointercapture": queuedPointerCaptures.delete(nativeEvent.pointerId);
		}
	}
	function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
		if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return existingQueuedEvent = {
			blockedOn,
			domEventName,
			eventSystemFlags,
			nativeEvent,
			targetContainers: [targetContainer]
		}, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
		existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
		blockedOn = existingQueuedEvent.targetContainers;
		null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
		return existingQueuedEvent;
	}
	function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
		switch (domEventName) {
			case "focusin": return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
			case "dragenter": return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
			case "mouseover": return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
			case "pointerover":
				var pointerId = nativeEvent.pointerId;
				queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
				return true;
			case "gotpointercapture": return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), true;
		}
		return false;
	}
	function attemptReplayContinuousQueuedEvent(queuedEvent) {
		if (null !== queuedEvent.blockedOn) return false;
		for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;) {
			var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
			if (null === nextBlockedOn) {
				nextBlockedOn = queuedEvent.nativeEvent;
				var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn);
				currentReplayingEvent = nativeEventClone;
				nextBlockedOn.target.dispatchEvent(nativeEventClone);
				currentReplayingEvent = null;
			} else return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
			targetContainers.shift();
		}
		return true;
	}
	function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
		attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
	}
	function replayUnblockedEvents() {
		hasScheduledReplayAttempt = false;
		null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
		null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
		null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
		queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
		queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
	}
	function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
		queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.n(3, replayUnblockedEvents)));
	}
	var lastScheduledReplayQueue = null;
	function scheduleReplayQueueIfNeeded(formReplayingQueue) {
		lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.n(3, function() {
			lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
			for (var i = 0; i < formReplayingQueue.length; i += 3) {
				var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
				if ("function" !== typeof submitterOrAction) if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;
				else break;
				var formInst = getInstanceFromNode(form);
				null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(formInst, {
					pending: true,
					data: formData,
					method: form.method,
					action: submitterOrAction
				}, submitterOrAction, formData));
			}
		}));
	}
	function retryIfBlockedOn(unblocked) {
		function unblock(queuedEvent) {
			return scheduleCallbackIfUnblocked(queuedEvent, unblocked), void 0;
		}
		null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
		null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
		null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
		queuedPointers.forEach(unblock);
		queuedPointerCaptures.forEach(unblock);
		{
			var i;
		}
		i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
		if (null != i) for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
			var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
			if ("function" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);
			else if (formProps) {
				var action = null;
				if (submitterOrAction && submitterOrAction.hasAttribute("formAction")) if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) action = formProps.formAction;
				else {
					if (null !== findInstanceBlockingTarget(form)) continue;
				}
				else action = formProps.action;
				"function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
				scheduleReplayQueueIfNeeded(i);
			}
		}
		var queuedTarget;
	}
	function ReactDOMRoot(internalRoot) {
		this._internalRoot = internalRoot;
	}
	ReactDOMRoot.prototype.render = function(children) {
		var root = this._internalRoot;
		if (null === root) throw Error(formatProdErrorMessage(409));
		var current = root.current, lane = requestUpdateLane();
		updateContainerImpl(current, lane, children, root);
	};
	ReactDOMRoot.prototype.unmount = function() {
		var root = this._internalRoot;
		if (null !== root) {
			this._internalRoot = null;
			var container = root.containerInfo;
			updateContainerImpl(root.current, 2, null, root);
			flushSyncWork$1();
			container[internalContainerInstanceKey] = null;
		}
	};
	var isomorphicReactPackageVersion$jscomp$inline_1840 = React.version;
	if ("19.2.4" !== isomorphicReactPackageVersion$jscomp$inline_1840) throw Error(formatProdErrorMessage(527, isomorphicReactPackageVersion$jscomp$inline_1840, "19.2.4"));
	var internals$jscomp$inline_2347 = {
		bundleType: 0,
		version: "19.2.4",
		rendererPackageName: "react-dom",
		currentDispatcherRef: ReactSharedInternals,
		reconcilerVersion: "19.2.4"
	};
	if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
		var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
		if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber) try {
			rendererID = hook$jscomp$inline_2348.inject(internals$jscomp$inline_2347), injectedHook = hook$jscomp$inline_2348;
		} catch {}
	}
	reactDomClient_production.a = function(container, options) {
		if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
		var onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
		options = createFiberRoot(container, 0, 0, 0, 0, 0, 0, 0, onUncaughtError, onCaughtError, onRecoverableError);
		container[internalContainerInstanceKey] = options.current;
		listenToAllSupportedEvents(container);
		return new ReactDOMRoot(options);
	};
	return reactDomClient_production;
}
function requireClient() {
	function checkDCE() {
		/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
		if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
			return;
		}
		try {
			// Verify that the code above has been dead code eliminated (DCE'd).
			__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
		} catch (err) {
			// DevTools shouldn't crash React, no matter what.
			// We should still report in case we break this code.
			console.error(err);
		}
	}
	{
		// DCE check should happen before ReactDOM bundle executes so that
		// DevTools can report bad minification during injection.
		checkDCE();
		client.a = requireReactDomClient_production();
	}
	return client.a;
}
var clientExports = requireClient();
var ReactDOM = getDefaultExportFromCjs(clientExports);
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable react-hooks/exhaustive-deps */
function useEvent(callback) {
	const fnRef = reactExports.useRef(callback);
	fnRef.current = callback;
	const memoFn = reactExports.useCallback((...args) => fnRef.current?.(...args), []);
	return memoFn;
}
function canUseDom() {
	return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
/**
* Wrap `React.useLayoutEffect` which will not throw warning message in test env
*/
const useInternalLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
const useLayoutEffect = (callback, deps) => {
	const firstMountRef = reactExports.useRef(true);
	useInternalLayoutEffect(() => {
		return callback(firstMountRef.current);
	}, deps);
	// We tell react that first mount has passed
	useInternalLayoutEffect(() => {
		firstMountRef.current = false;
		return () => {
			firstMountRef.current = true;
		};
	}, []);
};
const useLayoutUpdateEffect = (callback, deps) => {
	useLayoutEffect((firstMount) => {
		if (!firstMount) {
			return callback();
		}
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, deps);
};
/**
* Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
* We do not make this auto is to avoid real memory leak.
* Developer should confirm it's safe to ignore themselves.
*/
const useSafeState = (defaultValue) => {
	const destroyRef = reactExports.useRef(false);
	const [value, setValue] = reactExports.useState(defaultValue);
	reactExports.useEffect(() => {
		destroyRef.current = false;
		return () => {
			destroyRef.current = true;
		};
	}, []);
	function safeSetState(updater, ignoreDestroy) {
		if (ignoreDestroy && destroyRef.current) {
			return;
		}
		setValue(updater);
	}
	return [value, safeSetState];
};
/**
* Similar to `useState` but will use props value if provided.
* From React 18, we do not need safe `useState` since it will not throw for unmounted update.
* This hooks remove the `onChange` & `postState` logic since we only need basic merged state logic.
*/
function useControlledState(defaultStateValue, value) {
	const [innerValue, setInnerValue] = reactExports.useState(defaultStateValue);
	const mergedValue = value !== void 0 ? value : innerValue;
	useLayoutEffect((mount) => {
		if (!mount) {
			setInnerValue(value);
		}
	}, [value]);
	return [mergedValue, setInnerValue];
}
var reactIs = {};
var reactIs_production_min = {};
function requireReactIs_production_min() {
	var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy");
	function v(a) {
		if ("object" === typeof a && null !== a) {
			var r = a.$$typeof;
			switch (r) {
				case b: switch (a = a.type, a) {
					case d:
					case f:
					case e:
					case m:
					case n: return a;
					default: switch (a = a && a.$$typeof, a) {
						case k:
						case h:
						case l:
						case q:
						case p:
						case g: return a;
						default: return r;
					}
				}
				case c: return r;
			}
		}
	}
	reactIs_production_min.d = l;
	reactIs_production_min.u = function(a) {
		return v(a) === p;
	};
	return reactIs_production_min;
}
function requireReactIs() {
	{
		reactIs.a = requireReactIs_production_min();
	}
	return reactIs.a;
}
var reactIsExports = requireReactIs();
function useMemo(getValue, condition, shouldUpdate) {
	const cacheRef = reactExports.useRef({});
	if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
		cacheRef.current.value = getValue();
		cacheRef.current.condition = condition;
	}
	return cacheRef.current.value;
}
const REACT_ELEMENT_TYPE_18 = Symbol.for("react.element");
const REACT_ELEMENT_TYPE_19 = Symbol.for("react.transitional.element");
const REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
/**
* Compatible with React 18 or 19 to check if node is a Fragment.
*/
function isFragment$1(object) {
	return object && typeof object === "object" && (object.$$typeof === REACT_ELEMENT_TYPE_18 || object.$$typeof === REACT_ELEMENT_TYPE_19) && object.type === REACT_FRAGMENT_TYPE;
}
const ReactMajorVersion = Number(reactExports.version.split(".")[0]);
const fillRef = (ref, node) => {
	if (typeof ref === "function") {
		ref(node);
	} else if (typeof ref === "object" && ref && "current" in ref) {
		ref.current = node;
	}
};
/**
* Merge refs into one ref function to support ref passing.
*/
const composeRef = (...refs) => {
	const refList = refs.filter(Boolean);
	if (refList.length <= 1) {
		return refList[0];
	}
	return (node) => {
		refs.forEach((ref) => {
			fillRef(ref, node);
		});
	};
};
const useComposeRef = (...refs) => {
	return useMemo(
		() => composeRef(...refs),
		// eslint-disable-next-line react-hooks/exhaustive-deps
		refs,
		(prev, next) => prev.length !== 2 || prev.every((ref, i) => ref !== next[i])
	);
};
const supportRef = (nodeOrComponent) => {
	if (!nodeOrComponent) {
		return false;
	}
	// React 19 no need `forwardRef` anymore. So just pass if is a React element.
	if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) {
		return true;
	}
	const type = reactIsExports.u(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
	// Function component node
	if (typeof type === "function" && !type.prototype?.render && type.$$typeof !== reactIsExports.d) {
		return false;
	}
	// Class component
	if (typeof nodeOrComponent === "function" && !nodeOrComponent.prototype?.render && nodeOrComponent.$$typeof !== reactIsExports.d) {
		return false;
	}
	return true;
};
function isReactElement(node) {
	return reactExports.isValidElement(node) && !isFragment$1(node);
}
/**
* In React 19. `ref` is not a property from node.
* But a property from `props.ref`.
* To check if `props.ref` exist or fallback to `ref`.
*/
const getNodeRef = (node) => {
	if (node && isReactElement(node)) {
		const ele = node;
		// Source from:
		// https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/getReactNodeRef/getReactNodeRef.ts
		return ele.props.propertyIsEnumerable("ref") ? ele.props.ref : ele.ref;
	}
	return null;
};
function get(entity, path) {
	let current = entity;
	for (let i = 0; i < path.length; i += 1) {
		if (current === null || current === void 0) {
			return void 0;
		}
		current = current[path[i]];
	}
	return current;
}
function internalSet(entity, paths, value, removeIfUndefined) {
	if (!paths.length) {
		return value;
	}
	const [path, ...restPath] = paths;
	let clone;
	if (!entity && typeof path === "number") {
		clone = [];
	} else if (Array.isArray(entity)) {
		clone = [...entity];
	} else {
		clone = { ...entity };
	}
	// Delete prop if `removeIfUndefined` and value is undefined
	if (removeIfUndefined && value === void 0 && restPath.length === 1) {
		delete clone[path][restPath[0]];
	} else {
		clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
	}
	return clone;
}
function set(entity, paths, value, removeIfUndefined = false) {
	// Do nothing if `removeIfUndefined` and parent object not exist
	if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
		return entity;
	}
	return internalSet(entity, paths, value, removeIfUndefined);
}
function isObject(obj) {
	return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function createEmpty(source) {
	return Array.isArray(source) ? [] : {};
}
const keys = Reflect.ownKeys;
// ================================ Merge ================================
/**
* Merge multiple objects. Support custom merge logic.
* @param sources object sources
* @param config.prepareArray Customize array prepare function.
* It will return empty [] by default.
* So when match array, it will auto be override with next array in sources.
*/
function mergeWith(sources, config = {}) {
	const { prepareArray } = config;
	const finalPrepareArray = prepareArray || (() => []);
	let clone = createEmpty(sources[0]);
	sources.forEach((src) => {
		function internalMerge(path, parentLoopSet) {
			const loopSet = new Set(parentLoopSet);
			const value = get(src, path);
			const isArr = Array.isArray(value);
			if (isArr || isObject(value)) {
				// Only add not loop obj
				if (!loopSet.has(value)) {
					loopSet.add(value);
					const originValue = get(clone, path);
					if (isArr) {
						// Array will always be override
						clone = set(clone, path, finalPrepareArray(originValue, value));
					} else if (!originValue || typeof originValue !== "object") {
						// Init container if not exist
						clone = set(clone, path, createEmpty(value));
					}
					keys(value).forEach((key) => {
						if (Object.getOwnPropertyDescriptor(value, key).enumerable) {
							internalMerge([...path, key], loopSet);
						}
					});
				}
			} else {
				clone = set(clone, path, value);
			}
		}
		internalMerge([]);
	});
	return clone;
}
/**
* Merge multiple objects into a new single object.
* Arrays will be replaced by default.
*/
function merge$1(...sources) {
	return mergeWith(sources);
}
/* eslint-disable no-console */
let warned = {};
function call(__unused_49C5, valid, message) {
	if (!valid && !warned[message]) {
		warned[message] = true;
	}
}
/** @see Same as {@link warning}, but only warn once for the same message */
function warningOnce(valid, message) {
	call(0, valid, message);
}
function omit(obj, fields) {
	const clone = Object.assign({}, obj);
	if (Array.isArray(fields)) {
		fields.forEach((key) => {
			delete clone[key];
		});
	}
	return clone;
}
function toArray$3(children, option = {}) {
	let ret = [];
	React.Children.forEach(children, (child) => {
		if ((child === void 0 || child === null) && !option.keepEmpty) {
			return;
		}
		if (Array.isArray(child)) {
			ret = ret.concat(toArray$3(child));
		} else if (isFragment$1(child) && child.props) {
			ret = ret.concat(toArray$3(child.props.children, option));
		} else {
			ret.push(child);
		}
	});
	return ret;
}
const WarningContext = reactExports.createContext({});
function isDOM(node) {
	// https://developer.mozilla.org/en-US/docs/Web/API/Element
	// Since XULElement is also subclass of Element, we only need HTMLElement and SVGElement
	return node instanceof HTMLElement || node instanceof SVGElement;
}
/**
* Retrieves a DOM node via a ref, and does not invoke `findDOMNode`.
*/
function getDOM(node) {
	if (node && typeof node === "object" && isDOM(node.nativeElement)) {
		return node.nativeElement;
	}
	if (isDOM(node)) {
		return node;
	}
	return null;
}
const CollectionContext = reactExports.createContext(null);
/**
* Collect all the resize event from children ResizeObserver
*/
function Collection({ children, onBatchResize }) {
	const resizeIdRef = reactExports.useRef(0);
	const resizeInfosRef = reactExports.useRef([]);
	const onCollectionResize = reactExports.useContext(CollectionContext);
	const onResize = reactExports.useCallback((size, element, data) => {
		resizeIdRef.current += 1;
		const currentId = resizeIdRef.current;
		resizeInfosRef.current.push({
			size,
			element,
			data
		});
		Promise.resolve().then(() => {
			if (currentId === resizeIdRef.current) {
				onBatchResize?.(resizeInfosRef.current);
				resizeInfosRef.current = [];
			}
		});
		// Continue bubbling if parent exist
		onCollectionResize?.(size, element, data);
	}, [onBatchResize, onCollectionResize]);
	return reactExports.createElement(CollectionContext.Provider, { value: onResize }, children);
}
// =============================== Const ===============================
const elementListeners = new Map();
function onResize(entities) {
	entities.forEach((entity) => {
		const { target } = entity;
		elementListeners.get(target)?.forEach((listener) => listener(target));
	});
}
// Delay create ResizeObserver since it's not supported in server side
let observer;
function ensureResizeObserver() {
	if (!observer) {
		observer = new ResizeObserver(onResize);
	}
	return observer;
}
// ============================== Observe ==============================
function observe(element, callback) {
	if (!elementListeners.has(element)) {
		elementListeners.set(element, new Set());
		ensureResizeObserver().observe(element);
	}
	elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
	if (elementListeners.has(element)) {
		elementListeners.get(element).delete(callback);
		if (!elementListeners.get(element).size) {
			ensureResizeObserver().unobserve(element);
			elementListeners.delete(element);
		}
	}
}
function useResizeObserver(enabled, getTarget, onDelayResize, onSyncResize) {
	// ============================= Size =============================
	const sizeRef = reactExports.useRef({
		width: -1,
		height: -1,
		offsetWidth: -1,
		offsetHeight: -1
	});
	// =========================== Observe ============================
	// Handler
	const onInternalResize = useEvent((target) => {
		const { width, height } = target.getBoundingClientRect();
		const { offsetWidth, offsetHeight } = target;
		/**
		* Resize observer trigger when content size changed.
		* In most case we just care about element size,
		* let's use `boundary` instead of `contentRect` here to avoid shaking.
		*/
		const fixedWidth = Math.floor(width);
		const fixedHeight = Math.floor(height);
		if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
			const size = {
				width: fixedWidth,
				height: fixedHeight,
				offsetWidth,
				offsetHeight
			};
			sizeRef.current = size;
			// IE is strange, right?
			const mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
			const mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
			const sizeInfo = {
				...size,
				offsetWidth: mergedOffsetWidth,
				offsetHeight: mergedOffsetHeight
			};
			// Call the callback immediately, let the caller decide whether to defer
			// onResize(sizeInfo, target);
			onSyncResize?.(sizeInfo, target);
			// defer the callback but not defer to next frame
			Promise.resolve().then(() => {
				onDelayResize?.(sizeInfo, target);
			});
		}
	});
	// Dynamic observe
	const isFuncTarget = typeof getTarget === "function";
	reactExports.useEffect(() => {
		const target = isFuncTarget ? getTarget() : getTarget;
		if (target && enabled) {
			observe(target, onInternalResize);
		}
		return () => {
			if (target) {
				unobserve(target, onInternalResize);
			}
		};
	}, [enabled, isFuncTarget ? 0 : getTarget]);
}
function SingleObserver(props, ref) {
	const { children, disabled, onResize, data } = props;
	const elementRef = reactExports.useRef(null);
	const onCollectionResize = reactExports.useContext(CollectionContext);
	// =========================== Children ===========================
	const isRenderProps = typeof children === "function";
	const mergedChildren = isRenderProps ? children(elementRef) : children;
	// ============================= Ref ==============================
	const canRef = !isRenderProps && reactExports.isValidElement(mergedChildren) && supportRef(mergedChildren);
	const originRef = canRef ? getNodeRef(mergedChildren) : null;
	const mergedRef = useComposeRef(originRef, elementRef);
	const getDomElement = () => {
		return getDOM(elementRef.current);
	};
	reactExports.useImperativeHandle(ref, () => getDomElement());
	// =========================== Observe ============================
	useResizeObserver(!disabled, getDomElement, onResize, (sizeInfo, target) => {
		onCollectionResize?.(sizeInfo, target, data);
	});
	// ============================ Render ============================
	return canRef ? reactExports.cloneElement(mergedChildren, { ref: mergedRef }) : mergedChildren;
}
const RefSingleObserver = reactExports.forwardRef(SingleObserver);
function _extends$x() {
	_extends$x = Object.assign.bind();
	return _extends$x.apply(this, arguments);
}
const INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver$1(props, ref) {
	const { children } = props;
	const childNodes = typeof children === "function" ? [children] : toArray$3(children);
	return childNodes.map((child, index) => {
		const key = child?.key || `${INTERNAL_PREFIX_KEY}-${index}`;
		return reactExports.createElement(RefSingleObserver, _extends$x({}, props, {
			key,
			ref: index === 0 ? ref : void 0
		}), child);
	});
}
const RefResizeObserver = reactExports.forwardRef(ResizeObserver$1);
RefResizeObserver.Collection = Collection;
function r(e) {
	var t, f, n = "";
	if ("string" == typeof e || "number" == typeof e) n += e;
	else if ("object" == typeof e) if (Array.isArray(e)) {
		var o = e.length;
		for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
	} else for (f in e) e[f] && (n && (n += " "), n += f);
	return n;
}
function clsx() {
	for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
	return n;
}
function _arrayLikeToArray$y(r, a) {
	(null == a || a > r.length) && (a = r.length);
	for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
	return n;
}
function _arrayWithoutHoles$8(r) {
	if (Array.isArray(r)) return _arrayLikeToArray$y(r);
}
function _iterableToArray$8(r) {
	if (null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _unsupportedIterableToArray$y(r, a) {
	if (r) {
		if ("string" == typeof r) return _arrayLikeToArray$y(r, a);
		var t = {}.toString.call(r).slice(8, -1);
		return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$y(r, a) : void 0;
	}
}
function _nonIterableSpread$8() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray$8(r) {
	return _arrayWithoutHoles$8(r) || _iterableToArray$8(r) || _unsupportedIterableToArray$y(r) || _nonIterableSpread$8();
}
let raf = (callback) => +setTimeout(callback, 16);
let caf = (num) => clearTimeout(num);
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
	raf = (callback) => window.requestAnimationFrame(callback);
	caf = (handle) => window.cancelAnimationFrame(handle);
}
let rafUUID = 0;
const rafIds = new Map();
function cleanup(id) {
	rafIds.delete(id);
}
const wrapperRaf = (callback, times = 1) => {
	rafUUID += 1;
	const id = rafUUID;
	function callRef(leftTimes) {
		if (leftTimes === 0) {
			// Clean up
			cleanup(id);
			// Trigger
			callback();
		} else {
			// Next raf
			const realId = raf(() => {
				callRef(leftTimes - 1);
			});
			// Bind real raf id
			rafIds.set(id, realId);
		}
	}
	callRef(times);
	return id;
};
wrapperRaf.a = (id) => {
	const realId = rafIds.get(id);
	cleanup(id);
	return caf(realId);
};
const Variants = [
	"outlined",
	"borderless",
	"filled",
	"underlined"
];
const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
	if (customizePrefixCls) {
		return customizePrefixCls;
	}
	return suffixCls ? `${"ant"}-${suffixCls}` : "ant";
};
// zombieJ:  Do not pass `defaultRenderEmpty` here since it will cause circular dependency.
const ConfigContext = reactExports.createContext({
	getPrefixCls: defaultGetPrefixCls,
	iconPrefixCls: "anticon"
});
const EMPTY_OBJECT = {};
/**
* Get ConfigProvider configured component props.
* This help to reduce bundle size for saving `?.` operator.
* Do not use as `useMemo` deps since we do not cache the object here.
*
* NOTE: not refactor this with `useMemo` since memo will cost another memory space,
* which will waste both compare calculation & memory.
*/
function useComponentConfig(propName) {
	const context = reactExports.useContext(ConfigContext);
	const { getPrefixCls, direction } = context;
	const propValue = context[propName];
	return {
		classNames: EMPTY_OBJECT,
		styles: EMPTY_OBJECT,
		...propValue,
		getPrefixCls,
		direction
	};
}
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
	// 'm' and 'r' are mixing constants generated offline.
	// They're not really 'magic', they just happen to work well.
	// const m = 0x5bd1e995;
	// const r = 24;
	// Initialize the hash
	var h = 0;
	var k, i = 0, len = str.length;
	for (; len >= 4; ++i, len -= 4) {
		k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
		k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
		k ^= k >>> 24;
		h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
	}
	switch (len) {
		case 3: h ^= (str.charCodeAt(i + 2) & 255) << 16;
		case 2: h ^= (str.charCodeAt(i + 1) & 255) << 8;
		case 1:
			h ^= str.charCodeAt(i) & 255;
			h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
	}
	// bytes are well-incorporated.
	h ^= h >>> 13;
	h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
	return ((h ^ h >>> 15) >>> 0).toString(36);
}
function contains(root, n) {
	if (!root) {
		return false;
	}
	// Use native if support
	if (root.contains) {
		return root.contains(n);
	}
	// `document.contains` not support with IE11
	let node = n;
	while (node) {
		if (node === root) {
			return true;
		}
		node = node.parentNode;
	}
	return false;
}
const APPEND_ORDER = "data-rc-order";
const APPEND_PRIORITY = "data-rc-priority";
const containerCache = new Map();
function getMark({ mark }) {
	if (mark) {
		return mark.startsWith("data-") ? mark : `data-${mark}`;
	}
	return "rc-util-key";
}
function getContainer(option) {
	if (option.attachTo) {
		return option.attachTo;
	}
	const head = document.querySelector("head");
	return head || document.body;
}
function getOrder(prepend) {
	if (prepend === "queue") {
		return "prependQueue";
	}
	return prepend ? "prepend" : "append";
}
/**
* Find style which inject by rc-util
*/
function findStyles(container) {
	return Array.from((containerCache.get(container) || container).children).filter((node) => node.tagName === "STYLE");
}
function injectCSS(css, option) {
	if (!canUseDom()) {
		return null;
	}
	const { csp, prepend, priority = 0 } = option;
	const mergedOrder = getOrder(prepend);
	const isPrependQueue = mergedOrder === "prependQueue";
	const styleNode = document.createElement("style");
	styleNode.setAttribute(APPEND_ORDER, mergedOrder);
	if (isPrependQueue && priority) {
		styleNode.setAttribute(APPEND_PRIORITY, `${priority}`);
	}
	if (csp?.nonce) {
		styleNode.nonce = csp?.nonce;
	}
	styleNode.innerHTML = css;
	const container = getContainer(option);
	const { firstChild } = container;
	if (prepend) {
		// If is queue `prepend`, it will prepend first style and then append rest style
		if (isPrependQueue) {
			const existStyle = (option.styles || findStyles(container)).filter((node) => {
				// Ignore style which not injected by rc-util with prepend
				if (!["prepend", "prependQueue"].includes(node.getAttribute(APPEND_ORDER))) {
					return false;
				}
				// Ignore style which priority less then new style
				const nodePriority = Number(node.getAttribute(APPEND_PRIORITY) || 0);
				return priority >= nodePriority;
			});
			if (existStyle.length) {
				container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
				return styleNode;
			}
		}
		// Use `insertBefore` as `prepend`
		container.insertBefore(styleNode, firstChild);
	} else {
		container.appendChild(styleNode);
	}
	return styleNode;
}
function findExistNode(key, option) {
	let { styles } = option;
	styles ||= findStyles(getContainer(option));
	return styles.find((node) => node.getAttribute(getMark(option)) === key);
}
function removeCSS(key, option = {}) {
	const existNode = findExistNode(key, option);
	if (existNode) {
		const container = getContainer(option);
		container.removeChild(existNode);
	}
}
/**
* qiankun will inject `appendChild` to insert into other
*/
function syncRealContainer(container, option) {
	const cachedRealContainer = containerCache.get(container);
	// Find real container when not cached or cached container removed
	if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
		const placeholderStyle = injectCSS("", option);
		const { parentNode } = placeholderStyle;
		containerCache.set(container, parentNode);
		container.removeChild(placeholderStyle);
	}
}
function updateCSS(css, key, originOption = {}) {
	const container = getContainer(originOption);
	const styles = findStyles(container);
	const option = {
		...originOption,
		styles
	};
	// Sync real parent
	syncRealContainer(container, option);
	const existNode = findExistNode(key, option);
	if (existNode) {
		if (option.csp?.nonce && existNode.nonce !== option.csp?.nonce) {
			existNode.nonce = option.csp?.nonce;
		}
		if (existNode.innerHTML !== css) {
			existNode.innerHTML = css;
		}
		return existNode;
	}
	const newNode = injectCSS(css, option);
	newNode.setAttribute(getMark(option), key);
	return newNode;
}
/**
* Deeply compares two object literals.
* @param obj1 object 1
* @param obj2 object 2
* @param shallow shallow compare
* @returns
*/
function isEqual(obj1, obj2, shallow = false) {
	// https://github.com/mapbox/mapbox-gl-js/pull/5979/files#diff-fde7145050c47cc3a306856efd5f9c3016e86e859de9afbd02c879be5067e58f
	const refSet = new Set();
	function deepEqual(a, b, level = 1) {
		const circular = refSet.has(a);
		warningOnce(!circular, "Warning: There may be circular references");
		if (circular) {
			return false;
		}
		if (a === b) {
			return true;
		}
		if (shallow && level > 1) {
			return false;
		}
		refSet.add(a);
		const newLevel = level + 1;
		if (Array.isArray(a)) {
			if (!Array.isArray(b) || a.length !== b.length) {
				return false;
			}
			for (let i = 0; i < a.length; i++) {
				if (!deepEqual(a[i], b[i], newLevel)) {
					return false;
				}
			}
			return true;
		}
		if (a && b && typeof a === "object" && typeof b === "object") {
			const keys = Object.keys(a);
			if (keys.length !== Object.keys(b).length) {
				return false;
			}
			return keys.every((key) => deepEqual(a[key], b[key], newLevel));
		}
		// other
		return false;
	}
	return deepEqual(obj1, obj2);
}
/** Connect key with `SPLIT` */
function pathKey(keys) {
	return keys.join("%");
}
/** Record update id for extract static style order. */
let updateId = 0;
class Entity {
	constructor(instanceId) {
		this.instanceId = instanceId;
	}
	/** @private Internal cache map. Do not access this directly */
	cache = new Map();
	/** @private Record update times for each key */
	updateTimes = new Map();
	extracted = new Set();
	get(keys) {
		return this.opGet(pathKey(keys));
	}
	/** A fast get cache with `get` concat. */
	opGet(keyPathStr) {
		return this.cache.get(keyPathStr) || null;
	}
	update(keys, valueFn) {
		return this.opUpdate(pathKey(keys), valueFn);
	}
	/** A fast get cache with `get` concat. */
	opUpdate(keyPathStr, valueFn) {
		const prevValue = this.cache.get(keyPathStr);
		const nextValue = valueFn(prevValue);
		if (nextValue === null) {
			this.cache.delete(keyPathStr);
			this.updateTimes.delete(keyPathStr);
		} else {
			this.cache.set(keyPathStr, nextValue);
			this.updateTimes.set(keyPathStr, updateId);
			updateId += 1;
		}
	}
}
const ATTR_TOKEN = "data-token-hash";
const ATTR_MARK = "data-css-hash";
// Mark css-in-js instance in style element
const CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
function createCache() {
	const cssinjsInstanceId = Math.random().toString(12).slice(2);
	// Tricky SSR: Move all inline style to the head.
	// PS: We do not recommend tricky mode.
	if (typeof document !== "undefined" && document.head && document.body) {
		const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
		const { firstChild } = document.head;
		Array.from(styles).forEach((style) => {
			style[CSS_IN_JS_INSTANCE] ||= cssinjsInstanceId;
			// Not force move if no head
			if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
				document.head.insertBefore(style, firstChild);
			}
		});
		// Deduplicate of moved styles
		const styleHash = {};
		Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style) => {
			const hash = style.getAttribute(ATTR_MARK);
			if (styleHash[hash]) {
				if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
					style.parentNode?.removeChild(style);
				}
			} else {
				styleHash[hash] = true;
			}
		});
	}
	return new Entity(cssinjsInstanceId);
}
const StyleContext = reactExports.createContext({
	hashPriority: "low",
	cache: createCache(),
	defaultCache: true,
	autoPrefix: false
});
// ================================== Cache ==================================
function sameDerivativeOption(left, right) {
	if (left.length !== right.length) {
		return false;
	}
	for (let i = 0; i < left.length; i++) {
		if (left[i] !== right[i]) {
			return false;
		}
	}
	return true;
}
class ThemeCache {
	constructor() {
		this.cache = new Map();
		this.keys = [];
		this.cacheCallTimes = 0;
	}
	size() {
		return this.keys.length;
	}
	internalGet(derivativeOption, updateCallTimes = false) {
		let cache = { map: this.cache };
		derivativeOption.forEach((derivative) => {
			if (!cache) {
				cache = void 0;
			} else {
				cache = cache?.map?.get(derivative);
			}
		});
		if (cache?.value && updateCallTimes) {
			cache.value[1] = this.cacheCallTimes++;
		}
		return cache?.value;
	}
	get(derivativeOption) {
		return this.internalGet(derivativeOption, true)?.[0];
	}
	has(derivativeOption) {
		return !!this.internalGet(derivativeOption);
	}
	set(derivativeOption, value) {
		// New cache
		if (!this.has(derivativeOption)) {
			if (this.size() + 1 > 25) {
				const [targetKey] = this.keys.reduce((result, key) => {
					const [, callTimes] = result;
					if (this.internalGet(key)[1] < callTimes) {
						return [key, this.internalGet(key)[1]];
					}
					return result;
				}, [this.keys[0], this.cacheCallTimes]);
				this.delete(targetKey);
			}
			this.keys.push(derivativeOption);
		}
		let cache = this.cache;
		derivativeOption.forEach((derivative, index) => {
			if (index === derivativeOption.length - 1) {
				cache.set(derivative, { value: [value, this.cacheCallTimes++] });
			} else {
				const cacheValue = cache.get(derivative);
				if (!cacheValue) {
					cache.set(derivative, { map: new Map() });
				} else if (!cacheValue.map) {
					cacheValue.map = new Map();
				}
				cache = cache.get(derivative).map;
			}
		});
	}
	deleteByPath(currentCache, derivatives) {
		const cache = currentCache.get(derivatives[0]);
		if (derivatives.length === 1) {
			if (!cache.map) {
				currentCache.delete(derivatives[0]);
			} else {
				currentCache.set(derivatives[0], { map: cache.map });
			}
			return cache.value?.[0];
		}
		const result = this.deleteByPath(cache.map, derivatives.slice(1));
		if ((!cache.map || cache.map.size === 0) && !cache.value) {
			currentCache.delete(derivatives[0]);
		}
		return result;
	}
	delete(derivativeOption) {
		// If cache exists
		if (this.has(derivativeOption)) {
			this.keys = this.keys.filter((item) => !sameDerivativeOption(item, derivativeOption));
			return this.deleteByPath(this.cache, derivativeOption);
		}
		return void 0;
	}
}
let uuid$2 = 0;
/**
* Theme with algorithms to derive tokens from design tokens.
* Use `createTheme` first which will help to manage the theme instance cache.
*/
class Theme {
	derivatives;
	id;
	constructor(derivatives) {
		this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
		this.id = uuid$2;
		uuid$2 += 1;
	}
	getDerivativeToken(token) {
		return this.derivatives.reduce((result, derivative) => derivative(token, result), void 0);
	}
}
const cacheThemes = new ThemeCache();
/**
* Same as new Theme, but will always return same one if `derivative` not changed.
*/
function createTheme(derivatives) {
	const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
	// Create new theme if not exist
	if (!cacheThemes.has(derivativeArr)) {
		cacheThemes.set(derivativeArr, new Theme(derivativeArr));
	}
	// Get theme from cache and return
	return cacheThemes.get(derivativeArr);
}
// Create a cache for memo concat
const resultCache = new WeakMap();
const RESULT_VALUE = {};
function memoResult(callback, deps) {
	let current = resultCache;
	for (let i = 0; i < 2; i += 1) {
		const dep = deps[i];
		if (!current.has(dep)) {
			current.set(dep, new WeakMap());
		}
		current = current.get(dep);
	}
	if (!current.has(RESULT_VALUE)) {
		current.set(RESULT_VALUE, callback());
	}
	return current.get(RESULT_VALUE);
}
// Create a cache here to avoid always loop generate
const flattenTokenCache = new WeakMap();
/**
* Flatten token to string, this will auto cache the result when token not change
*/
function flattenToken(token) {
	let str = flattenTokenCache.get(token) || "";
	if (!str) {
		Object.keys(token).forEach((key) => {
			const value = token[key];
			str += key;
			if (value instanceof Theme) {
				str += value.id;
			} else if (value && typeof value === "object") {
				str += flattenToken(value);
			} else {
				str += value;
			}
		});
		// https://github.com/ant-design/ant-design/issues/48386
		// Should hash the string to avoid style tag name too long
		str = murmur2(str);
		// Put in cache
		flattenTokenCache.set(token, str);
	}
	return str;
}
/**
* Convert derivative token to key string
*/
function token2key(token, salt) {
	return murmur2(`${salt}_${flattenToken(token)}`);
}
const isClientSide = canUseDom();
function unit$1(num) {
	if (typeof num === "number") {
		return `${num}px`;
	}
	return num;
}
function where(options) {
	const { a: hashCls, b: hashPriority = "low" } = options;
	if (!hashCls) {
		return "";
	}
	const hashSelector = `.${hashCls}`;
	return hashPriority === "low" ? `:where(${hashSelector})` : hashSelector;
}
const isNonNullable$1 = (val) => {
	return val !== void 0 && val !== null;
};
const token2CSSVar = (token, prefix = "") => {
	return `--${prefix ? `${prefix}-` : ""}${token}`.replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
};
const serializeCSSVar = (cssVars, hashId, options) => {
	const { a: hashCls, b: hashPriority = "low" } = options;
	if (!Object.keys(cssVars).length) {
		return "";
	}
	return `${where({
		a: hashCls,
		b: hashPriority
	})}.${hashId}${options.c ? `.${options.c}` : ""}{${Object.entries(cssVars).map(([key, value]) => `${key}:${value};`).join("")}}`;
};
const transformToken = (token, themeKey, config) => {
	const { a: hashCls, b: hashPriority = "low", c: prefix, d: unitless, e: ignore, f: preserve } = config;
	const cssVars = {};
	const result = {};
	Object.entries(token).forEach(([key, value]) => {
		if (preserve?.[key]) {
			result[key] = value;
		} else if ((typeof value === "string" || typeof value === "number") && !ignore?.[key]) {
			const cssVar = token2CSSVar(key, prefix);
			cssVars[cssVar] = typeof value === "number" && !unitless?.[key] ? `${value}px` : String(value);
			result[key] = `var(${cssVar})`;
		}
	});
	return [result, serializeCSSVar(cssVars, themeKey, {
		c: config.f,
		a: hashCls,
		b: hashPriority
	})];
};
const effectMap = new Map();
function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
	const { cache: globalCache } = reactExports.useContext(StyleContext);
	const fullPath = [prefix, ...keyPath];
	const fullPathStr = pathKey(fullPath);
	const buildCache = (updater) => {
		globalCache.opUpdate(fullPathStr, (prevCache) => {
			const [times = 0, cache] = prevCache || [void 0, void 0];
			// HMR should always ignore cache since developer may change it
			let tmpCache = cache;
			const mergedCache = tmpCache || cacheFn();
			const data = [times, mergedCache];
			// Call updater if need additional logic
			return updater ? updater(data) : data;
		});
	};
	// Create cache
	reactExports.useMemo(
		() => {
			buildCache();
		},
		[fullPathStr]
		/* eslint-enable */
	);
	let cacheEntity = globalCache.opGet(fullPathStr);
	const cacheContent = cacheEntity[1];
	// Remove if no need anymore
	reactExports.useInsertionEffect(() => {
		buildCache(([times, cache]) => [times + 1, cache]);
		if (!effectMap.has(fullPathStr)) {
			onCacheEffect(cacheContent);
			effectMap.set(fullPathStr, true);
			//  batch render  effect
			Promise.resolve().then(() => {
				effectMap.delete(fullPathStr);
			});
		}
		return () => {
			globalCache.opUpdate(fullPathStr, (prevCache) => {
				const [times = 0, cache] = prevCache || [];
				const nextCount = times - 1;
				if (nextCount === 0) {
					onCacheRemove(cache);
					effectMap.delete(fullPathStr);
					return null;
				}
				return [times - 1, cache];
			});
		};
	}, [fullPathStr]);
	return cacheContent;
}
const EMPTY_OVERRIDE = {};
const tokenKeys = new Map();
function recordCleanToken(tokenKey) {
	tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
function removeStyleTags(key, instanceId) {
	if (typeof document !== "undefined") {
		const styles = document.querySelectorAll(`style[${ATTR_TOKEN}="${key}"]`);
		styles.forEach((style) => {
			if (style[CSS_IN_JS_INSTANCE] === instanceId) {
				style.parentNode?.removeChild(style);
			}
		});
	}
}
// Remove will check current keys first
function cleanTokenStyle(tokenKey, instanceId) {
	tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
	const cleanableKeyList = new Set();
	tokenKeys.forEach((value, key) => {
		if (value <= 0) cleanableKeyList.add(key);
	});
	// Should keep tokens under threshold for not to insert style too often
	if (tokenKeys.size - cleanableKeyList.size > -1) {
		cleanableKeyList.forEach((key) => {
			removeStyleTags(key, instanceId);
			tokenKeys.delete(key);
		});
	}
}
/**
* Cache theme derivative token as global shared one
* @param theme Theme entity
* @param tokens List of tokens, used for cache. Please do not dynamic generate object directly
* @param option Additional config
* @returns Call Theme.getDerivativeToken(tokenObject) to get token
*/
function useCacheToken(theme, tokens, option) {
	const { cache: { instanceId }, container, hashPriority } = reactExports.useContext(StyleContext);
	const { a: salt, b: override = EMPTY_OVERRIDE, c: compute, d: cssVar } = option;
	// Basic - We do basic cache here
	const mergedToken = memoResult(() => Object.assign({}, ...tokens), tokens);
	const tokenStr = flattenToken(mergedToken);
	const overrideTokenStr = flattenToken(override);
	const cssVarStr = flattenToken(cssVar);
	const cachedToken = useGlobalCache("token", [
		salt,
		theme.id,
		tokenStr,
		overrideTokenStr,
		cssVarStr
	], () => {
		const mergedDerivativeToken = compute(mergedToken, override, theme);
		const actualToken = { ...mergedDerivativeToken };
		// Optimize for `useStyleRegister` performance
		const mergedSalt = `${salt}_${cssVar.prefix}`;
		const hashId = murmur2(mergedSalt);
		const hashCls = `${"css"}-${hashId}`;
		actualToken._tokenKey = token2key(actualToken, mergedSalt);
		// Replace token value with css variables
		const [tokenWithCssVar, cssVarsStr] = transformToken(mergedDerivativeToken, cssVar.key, {
			c: cssVar.prefix,
			e: cssVar.ignore,
			d: cssVar.unitless,
			f: cssVar.preserve,
			b: hashPriority,
			a: cssVar.hashed ? hashCls : void 0
		});
		tokenWithCssVar._hashId = hashId;
		recordCleanToken(cssVar.key);
		return [
			tokenWithCssVar,
			hashCls,
			actualToken,
			cssVarsStr,
			cssVar.key
		];
	}, ([, , , , themeKey]) => {
		// Remove token will remove all related style
		cleanTokenStyle(themeKey, instanceId);
	}, ([, , , cssVarsStr, themeKey]) => {
		if (!cssVarsStr) {
			return;
		}
		const style = updateCSS(cssVarsStr, murmur2(`css-var-${themeKey}`), {
			mark: ATTR_MARK,
			prepend: "queue",
			attachTo: container,
			priority: -999
		});
		style[CSS_IN_JS_INSTANCE] = instanceId;
		// Used for `useCacheToken` to remove on batch when token removed
		style.setAttribute(ATTR_TOKEN, themeKey);
	});
	return cachedToken;
}
var unitlessKeys = {
	animationIterationCount: 1,
	borderImageOutset: 1,
	borderImageSlice: 1,
	borderImageWidth: 1,
	boxFlex: 1,
	boxFlexGroup: 1,
	boxOrdinalGroup: 1,
	columnCount: 1,
	columns: 1,
	flex: 1,
	flexGrow: 1,
	flexPositive: 1,
	flexShrink: 1,
	flexNegative: 1,
	flexOrder: 1,
	gridRow: 1,
	gridRowEnd: 1,
	gridRowSpan: 1,
	gridRowStart: 1,
	gridColumn: 1,
	gridColumnEnd: 1,
	gridColumnSpan: 1,
	gridColumnStart: 1,
	msGridRow: 1,
	msGridRowSpan: 1,
	msGridColumn: 1,
	msGridColumnSpan: 1,
	fontWeight: 1,
	lineHeight: 1,
	opacity: 1,
	order: 1,
	orphans: 1,
	tabSize: 1,
	widows: 1,
	zIndex: 1,
	zoom: 1,
	WebkitLineClamp: 1,
	fillOpacity: 1,
	floodOpacity: 1,
	stopOpacity: 1,
	strokeDasharray: 1,
	strokeDashoffset: 1,
	strokeMiterlimit: 1,
	strokeOpacity: 1,
	strokeWidth: 1
};
var unitless$1 = unitlessKeys;
/**
* @param {number}
* @return {number}
*/
var abs = Math.abs;
/**
* @param {number}
* @return {string}
*/
var from = String.fromCharCode;
/**
* @param {object}
* @return {object}
*/
var assign = Object.assign;
/**
* @param {string} value
* @param {number} length
* @return {number}
*/
function hash(value, length) {
	return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
/**
* @param {string} value
* @return {string}
*/
function trim(value) {
	return value.trim();
}
/**
* @param {string} value
* @param {RegExp} pattern
* @return {string?}
*/
function match$1(value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value;
}
/**
* @param {string} value
* @param {(string|RegExp)} pattern
* @param {string} replacement
* @return {string}
*/
function replace(value, pattern, replacement) {
	return value.replace(pattern, replacement);
}
/**
* @param {string} value
* @param {string} search
* @param {number} position
* @return {number}
*/
function indexof(value, search, position) {
	return value.indexOf(search, position);
}
/**
* @param {string} value
* @param {number} index
* @return {number}
*/
function charat(value, index) {
	return value.charCodeAt(index) | 0;
}
/**
* @param {string} value
* @param {number} begin
* @param {number} end
* @return {string}
*/
function substr(value, begin, end) {
	return value.slice(begin, end);
}
/**
* @param {string} value
* @return {number}
*/
function strlen(value) {
	return value.length;
}
/**
* @param {any[]} value
* @return {number}
*/
function sizeof(value) {
	return value.length;
}
/**
* @param {any} value
* @param {any[]} array
* @return {any}
*/
function append(value, array) {
	return array.push(value), value;
}
/**
* @param {string[]} array
* @param {function} callback
* @return {string}
*/
function combine(array, callback) {
	return array.map(callback).join("");
}
/**
* @param {string[]} array
* @param {RegExp} pattern
* @return {string[]}
*/
function filter(array, pattern) {
	return array.filter(function(value) {
		return !match$1(value, pattern);
	});
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
/**
* @param {string} value
* @param {object | null} root
* @param {object | null} parent
* @param {string} type
* @param {string[] | string} props
* @param {object[] | string} children
* @param {object[]} siblings
* @param {number} length
*/
function node(value, root, parent, type, props, children, length, siblings) {
	return {
		value,
		root,
		parent,
		type,
		props,
		children,
		line,
		column,
		length,
		return: "",
		siblings
	};
}
/**
* @param {object} root
* @param {object} props
* @return {object}
*/
function copy(root, props) {
	return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
/**
* @param {object} root
*/
function lift(root) {
	while (root.root) root = copy(root.root, { children: [root] });
	append(root, root.siblings);
}
/**
* @return {number}
*/
function char() {
	return character;
}
/**
* @return {number}
*/
function prev() {
	character = position > 0 ? charat(characters, --position) : 0;
	if (column--, character === 10) column = 1, line--;
	return character;
}
/**
* @return {number}
*/
function next() {
	character = position < length ? charat(characters, position++) : 0;
	if (column++, character === 10) column = 1, line++;
	return character;
}
/**
* @return {number}
*/
function peek() {
	return charat(characters, position);
}
/**
* @return {number}
*/
function caret() {
	return position;
}
/**
* @param {number} begin
* @param {number} end
* @return {string}
*/
function slice(begin, end) {
	return substr(characters, begin, end);
}
/**
* @param {number} type
* @return {number}
*/
function token(type) {
	switch (type) {
		case 0:
		case 9:
		case 10:
		case 13:
		case 32: return 5;
		case 33:
		case 43:
		case 44:
		case 47:
		case 62:
		case 64:
		case 126:
		case 59:
		case 123:
		case 125: return 4;
		case 58: return 3;
		case 34:
		case 39:
		case 40:
		case 91: return 2;
		case 41:
		case 93: return 1;
	}
	return 0;
}
/**
* @param {string} value
* @return {any[]}
*/
function alloc(value) {
	return line = column = 1, length = strlen(characters = value), position = 0, [];
}
/**
* @param {any} value
* @return {any}
*/
function dealloc(value) {
	return characters = "", value;
}
/**
* @param {number} type
* @return {string}
*/
function delimit(type) {
	return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
/**
* @param {number} type
* @return {string}
*/
function whitespace$2(type) {
	while (character = peek()) if (character < 33) next();
	else break;
	return token(type) > 2 || token(character) > 3 ? "" : " ";
}
/**
* @param {number} index
* @param {number} count
* @return {string}
*/
function escaping(index, count) {
	while (--count && next())
 // not 0-9 A-F a-f
	if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
/**
* @param {number} type
* @return {number}
*/
function delimiter(type) {
	while (next()) switch (character) {
		case type: return position;
		case 34:
		case 39:
			if (type !== 34 && type !== 39) delimiter(character);
			break;
		case 40:
			if (type === 41) delimiter(type);
			break;
		case 92:
			next();
			break;
	}
	return position;
}
/**
* @param {number} type
* @param {number} index
* @return {number}
*/
function commenter(type, index) {
	while (next())
 // //
	if (type + character === 57) break;
	else if (type + character === 84 && peek() === 47) break;
	return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
/**
* @param {number} index
* @return {string}
*/
function identifier(index) {
	while (!token(peek())) next();
	return slice(index, position);
}
/**
* @param {string} value
* @return {object[]}
*/
function compile(value) {
	return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
/**
* @param {string} value
* @param {object} root
* @param {object?} parent
* @param {string[]} rule
* @param {string[]} rules
* @param {string[]} rulesets
* @param {number[]} pseudo
* @param {number[]} points
* @param {string[]} declarations
* @return {object}
*/
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0;
	var offset = 0;
	var length = pseudo;
	var atrule = 0;
	var property = 0;
	var previous = 0;
	var variable = 1;
	var scanning = 1;
	var ampersand = 1;
	var character = 0;
	var type = "";
	var props = rules;
	var children = rulesets;
	var reference = rule;
	var characters = "";
	while (scanning) switch (previous = character, character = next()) {
		case 40: if (previous != 108 && charat(characters, length - 1) == 58) {
			if (indexof(characters += replace(delimit(character), "&", "&\f"), "&\f", abs(index ? points[index - 1] : 0)) != -1) ampersand = -1;
			break;
		}
		case 34:
		case 39:
		case 91:
			characters += delimit(character);
			break;
		case 9:
		case 10:
		case 13:
		case 32:
			characters += whitespace$2(previous);
			break;
		case 92:
			characters += escaping(caret() - 1, 7);
			continue;
		case 47:
			switch (peek()) {
				case 42:
				case 47:
					append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
					if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters) && substr(characters, -1, void 0) !== " ") characters += " ";
					break;
				default: characters += "/";
			}
			break;
		case 123 * variable: points[index++] = strlen(characters) * ampersand;
		case 125 * variable:
		case 59:
		case 0:
			switch (character) {
				case 0:
				case 125: scanning = 0;
				case 59 + offset:
					if (ampersand == -1) characters = replace(characters, /\f/g, "");
					if (property > 0 && (strlen(characters) - length || variable === 0 && previous === 47)) append(property > 32 ? declaration(characters + ";", rule, parent, length - 1, declarations) : declaration(replace(characters, " ", "") + ";", rule, parent, length - 2, declarations), declarations);
					break;
				case 59: characters += ";";
				default:
					append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length, rulesets), rulesets);
					if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);
					else {
						switch (atrule) {
							case 99: if (charat(characters, 3) === 110) break;
							case 108: if (charat(characters, 2) === 97) break;
							default: offset = 0;
							case 100:
							case 109:
							case 115:
						}
						if (offset) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, 0, rules, props = [], length, children), children), rules, children, length, points, rule ? props : children);
						else parse(characters, reference, reference, reference, [""], children, 0, points, children);
					}
			}
			index = (offset = property = 0, 0), variable = ampersand = 1, type = characters = "", length = pseudo;
			break;
		case 58: length = 1 + strlen(characters), property = previous;
		default:
			if (variable < 1) {
				if (character == 123) --variable;
				else if (character == 125 && variable++ == 0 && prev() == 125) continue;
			}
			switch (characters += from(character), character * variable) {
				case 38:
					ampersand = offset > 0 ? 1 : (characters += "\f", -1);
					break;
				case 44:
					points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
					break;
				case 64:
					// -
					if (peek() === 45) characters += delimit(next());
					atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
					break;
				case 45: if (previous === 45 && strlen(characters) == 2) variable = 0;
			}
	}
	return rulesets;
}
/**
* @param {string} value
* @param {object} root
* @param {object?} parent
* @param {number} index
* @param {number} offset
* @param {string[]} rules
* @param {number[]} points
* @param {string} type
* @param {string[]} props
* @param {string[]} children
* @param {number} length
* @param {object[]} siblings
* @return {object}
*/
function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length, siblings) {
	var post = offset - 1;
	var rule = offset === 0 ? rules : [""];
	var size = sizeof(rule);
	for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
	return node(value, root, parent, offset === 0 ? "rule" : type, props, children, length, siblings);
}
/**
* @param {number} value
* @param {object} root
* @param {object?} parent
* @param {object[]} siblings
* @return {object}
*/
function comment(value, root, parent, siblings) {
	return node(value, root, parent, "comm", from(char()), substr(value, 2, -2), 0, siblings);
}
/**
* @param {string} value
* @param {object} root
* @param {object?} parent
* @param {number} length
* @param {object[]} siblings
* @return {object}
*/
function declaration(value, root, parent, length, siblings) {
	return node(value, root, parent, "decl", substr(value, 0, length), substr(value, length + 1, -1), length, siblings);
}
/**
* @param {string} value
* @param {number} length
* @param {object[]} children
* @return {string}
*/
function prefix(value, length, children) {
	switch (hash(value, length)) {
		case 5103: return "-webkit-" + "print-" + value + value;
		case 5737:
		case 4201:
		case 3177:
		case 3433:
		case 1641:
		case 4457:
		case 2921:
		case 5572:
		case 6356:
		case 5844:
		case 3191:
		case 6645:
		case 3005:
		case 4215:
		case 6389:
		case 5109:
		case 5365:
		case 5621:
		case 3829:
		case 6391:
		case 5879:
		case 5623:
		case 6135:
		case 4599: return "-webkit-" + value + value;
		case 4855: return "-webkit-" + value.replace("add", "source-over").replace("substract", "source-out").replace("intersect", "source-in").replace("exclude", "xor") + value;
		case 4789: return "-moz-" + value + value;
		case 5349:
		case 4246:
		case 4810:
		case 6968:
		case 2756: return "-webkit-" + value + "-moz-" + value + "-ms-" + value + value;
		case 5936: switch (charat(value, length + 11)) {
			case 114: return "-webkit-" + value + "-ms-" + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
			case 108: return "-webkit-" + value + "-ms-" + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
			case 45: return "-webkit-" + value + "-ms-" + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
		}
		case 6828:
		case 4268:
		case 2903: return "-webkit-" + value + "-ms-" + value + value;
		case 6165: return "-webkit-" + value + "-ms-" + "flex-" + value + value;
		case 5187: return "-webkit-" + value + replace(value, /(\w+).+(:[^]+)/, "-webkit-" + "box-$1$2" + "-ms-" + "flex-$1$2") + value;
		case 5443: return "-webkit-" + value + "-ms-" + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match$1(value, /flex-|baseline/) ? "-ms-" + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
		case 4675: return "-webkit-" + value + "-ms-" + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
		case 5548: return "-webkit-" + value + "-ms-" + replace(value, "shrink", "negative") + value;
		case 5292: return "-webkit-" + value + "-ms-" + replace(value, "basis", "preferred-size") + value;
		case 6060: return "-webkit-box-" + replace(value, "-grow", "") + "-webkit-" + value + "-ms-" + replace(value, "grow", "positive") + value;
		case 4554: return "-webkit-" + replace(value, /([^-])(transform)/g, "$1-webkit-$2") + value;
		case 6187: return replace(replace(replace(value, /(zoom-|grab)/, "-webkit-$1"), /(image-set)/, "-webkit-$1"), value, "") + value;
		case 5495:
		case 3959: return replace(value, /(image-set\([^]*)/, "-webkit-$1" + "$`$1");
		case 4968: return replace(replace(value, /(.+:)(flex-)?(.*)/, "-webkit-" + "box-pack:$3" + "-ms-" + "flex-pack:$3"), /space-between/, "justify") + "-webkit-" + value + value;
		case 4200:
			if (!match$1(value, /flex-|baseline/)) return "-ms-" + "grid-column-align" + substr(value, length) + value;
			break;
		case 2592:
		case 3360: return "-ms-" + replace(value, "template-", "") + value;
		case 4384:
		case 3616:
			if (children && children.some(function(element, index) {
				return length = index, match$1(element.props, /grid-\w+-end/);
			})) {
				return ~indexof(value + (children = children[length].value), "span", 0) ? value : "-ms-" + replace(value, "-start", "") + value + "-ms-" + "grid-row-span:" + (~indexof(children, "span", 0) ? match$1(children, /\d+/) : +match$1(children, /\d+/) - +match$1(value, /\d+/)) + ";";
			}
			return "-ms-" + replace(value, "-start", "") + value;
		case 4896:
		case 4128: return children && children.some(function(element) {
			return match$1(element.props, /grid-\w+-start/);
		}) ? value : "-ms-" + replace(replace(value, "-end", "-span"), "span ", "") + value;
		case 4095:
		case 3583:
		case 4068:
		case 2532: return replace(value, /(.+)-inline(.+)/, "-webkit-$1$2") + value;
		case 8116:
		case 7059:
		case 5753:
		case 5535:
		case 5445:
		case 5701:
		case 4933:
		case 4677:
		case 5533:
		case 5789:
		case 5021:
		case 4765:
			// stretch, max-content, min-content, fill-available
			if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
				case 109:
 // -
				if (charat(value, length + 4) !== 45) break;
				case 102: return replace(value, /(.+:)(.+)-([^]+)/, "$1-webkit-" + "$2-$3" + "$1" + "-moz-" + (charat(value, length + 3) == 108 ? "$3" : "$2-$3")) + value;
				case 115: return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length, children) + value : value;
			}
			break;
		case 5152:
		case 5920: return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(__unused_0FCF, a, b, c, d, e, f) {
			return "-ms-" + a + ":" + b + f + (c ? "-ms-" + a + "-span:" + (d ? e : +e - +b) + f : "") + value;
		});
		case 4949:
			// stick(y)?
			if (charat(value, length + 6) === 121) return replace(value, ":", ":-webkit-") + value;
			break;
		case 6444:
			switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
				case 120: return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1-webkit-" + (charat(value, 14) === 45 ? "inline-" : "") + "box$3" + "$1" + "-webkit-" + "$2$3" + "$1" + "-ms-" + "$2box$3") + value;
				case 100: return replace(value, ":", ":-ms-") + value;
			}
			break;
		case 5719:
		case 2647:
		case 2135:
		case 3927:
		case 2391: return replace(value, "scroll-", "scroll-snap-") + value;
	}
	return value;
}
/**
* @param {object[]} children
* @param {function} callback
* @return {string}
*/
function serialize(children, callback) {
	var output = "";
	for (var i = 0; i < children.length; i++) output += callback(children[i], i, children, callback) || "";
	return output;
}
/**
* @param {object} element
* @param {number} index
* @param {object[]} children
* @param {function} callback
* @return {string}
*/
function stringify$1(element, __unused_D143, children, callback) {
	switch (element.type) {
		case "@layer": if (element.children.length) break;
		case "@import":
		case "@namespace":
		case "decl": return element.return = element.return || element.value;
		case "comm": return "";
		case "@keyframes": return element.return = element.value + "{" + serialize(element.children, callback) + "}";
		case "rule": if (!strlen(element.value = element.props.join(","))) return "";
	}
	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
/**
* @param {function[]} collection
* @return {function}
*/
function middleware(collection) {
	return function(element, index, children, callback) {
		var output = "";
		for (var i = 0; i < 2; i++) output += collection[i](element, index, children, callback) || "";
		return output;
	};
}
/**
* @param {object} element
* @param {number} index
* @param {object[]} children
* @param {function} callback
*/
function prefixer(element, __unused_D143_0, children, callback) {
	if (element.length > -1) {
		if (!element.return) switch (element.type) {
			case "decl":
				element.return = prefix(element.value, element.length, children);
				return;
			case "@keyframes": return serialize([copy(element, { value: replace(element.value, "@", "@-webkit-") })], callback);
			case "rule": if (element.length) return combine(children = element.props, function(value) {
				switch (match$1(value, callback = /(::plac\w+|:read-\w+)/)) {
					case ":read-only":
					case ":read-write":
						lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":-moz-$1")] }));
						lift(copy(element, { props: [value] }));
						assign(element, { props: filter(children, callback) });
						break;
					case "::placeholder":
						lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":-webkit-" + "input-$1")] }));
						lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":-moz-$1")] }));
						lift(copy(element, { props: [replace(value, /:(plac\w+)/, "-ms-input-$1")] }));
						lift(copy(element, { props: [value] }));
						assign(element, { props: filter(children, callback) });
						break;
				}
				return "";
			});
		}
	}
}
const ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
/**
* This marks style from the css file.
* Which means not exist in `<style />` tag.
*/
const CSS_FILE_STYLE = "_FILE_STYLE__";
let cachePathMap;
let fromCSSFile = true;
function prepare() {
	if (!cachePathMap) {
		cachePathMap = {};
		if (canUseDom()) {
			const div = document.createElement("div");
			div.className = ATTR_CACHE_MAP;
			div.style.position = "fixed";
			div.style.visibility = "hidden";
			div.style.top = "-9999px";
			document.body.appendChild(div);
			let content = getComputedStyle(div).content || "";
			content = content.replace(/^"/, "").replace(/"$/, "");
			// Fill data
			content.split(";").forEach((item) => {
				const [path, hash] = item.split(":");
				cachePathMap[path] = hash;
			});
			// Remove inline record style
			const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
			if (inlineMapStyle) {
				fromCSSFile = false;
				inlineMapStyle.parentNode?.removeChild(inlineMapStyle);
			}
			document.body.removeChild(div);
		}
	}
}
function existPath(path) {
	prepare();
	return !!cachePathMap[path];
}
function getStyleAndHash(path) {
	const hash = cachePathMap[path];
	let styleStr = null;
	if (hash && canUseDom()) {
		if (fromCSSFile) {
			styleStr = CSS_FILE_STYLE;
		} else {
			const style = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path]}"]`);
			if (style) {
				styleStr = style.innerHTML;
			} else {
				// Clean up since not exist anymore
				delete cachePathMap[path];
			}
		}
	}
	return [styleStr, hash];
}
const MULTI_VALUE = "_multi_value_";
// ============================================================================
// ==                                 Parser                                 ==
// ============================================================================
// Preprocessor style content to browser support one
function normalizeStyle(styleStr, autoPrefix) {
	const serialized = autoPrefix ? serialize(compile(styleStr), middleware([prefixer, stringify$1])) : serialize(compile(styleStr), stringify$1);
	return serialized.replace(/\{%%%\:[^;];}/g, ";");
}
function isCompoundCSSProperty(value) {
	return typeof value === "object" && value && ("_skip_check_" in value || MULTI_VALUE in value);
}
//  hash 
function injectSelectorHash(key, hashId, hashPriority = "high") {
	if (!hashId) {
		return key;
	}
	const hashSelector = where({
		a: hashId,
		b: hashPriority
	});
	//  hashId
	const keys = key.split(",").map((k) => {
		const fullPath = k.trim().split(/\s+/);
		//  Selector  HTML Element
		let firstPath = fullPath[0] || "";
		const htmlElement = firstPath.match(/^\w+/)?.[0] || "";
		firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;
		return [firstPath, ...fullPath.slice(1)].join(" ");
	});
	return keys.join(",");
}
// Parse CSSObject to style content
const parseStyle = (interpolation, config = {}, { root, injectHash, parentSelectors } = {
	root: true,
	parentSelectors: []
}) => {
	const { hashId, layer, hashPriority, transformers = [] } = config;
	let styleStr = "";
	let effectStyle = {};
	function parseKeyframes(keyframes) {
		const animationName = keyframes.getName(hashId);
		if (!effectStyle[animationName]) {
			const [parsedStr] = parseStyle(keyframes.style, config, {
				root: false,
				parentSelectors
			});
			effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;
		}
	}
	function flattenList(list, fullList = []) {
		list.forEach((item) => {
			if (Array.isArray(item)) {
				flattenList(item, fullList);
			} else if (item) {
				fullList.push(item);
			}
		});
		return fullList;
	}
	const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
	flattenStyleList.forEach((originStyle) => {
		// Only root level can use raw string
		const style = typeof originStyle === "string" && !root ? {} : originStyle;
		if (typeof style === "string") {
			styleStr += `${style}
`;
		} else if (style._keyframe) {
			// Keyframe
			parseKeyframes(style);
		} else {
			const mergedStyle = transformers.reduce((prev, trans) => trans?.visit?.(prev) || prev, style);
			// Normal CSSObject
			Object.keys(mergedStyle).forEach((key) => {
				const value = mergedStyle[key];
				if (typeof value === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
					let subInjectHash = false;
					// 
					let mergedKey = key.trim();
					// Whether treat child as root. In most case it is false.
					let nextRoot = false;
					// 
					if ((root || injectHash) && hashId) {
						if (mergedKey.startsWith("@")) {
							//  hashId
							subInjectHash = true;
						} else if (mergedKey === "&") {
							//  root selector  &
							mergedKey = injectSelectorHash("", hashId, hashPriority);
						} else {
							//  hashId
							mergedKey = injectSelectorHash(key, hashId, hashPriority);
						}
					} else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
						// In case of `{ '&': { a: { color: 'red' } } }` or `{ '': { a: { color: 'red' } } }` without hashId,
						// we will get `&{a:{color:red;}}` or `{a:{color:red;}}` string for stylis to compile.
						// But it does not conform to stylis syntax,
						// and finally we will get `{color:red;}` as css, which is wrong.
						// So we need to remove key in root, and treat child `{ a: { color: 'red' } }` as root.
						mergedKey = "";
						nextRoot = true;
					}
					const [parsedStr, childEffectStyle] = parseStyle(value, config, {
						root: nextRoot,
						injectHash: subInjectHash,
						parentSelectors: [...parentSelectors, mergedKey]
					});
					effectStyle = {
						...effectStyle,
						...childEffectStyle
					};
					styleStr += `${mergedKey}${parsedStr}`;
				} else {
					function appendStyle(cssKey, cssValue) {
						// 
						const styleName = cssKey.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
						// Auto suffix with px
						let formatValue = cssValue;
						if (!unitless$1[cssKey] && typeof formatValue === "number" && formatValue !== 0) {
							formatValue = `${formatValue}px`;
						}
						// handle animationName & Keyframe value
						if (cssKey === "animationName" && cssValue?._keyframe) {
							parseKeyframes(cssValue);
							formatValue = cssValue.getName(hashId);
						}
						styleStr += `${styleName}:${formatValue};`;
					}
					const actualValue = value?.value ?? value;
					if (typeof value === "object" && value?.[MULTI_VALUE] && Array.isArray(actualValue)) {
						actualValue.forEach((item) => {
							appendStyle(key, item);
						});
					} else {
						if (isNonNullable$1(actualValue)) {
							appendStyle(key, actualValue);
						}
					}
				}
			});
		}
	});
	if (!root) {
		styleStr = `{${styleStr}}`;
	} else if (layer) {
		// fixme: https://github.com/thysultan/stylis/pull/339
		if (styleStr) {
			styleStr = `@layer ${layer.name} {${styleStr}}`;
		}
		if (layer.dependencies) {
			effectStyle[`@layer ${layer.name}`] = layer.dependencies.map((deps) => `@layer ${deps}, ${layer.name};`).join("\n");
		}
	}
	return [styleStr, effectStyle];
};
// ============================================================================
// ==                                Register                                ==
// ============================================================================
function uniqueHash(path, styleStr) {
	return murmur2(`${path.join("%")}${styleStr}`);
}
/**
* Register a style to the global style sheet.
*/
function useStyleRegister(info, styleFn) {
	const { path, hashId, layer, nonce, clientOnly, order = 0 } = info;
	const { hashPriority, container, transformers, linters, cache, layer: enableLayer, autoPrefix } = reactExports.useContext(StyleContext);
	const fullPath = [hashId || ""];
	if (enableLayer) {
		fullPath.push("layer");
	}
	fullPath.push(...path);
	// Check if need insert style
	let isMergedClientSide = isClientSide;
	useGlobalCache(
		"style",
		fullPath,
		// Create cache if needed
		() => {
			const cachePath = fullPath.join("|");
			// Get style from SSR inline style directly
			if (existPath(cachePath)) {
				const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
				if (inlineCacheStyleStr) {
					return [
						inlineCacheStyleStr,
						styleHash,
						{},
						clientOnly,
						order
					];
				}
			}
			// Generate style
			const styleObj = styleFn();
			const [parsedStyle, effectStyle] = parseStyle(styleObj, {
				hashId,
				hashPriority,
				layer: enableLayer ? layer : void 0,
				path: path.join("-"),
				transformers,
				linters
			});
			const styleStr = normalizeStyle(parsedStyle, autoPrefix || false);
			const styleId = uniqueHash(fullPath, styleStr);
			return [
				styleStr,
				styleId,
				effectStyle,
				clientOnly,
				order
			];
		},
		// Remove cache if no need
		() => 0,
		// Effect: Inject style here
		(cacheValue) => {
			const [styleStr, styleId, effectStyle, , priority] = cacheValue;
			if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
				const mergedCSSConfig = {
					mark: ATTR_MARK,
					prepend: enableLayer ? false : "queue",
					attachTo: container,
					priority
				};
				const nonceStr = typeof nonce === "function" ? nonce() : nonce;
				if (nonceStr) {
					mergedCSSConfig.csp = { nonce: nonceStr };
				}
				// ================= Split Effect Style =================
				// We will split effectStyle here since @layer should be at the top level
				const effectLayerKeys = [];
				const effectRestKeys = [];
				Object.keys(effectStyle).forEach((key) => {
					if (key.startsWith("@layer")) {
						effectLayerKeys.push(key);
					} else {
						effectRestKeys.push(key);
					}
				});
				// ================= Inject Layer Style =================
				// Inject layer style
				effectLayerKeys.forEach((effectKey) => {
					updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_layer-${effectKey}`, {
						...mergedCSSConfig,
						prepend: true
					});
				});
				// ==================== Inject Style ====================
				// Inject style
				const style = updateCSS(styleStr, styleId, mergedCSSConfig);
				style[CSS_IN_JS_INSTANCE] = cache.instanceId;
				// ================ Inject Effect Style =================
				// Inject client side effect style
				effectRestKeys.forEach((effectKey) => {
					updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_effect-${effectKey}`, mergedCSSConfig);
				});
			}
		}
	);
}
const useCSSVarRegister = (config, fn) => {
	const { a: key, b: prefix, c: unitless, d: ignore, e: token, f: scope = "" } = config;
	const { cache: { instanceId }, container, hashPriority } = reactExports.useContext(StyleContext);
	const { _tokenKey: tokenKey } = token;
	const stylePath = [
		...config.g,
		key,
		scope,
		tokenKey
	];
	const __unused_403A = useGlobalCache("cssVar", stylePath, () => {
		const originToken = fn();
		const [mergedToken, cssVarsStr] = transformToken(originToken, key, {
			c: prefix,
			d: unitless,
			e: ignore,
			f: scope,
			b: hashPriority,
			a: void 0
		});
		const styleId = uniqueHash(stylePath, cssVarsStr);
		return [
			mergedToken,
			cssVarsStr,
			styleId,
			key
		];
	}, ([, , styleId]) => {
		if (isClientSide) {
			removeCSS(styleId, {
				mark: ATTR_MARK,
				attachTo: container
			});
		}
	}, ([, cssVarsStr, styleId]) => {
		if (!cssVarsStr) {
			return;
		}
		const style = updateCSS(cssVarsStr, styleId, {
			mark: ATTR_MARK,
			prepend: "queue",
			attachTo: container,
			priority: -999
		});
		style[CSS_IN_JS_INSTANCE] = instanceId;
		// Used for `useCacheToken` to remove on batch when token removed
		style.setAttribute(ATTR_TOKEN, key);
	});
	return;
};
class Keyframe {
	constructor(name, style) {
		this.name = name;
		this.style = style;
	}
	getName(hashId = "") {
		return hashId ? `${hashId}-${this.name}` : this.name;
	}
	_keyframe = true;
}
function _typeof$u(o) {
	"@babel/helpers - typeof";
	return _typeof$u = function(o) {
		return typeof o;
	}, _typeof$u(o);
}
function _arrayWithHoles$v(r) {
	if (Array.isArray(r)) return r;
}
function _iterableToArrayLimit$v(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _nonIterableRest$v() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray$v(r, e) {
	return _arrayWithHoles$v(r) || _iterableToArrayLimit$v(r, e) || _unsupportedIterableToArray$y(r, e) || _nonIterableRest$v();
}
function toPrimitive(t) {
	if ("object" != _typeof$u(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$u(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function toPropertyKey(t) {
	var i = toPrimitive(t);
	return "symbol" == _typeof$u(i) ? i : i + "";
}
function _defineProperty$s(e, r, t) {
	return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
		value: t,
		enumerable: true,
		configurable: true,
		writable: true
	}) : e[r] = t, e;
}
function ownKeys$i(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread2(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$i(Object(t), true).forEach(function(r) {
			_defineProperty$s(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _classCallCheck$1(a, n) {
	if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(e, r) {
	for (var t = 0; t < r.length; t++) {
		var o = r[t];
		o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
	}
}
function _createClass$1(e, r) {
	return r && _defineProperties$1(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
function _assertThisInitialized(e) {
	if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return e;
}
function _setPrototypeOf(t, e) {
	return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
		return t.__proto__ = e, t;
	}, _setPrototypeOf(t, e);
}
function _inherits(t, e) {
	if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
	t.prototype = Object.create(e && e.prototype, { constructor: {
		value: t,
		writable: true,
		configurable: true
	} }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
}
function _getPrototypeOf(t) {
	return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
		return t.__proto__ || Object.getPrototypeOf(t);
	}, _getPrototypeOf(t);
}
function _isNativeReflectConstruct() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch {}
	return (_isNativeReflectConstruct = function() {
		return !!t;
	})();
}
function _possibleConstructorReturn(t, e) {
	if (e && ("object" == _typeof$u(e) || "function" == typeof e)) return e;
	if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized(t);
}
function _createSuper(t) {
	var r = _isNativeReflectConstruct();
	return function() {
		var e, o = _getPrototypeOf(t);
		if (r) {
			var s = _getPrototypeOf(this).constructor;
			e = Reflect.construct(o, arguments, s);
		} else e = o.apply(this, arguments);
		return _possibleConstructorReturn(this, e);
	};
}
var AbstractCalculator = _createClass$1(function AbstractCalculator() {
	_classCallCheck$1(this, AbstractCalculator);
});
var AbstractCalculator$1 = AbstractCalculator;
var regexp$2 = new RegExp("CALC_UNIT", "g");
function unit(value) {
	if (typeof value === "number") {
		return "".concat(value).concat("CALC_UNIT");
	}
	return value;
}
var CSSCalculator = function(_AbstractCalculator) {
	_inherits(CSSCalculator, _AbstractCalculator);
	var _super = _createSuper(CSSCalculator);
	function CSSCalculator(num, unitlessCssVar) {
		var _this;
		_classCallCheck$1(this, CSSCalculator);
		_this = _super.call(this);
		_defineProperty$s(_assertThisInitialized(_this), "result", "");
		_defineProperty$s(_assertThisInitialized(_this), "unitlessCssVar", void 0);
		_defineProperty$s(_assertThisInitialized(_this), "lowPriority", void 0);
		var numType = _typeof$u(num);
		_this.unitlessCssVar = unitlessCssVar;
		if (num instanceof CSSCalculator) {
			_this.result = "(".concat(num.result, ")");
		} else if (numType === "number") {
			_this.result = unit(num);
		} else if (numType === "string") {
			_this.result = num;
		}
		return _this;
	}
	_createClass$1(CSSCalculator, [
		{
			key: "add",
			value: function(num) {
				if (num instanceof CSSCalculator) {
					this.result = "".concat(this.result, " + ").concat(num.getResult());
				} else if (typeof num === "number" || typeof num === "string") {
					this.result = "".concat(this.result, " + ").concat(unit(num));
				}
				this.lowPriority = true;
				return this;
			}
		},
		{
			key: "sub",
			value: function(num) {
				if (num instanceof CSSCalculator) {
					this.result = "".concat(this.result, " - ").concat(num.getResult());
				} else if (typeof num === "number" || typeof num === "string") {
					this.result = "".concat(this.result, " - ").concat(unit(num));
				}
				this.lowPriority = true;
				return this;
			}
		},
		{
			key: "mul",
			value: function(num) {
				if (this.lowPriority) {
					this.result = "(".concat(this.result, ")");
				}
				if (num instanceof CSSCalculator) {
					this.result = "".concat(this.result, " * ").concat(num.getResult(true));
				} else if (typeof num === "number" || typeof num === "string") {
					this.result = "".concat(this.result, " * ").concat(num);
				}
				this.lowPriority = false;
				return this;
			}
		},
		{
			key: "div",
			value: function(num) {
				if (this.lowPriority) {
					this.result = "(".concat(this.result, ")");
				}
				if (num instanceof CSSCalculator) {
					this.result = "".concat(this.result, " / ").concat(num.getResult(true));
				} else if (typeof num === "number" || typeof num === "string") {
					this.result = "".concat(this.result, " / ").concat(num);
				}
				this.lowPriority = false;
				return this;
			}
		},
		{
			key: "getResult",
			value: function(force) {
				return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
			}
		},
		{
			key: "equal",
			value: function(options) {
				var _this2 = this;
				var _ref = options || {}, cssUnit = _ref.unit;
				var mergedUnit = true;
				if (typeof cssUnit === "boolean") {
					mergedUnit = cssUnit;
				} else if (Array.from(this.unitlessCssVar).some(function(cssVar) {
					return _this2.result.includes(cssVar);
				})) {
					mergedUnit = false;
				}
				this.result = this.result.replace(regexp$2, mergedUnit ? "px" : "");
				if (typeof this.lowPriority !== "undefined") {
					return "calc(".concat(this.result, ")");
				}
				return this.result;
			}
		}
	]);
	return CSSCalculator;
}(AbstractCalculator$1);
var __unused_76FD = function(_AbstractCalculator) {
	_inherits(NumCalculator, _AbstractCalculator);
	var _super = _createSuper(NumCalculator);
	function NumCalculator(num) {
		var _this;
		_classCallCheck$1(this, NumCalculator);
		_this = _super.call(this);
		_defineProperty$s(_assertThisInitialized(_this), "result", 0);
		if (num instanceof NumCalculator) {
			_this.result = num.result;
		} else if (typeof num === "number") {
			_this.result = num;
		}
		return _this;
	}
	_createClass$1(NumCalculator, [
		{
			key: "add",
			value: function(num) {
				if (num instanceof NumCalculator) {
					this.result += num.result;
				} else if (typeof num === "number") {
					this.result += num;
				}
				return this;
			}
		},
		{
			key: "sub",
			value: function(num) {
				if (num instanceof NumCalculator) {
					this.result -= num.result;
				} else if (typeof num === "number") {
					this.result -= num;
				}
				return this;
			}
		},
		{
			key: "mul",
			value: function(num) {
				if (num instanceof NumCalculator) {
					this.result *= num.result;
				} else if (typeof num === "number") {
					this.result *= num;
				}
				return this;
			}
		},
		{
			key: "div",
			value: function(num) {
				if (num instanceof NumCalculator) {
					this.result /= num.result;
				} else if (typeof num === "number") {
					this.result /= num;
				}
				return this;
			}
		},
		{
			key: "equal",
			value: function() {
				return this.result;
			}
		}
	]);
	return;
}(AbstractCalculator$1);
var genCalc = function(__unused_F7FC, unitlessCssVar) {
	var Calculator = CSSCalculator;
	return function(num) {
		return new Calculator(num, unitlessCssVar);
	};
};
var genCalc$1 = genCalc;
var getCompVarPrefix = function(component, prefix) {
	return "".concat([prefix, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
};
var getCompVarPrefix$1 = getCompVarPrefix;
function getComponentToken(component, token, defaultToken, options) {
	var customToken = _objectSpread2({}, token[component]);
	if (options !== null && true && options.deprecatedTokens) {
		var deprecatedTokens = options.deprecatedTokens;
		deprecatedTokens.forEach(function(_ref) {
			var _ref2 = _slicedToArray$v(_ref, 2), oldTokenKey = _ref2[0], newTokenKey = _ref2[1];
			// Should wrap with `if` clause, or there will be `undefined` in object.
			if (customToken !== null && customToken !== void 0 && customToken[oldTokenKey] || customToken !== null && customToken !== void 0 && customToken[newTokenKey]) {
				var _customToken$newToken;
				(_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 || (customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey]);
			}
		});
	}
	var mergedToken = _objectSpread2(_objectSpread2({}, defaultToken), customToken);
	// Remove same value as global token to minimize size
	Object.keys(mergedToken).forEach(function(key) {
		if (mergedToken[key] === token[key]) {
			delete mergedToken[key];
		}
	});
	return mergedToken;
}
var enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
var recording = true;
/**
* This function will do as `Object.assign` in production. But will use Object.defineProperty:get to
* pass all value access in development. To support statistic field usage with alias token.
*/
function merge() {
	for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
		objs[_key] = arguments[_key];
	}
	/* istanbul ignore next */
	if (!enableStatistic) {
		return Object.assign.apply(0, [{}].concat(objs));
	}
	recording = false;
	var ret = {};
	objs.forEach(function(obj) {
		if (_typeof$u(obj) !== "object") {
			return;
		}
		var keys = Object.keys(obj);
		keys.forEach(function(key) {
			Object.defineProperty(ret, key, {
				configurable: true,
				enumerable: true,
				get: function() {
					return obj[key];
				}
			});
		});
	});
	recording = true;
	return ret;
}
/** @internal Internal Usage. Not use in your production. */
var statistic = {};
/* istanbul ignore next */
function noop() {}
/** Statistic token usage case. Should use `merge` function if you do not want spread record. */
var statisticToken = function(token) {
	var tokenKeys;
	var proxy = token;
	var flush = noop;
	if (enableStatistic && true) {
		tokenKeys = new Set();
		proxy = new Proxy(token, { get: function(obj, prop) {
			if (recording) {
				var _tokenKeys;
				(_tokenKeys = tokenKeys) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
			}
			return obj[prop];
		} });
		flush = function(componentName, componentToken) {
			var _statistic$componentN;
			statistic[componentName] = {
				global: Array.from(tokenKeys),
				component: _objectSpread2(_objectSpread2({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
			};
		};
	}
	return {
		a: proxy,
		b: flush
	};
};
var statisticToken$1 = statisticToken;
function getDefaultComponentToken(component, token, getDefaultToken) {
	if (typeof getDefaultToken === "function") {
		var _token$component;
		return getDefaultToken(merge(token, (_token$component = token[component]) !== null && _token$component !== void 0 ? _token$component : {}));
	}
	return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
}
function genMaxMin() {
	return {
		a: function() {
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			return "max(".concat(args.map(function(value) {
				return unit$1(value);
			}).join(","), ")");
		},
		b: function() {
			for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}
			return "min(".concat(args.map(function(value) {
				return unit$1(value);
			}).join(","), ")");
		}
	};
}
/**
* A helper class to map keys to values.
* It supports both primitive keys and object keys.
*/
var ArrayKeyMap = function() {
	function ArrayKeyMap() {
		_classCallCheck$1(this, ArrayKeyMap);
		_defineProperty$s(this, "map", new Map());
		// Use WeakMap to avoid memory leak
		_defineProperty$s(this, "objectIDMap", new WeakMap());
		_defineProperty$s(this, "nextID", 0);
		_defineProperty$s(this, "lastAccessBeat", new Map());
		// We will clean up the cache when reach the limit
		_defineProperty$s(this, "accessBeat", 0);
	}
	_createClass$1(ArrayKeyMap, [
		{
			key: "set",
			value: function(keys, value) {
				// New set will trigger clear
				this.clear();
				// Set logic
				var compositeKey = this.getCompositeKey(keys);
				this.map.set(compositeKey, value);
				this.lastAccessBeat.set(compositeKey, Date.now());
			}
		},
		{
			key: "get",
			value: function(keys) {
				var compositeKey = this.getCompositeKey(keys);
				var cache = this.map.get(compositeKey);
				this.lastAccessBeat.set(compositeKey, Date.now());
				this.accessBeat += 1;
				return cache;
			}
		},
		{
			key: "getCompositeKey",
			value: function(keys) {
				var _this = this;
				var ids = keys.map(function(key) {
					if (key && _typeof$u(key) === "object") {
						return "obj_".concat(_this.getObjectID(key));
					}
					return "".concat(_typeof$u(key), "_").concat(key);
				});
				return ids.join("|");
			}
		},
		{
			key: "getObjectID",
			value: function(obj) {
				if (this.objectIDMap.has(obj)) {
					return this.objectIDMap.get(obj);
				}
				var id = this.nextID;
				this.objectIDMap.set(obj, id);
				this.nextID += 1;
				return id;
			}
		},
		{
			key: "clear",
			value: function() {
				var _this2 = this;
				if (this.accessBeat > 1e4) {
					var now = Date.now();
					this.lastAccessBeat.forEach(function(beat, key) {
						if (now - beat > 6e5) {
							_this2.map.delete(key);
							_this2.lastAccessBeat.delete(key);
						}
					});
					this.accessBeat = 0;
				}
			}
		}
	]);
	return ArrayKeyMap;
}();
var uniqueMap = new ArrayKeyMap();
/**
* Like `useMemo`, but this hook result will be shared across all instances.
*/
function useUniqueMemo(memoFn, deps) {
	return React.useMemo(function() {
		var cachedValue = uniqueMap.get(deps);
		if (cachedValue) {
			return cachedValue;
		}
		var newValue = memoFn();
		uniqueMap.set(deps, newValue);
		return newValue;
	}, deps);
}
function genStyleUtils(config) {
	// Dependency inversion for preparing basic config.
	var _config$useCSP = config.a, useCSP = _config$useCSP, useToken = config.b, usePrefix = config.c, getResetStyles = config.d, getCommonStyle = config.e, getCompUnitless = config.f;
	function genStyleHooks(component, styleFn, getDefaultToken, options) {
		var componentName = Array.isArray(component) ? component[0] : component;
		function prefixToken(key) {
			return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
		}
		// Fill unitless
		var originUnitless = (options === null || options === void 0 ? void 0 : options.unitless) || {};
		var originCompUnitless = getCompUnitless();
		var compUnitless = _objectSpread2(_objectSpread2({}, originCompUnitless), {}, _defineProperty$s({}, prefixToken("zIndexPopup"), true));
		Object.keys(originUnitless).forEach(function(key) {
			compUnitless[prefixToken(key)] = originUnitless[key];
		});
		// Options
		var mergedOptions = _objectSpread2(_objectSpread2({}, options), {}, {
			unitless: compUnitless,
			prefixToken
		});
		// Hooks
		var useStyle = genComponentStyleHook(component, styleFn, getDefaultToken, mergedOptions);
		var useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
		return function(prefixCls) {
			var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
			var hashId = useStyle(prefixCls, rootCls);
			var cssVarCls = useCSSVar(rootCls);
			return [hashId, cssVarCls];
		};
	}
	function genCSSVarRegister(component, getDefaultToken, options) {
		var compUnitless = options.unitless, prefixToken = options.prefixToken, ignore = options.ignore;
		return function(rootCls) {
			var _useToken = useToken(), cssVar = _useToken.a, realToken = _useToken.b;
			useCSSVarRegister({
				g: [component],
				b: cssVar.prefix,
				a: cssVar.key,
				c: compUnitless,
				d: ignore,
				e: realToken,
				f: rootCls
			}, function() {
				var defaultToken = getDefaultComponentToken(component, realToken, getDefaultToken);
				var componentToken = getComponentToken(component, realToken, defaultToken, { deprecatedTokens: options === null || options === void 0 ? void 0 : options.deprecatedTokens });
				if (defaultToken) {
					Object.keys(defaultToken).forEach(function(key) {
						componentToken[prefixToken(key)] = componentToken[key];
						delete componentToken[key];
					});
				}
				return componentToken;
			});
			return cssVar === null || false ? void 0 : cssVar.key;
		};
	}
	function genComponentStyleHook(componentName, styleFn, getDefaultToken) {
		var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
		var cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
		var _cells = _slicedToArray$v(cells, 1), component = _cells[0];
		var concatComponent = cells.join("-");
		var mergedLayer = { name: "antd" };
		// Return new style hook
		return function(prefixCls) {
			var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
			var _useToken2 = useToken(), theme = _useToken2.c, realToken = _useToken2.b, hashId = _useToken2.d, token = _useToken2.e, cssVar = _useToken2.a, zeroRuntime = _useToken2.f;
			// Update of `disabledRuntimeStyle` would cause React hook error, so memoized it and never update.
			var memoizedZeroRuntime = reactExports.useMemo(function() {
				return zeroRuntime;
			}, []);
			if (memoizedZeroRuntime) {
				return hashId;
			}
			var _usePrefix = usePrefix(), rootPrefixCls = _usePrefix.a, iconPrefixCls = _usePrefix.b;
			var csp = useCSP();
			// Use unique memo to share the result across all instances
			var calc = useUniqueMemo(function() {
				var unitlessCssVar = new Set();
				Object.keys(options.unitless || {}).forEach(function(key) {
					// Some component proxy the AliasToken (e.g. Image) and some not (e.g. Modal)
					// We should both pass in `unitlessCssVar` to make sure the CSSVar can be unitless.
					unitlessCssVar.add(token2CSSVar(key, cssVar.prefix));
					unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix$1(component, cssVar.prefix)));
				});
				return genCalc$1(0, unitlessCssVar);
			}, [
				"css",
				component,
				cssVar === null || false ? void 0 : cssVar.prefix
			]);
			var _genMaxMin = genMaxMin(), max = _genMaxMin.a, min = _genMaxMin.b;
			// Shared config
			var sharedConfig = {
				theme,
				token,
				hashId,
				nonce: function() {
					return csp.nonce;
				},
				clientOnly: options.clientOnly,
				layer: mergedLayer,
				order: options.order || -999
			};
			// This if statement is safe, as it will only be used if the generator has the function. It's not dynamic.
			{
				{
					// Generate style for all need reset tags.
					useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
						clientOnly: false,
						path: ["Shared", rootPrefixCls]
					}), function() {
						return getResetStyles(token, { a: { a: iconPrefixCls } });
					});
				}
			}
			useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, { path: [
				concatComponent,
				prefixCls,
				iconPrefixCls
			] }), function() {
				if (options.injectStyle === false) {
					return [];
				}
				var _statisticToken = statisticToken$1(token), proxyToken = _statisticToken.a, flush = _statisticToken.b;
				var defaultComponentToken = getDefaultComponentToken(component, realToken, getDefaultToken);
				var componentCls = ".".concat(prefixCls);
				var componentToken = getComponentToken(component, realToken, defaultComponentToken, { deprecatedTokens: options.deprecatedTokens });
				if (defaultComponentToken && _typeof$u(defaultComponentToken) === "object") {
					Object.keys(defaultComponentToken).forEach(function(key) {
						defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix$1(component, cssVar.prefix)), ")");
					});
				}
				var mergedToken = merge(proxyToken, {
					componentCls,
					prefixCls,
					iconCls: ".".concat(iconPrefixCls),
					antCls: ".".concat(rootPrefixCls),
					calc,
					max,
					min
				}, defaultComponentToken);
				var styleInterpolation = styleFn(mergedToken, {
					hashId,
					prefixCls,
					rootPrefixCls,
					iconPrefixCls
				});
				flush(component, componentToken);
				var commonStyle = getCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont);
				return [options.resetStyle === false ? null : commonStyle, styleInterpolation];
			});
			return hashId;
		};
	}
	function genSubStyleComponent(componentName, styleFn, getDefaultToken) {
		var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
		var useStyle = genComponentStyleHook(componentName, styleFn, getDefaultToken, _objectSpread2({
			resetStyle: false,
			order: -998
		}, options));
		var StyledComponent = function(_ref) {
			var prefixCls = _ref.prefixCls, _ref$rootCls = _ref.rootCls, rootCls = _ref$rootCls === void 0 ? prefixCls : _ref$rootCls;
			useStyle(prefixCls, rootCls);
			return null;
		};
		return StyledComponent;
	}
	return {
		a: genStyleHooks,
		b: genSubStyleComponent,
		c: genComponentStyleHook
	};
}
const PresetColors = [
	"blue",
	"purple",
	"cyan",
	"green",
	"magenta",
	"pink",
	"red",
	"orange",
	"yellow",
	"volcano",
	"geekblue",
	"lime",
	"gold"
];
function getLineHeight(fontSize) {
	return (fontSize + 8) / fontSize;
}
// https://zhuanlan.zhihu.com/p/32746810
function getFontSizes(base) {
	const fontSizes = Array.from({ length: 10 }).map((__unused_8C62, index) => {
		const i = index - 1;
		const baseSize = base * Math.E ** (i / 5);
		const intSize = index > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
		// Convert to even
		return Math.floor(intSize / 2) * 2;
	});
	fontSizes[1] = base;
	return fontSizes.map((size) => ({
		size,
		lineHeight: getLineHeight(size)
	}));
}
const defaultPresetColors = {
	blue: "#1677FF",
	purple: "#722ED1",
	cyan: "#13C2C2",
	green: "#52C41A",
	magenta: "#EB2F96",
	pink: "#EB2F96",
	red: "#F5222D",
	orange: "#FA8C16",
	yellow: "#FADB14",
	volcano: "#FA541C",
	geekblue: "#2F54EB",
	gold: "#FAAD14",
	lime: "#A0D911"
};
const seedToken = {
	...defaultPresetColors,
	colorPrimary: "#1677ff",
	colorSuccess: "#52c41a",
	colorWarning: "#faad14",
	colorError: "#ff4d4f",
	colorInfo: "#1677ff",
	colorLink: "",
	colorTextBase: "",
	colorBgBase: "",
	fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,\n'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n'Noto Color Emoji'",
	fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
	fontSize: 14,
	lineWidth: 1,
	lineType: "solid",
	motionUnit: .1,
	motionBase: 0,
	motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
	motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
	motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
	motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
	motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
	motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
	motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
	motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
	borderRadius: 6,
	sizeUnit: 4,
	sizeStep: 4,
	sizePopupArrow: 16,
	controlHeight: 32,
	zIndexBase: 0,
	zIndexPopupBase: 1e3,
	opacityImage: 1,
	wireframe: false,
	motion: true
};
// 36 Hex to reduce the size of the file
var presetColors = {
	aliceblue: "9ehhb",
	antiquewhite: "9sgk7",
	aqua: "1ekf",
	aquamarine: "4zsno",
	azure: "9eiv3",
	beige: "9lhp8",
	bisque: "9zg04",
	black: "0",
	blanchedalmond: "9zhe5",
	blue: "73",
	blueviolet: "5e31e",
	brown: "6g016",
	burlywood: "8ouiv",
	cadetblue: "3qba8",
	chartreuse: "4zshs",
	chocolate: "87k0u",
	coral: "9yvyo",
	cornflowerblue: "3xael",
	cornsilk: "9zjz0",
	crimson: "8l4xo",
	cyan: "1ekf",
	darkblue: "3v",
	darkcyan: "rkb",
	darkgoldenrod: "776yz",
	darkgray: "6mbhl",
	darkgreen: "jr4",
	darkgrey: "6mbhl",
	darkkhaki: "7ehkb",
	darkmagenta: "5f91n",
	darkolivegreen: "3bzfz",
	darkorange: "9yygw",
	darkorchid: "5z6x8",
	darkred: "5f8xs",
	darksalmon: "9441m",
	darkseagreen: "5lwgf",
	darkslateblue: "2th1n",
	darkslategray: "1ugcv",
	darkslategrey: "1ugcv",
	darkturquoise: "14up",
	darkviolet: "5rw7n",
	deeppink: "9yavn",
	deepskyblue: "11xb",
	dimgray: "442g9",
	dimgrey: "442g9",
	dodgerblue: "16xof",
	firebrick: "6y7tu",
	floralwhite: "9zkds",
	forestgreen: "1cisi",
	fuchsia: "9y70f",
	gainsboro: "8m8kc",
	ghostwhite: "9pq0v",
	goldenrod: "8j4f4",
	gold: "9zda8",
	gray: "50i2o",
	green: "pa8",
	greenyellow: "6senj",
	grey: "50i2o",
	honeydew: "9eiuo",
	hotpink: "9yrp0",
	indianred: "80gnw",
	indigo: "2xcoy",
	ivory: "9zldc",
	khaki: "9edu4",
	lavenderblush: "9ziet",
	lavender: "90c8q",
	lawngreen: "4vk74",
	lemonchiffon: "9zkct",
	lightblue: "6s73a",
	lightcoral: "9dtog",
	lightcyan: "8s1rz",
	lightgoldenrodyellow: "9sjiq",
	lightgray: "89jo3",
	lightgreen: "5nkwg",
	lightgrey: "89jo3",
	lightpink: "9z6wx",
	lightsalmon: "9z2ii",
	lightseagreen: "19xgq",
	lightskyblue: "5arju",
	lightslategray: "4nwk9",
	lightslategrey: "4nwk9",
	lightsteelblue: "6wau6",
	lightyellow: "9zlcw",
	lime: "1edc",
	limegreen: "1zcxe",
	linen: "9shk6",
	magenta: "9y70f",
	maroon: "4zsow",
	mediumaquamarine: "40eju",
	mediumblue: "5p",
	mediumorchid: "79qkz",
	mediumpurple: "5r3rv",
	mediumseagreen: "2d9ip",
	mediumslateblue: "4tcku",
	mediumspringgreen: "1di2",
	mediumturquoise: "2uabw",
	mediumvioletred: "7rn9h",
	midnightblue: "z980",
	mintcream: "9ljp6",
	mistyrose: "9zg0x",
	moccasin: "9zfzp",
	navajowhite: "9zest",
	navy: "3k",
	oldlace: "9wq92",
	olive: "50hz4",
	olivedrab: "472ub",
	orange: "9z3eo",
	orangered: "9ykg0",
	orchid: "8iu3a",
	palegoldenrod: "9bl4a",
	palegreen: "5yw0o",
	paleturquoise: "6v4ku",
	palevioletred: "8k8lv",
	papayawhip: "9zi6t",
	peachpuff: "9ze0p",
	peru: "80oqn",
	pink: "9z8wb",
	plum: "8nba5",
	powderblue: "6wgdi",
	purple: "4zssg",
	rebeccapurple: "3zk49",
	red: "9y6tc",
	rosybrown: "7cv4f",
	royalblue: "2jvtt",
	saddlebrown: "5fmkz",
	salmon: "9rvci",
	sandybrown: "9jn1c",
	seagreen: "1tdnb",
	seashell: "9zje6",
	sienna: "6973h",
	silver: "7ir40",
	skyblue: "5arjf",
	slateblue: "45e4t",
	slategray: "4e100",
	slategrey: "4e100",
	snow: "9zke2",
	springgreen: "1egv",
	steelblue: "2r1kk",
	tan: "87yx8",
	teal: "pds",
	thistle: "8ggk8",
	tomato: "9yqfb",
	turquoise: "2j4r4",
	violet: "9b10u",
	wheat: "9ld4j",
	white: "9zldr",
	whitesmoke: "9lhpx",
	yellow: "9zl6o",
	yellowgreen: "61fzm"
};
const round = Math.round;
/**
* Support format, alpha unit will check the % mark:
* - rgba(102, 204, 255, .5)      -> [102, 204, 255, 0.5]
* - rgb(102 204 255 / .5)        -> [102, 204, 255, 0.5]
* - rgb(100%, 50%, 0% / 50%)     -> [255, 128, 0, 0.5]
* - hsl(270, 60, 40, .5)         -> [270, 60, 40, 0.5]
* - hsl(270deg 60% 40% / 50%)   -> [270, 60, 40, 0.5]
*
* When `base` is provided, the percentage value will be divided by `base`.
*/
function splitColorStr(str, parseNum) {
	const match = str.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [];
	const numList = match.map((item) => parseFloat(item));
	for (let i = 0; i < 3; i += 1) {
		numList[i] = parseNum(numList[i] || 0, match[i] || "", i);
	}
	// For alpha. 50% should be 0.5
	if (match[3]) {
		numList[3] = match[3].includes("%") ? numList[3] / 100 : numList[3];
	} else {
		// By default, alpha is 1
		numList[3] = 1;
	}
	return numList;
}
const parseHSVorHSL = (num, __unused_387B, index) => index === 0 ? num : num / 100;
/** round and limit number to integer between 0-255 */
function limitRange(value, max) {
	const mergedMax = max || 255;
	if (value > mergedMax) {
		return mergedMax;
	}
	if (value < 0) {
		return 0;
	}
	return value;
}
class FastColor {
	/**
	* All FastColor objects are valid. So isValid is always true. This property is kept to be compatible with TinyColor.
	*/
	isValid = true;
	/**
	* Red, R in RGB
	*/
	r = 0;
	/**
	* Green, G in RGB
	*/
	g = 0;
	/**
	* Blue, B in RGB
	*/
	b = 0;
	/**
	* Alpha/Opacity, A in RGBA/HSLA
	*/
	a = 1;
	// HSV privates
	_h;
	_hsl_s;
	_hsv_s;
	_l;
	_v;
	// intermediate variables to calculate HSL/HSV
	_max;
	_min;
	_brightness;
	constructor(input) {
		/**
		* Always check 3 char in the object to determine the format.
		* We not use function in check to save bundle size.
		* e.g. 'rgb' -> { r: 0, g: 0, b: 0 }.
		*/
		function matchFormat(str) {
			return str[0] in input && str[1] in input && str[2] in input;
		}
		if (!!input) if (typeof input === "string") {
			const trimStr = input.trim();
			function matchPrefix(prefix) {
				return trimStr.startsWith(prefix);
			}
			if (/^#?[A-F\d]{3,8}$/i.test(trimStr)) {
				this.fromHexString(trimStr);
			} else if (matchPrefix("rgb")) {
				this.fromRgbString(trimStr);
			} else if (matchPrefix("hsl")) {
				this.fromHslString(trimStr);
			} else if (matchPrefix("hsv") || matchPrefix("hsb")) {
				this.fromHsvString(trimStr);
			} else {
				// From preset color
				const presetColor = presetColors[trimStr.toLowerCase()];
				if (presetColor) {
					this.fromHexString(
						// Convert 36 hex to 16 hex
						parseInt(presetColor, 36).toString(16).padStart(6, "0")
					);
				}
			}
		} else if (input instanceof FastColor) {
			this.r = input.r;
			this.g = input.g;
			this.b = input.b;
			this.a = input.a;
			this._h = input._h;
			this._hsl_s = input._hsl_s;
			this._hsv_s = input._hsv_s;
			this._l = input._l;
			this._v = input._v;
		} else if (matchFormat("rgb")) {
			this.r = limitRange(input.r);
			this.g = limitRange(input.g);
			this.b = limitRange(input.b);
			this.a = typeof input.a === "number" ? limitRange(input.a, 1) : 1;
		} else if (matchFormat("hsl")) {
			this.fromHsl(input);
		} else if (matchFormat("hsv")) {
			this.fromHsv(input);
		} else {
			throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(input));
		}
	}
	// ======================= Setter =======================
	setR(value) {
		return this._sc("r", value);
	}
	setG(value) {
		return this._sc("g", value);
	}
	setB(value) {
		return this._sc("b", value);
	}
	setA(value) {
		return this._sc("a", value, 1);
	}
	setHue(value) {
		const hsv = this.toHsv();
		hsv.h = value;
		return this._c(hsv);
	}
	// ======================= Getter =======================
	/**
	* Returns the perceived luminance of a color, from 0-1.
	* @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
	*/
	getLuminance() {
		function adjustGamma(raw) {
			const val = raw / 255;
			return val <= .03928 ? val / 12.92 : Math.pow((val + .055) / 1.055, 2.4);
		}
		const R = adjustGamma(this.r);
		const G = adjustGamma(this.g);
		const B = adjustGamma(this.b);
		return .2126 * R + .7152 * G + .0722 * B;
	}
	getHue() {
		if (typeof this._h === "undefined") {
			const delta = this.getMax() - this.getMin();
			if (delta === 0) {
				this._h = 0;
			} else {
				this._h = round(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));
			}
		}
		return this._h;
	}
	/**
	* @deprecated should use getHSVSaturation or getHSLSaturation instead
	*/
	getSaturation() {
		return this.getHSVSaturation();
	}
	getHSVSaturation() {
		if (typeof this._hsv_s === "undefined") {
			const delta = this.getMax() - this.getMin();
			if (delta === 0) {
				this._hsv_s = 0;
			} else {
				this._hsv_s = delta / this.getMax();
			}
		}
		return this._hsv_s;
	}
	getHSLSaturation() {
		if (typeof this._hsl_s === "undefined") {
			const delta = this.getMax() - this.getMin();
			if (delta === 0) {
				this._hsl_s = 0;
			} else {
				const l = this.getLightness();
				this._hsl_s = delta / 255 / (1 - Math.abs(2 * l - 1));
			}
		}
		return this._hsl_s;
	}
	getLightness() {
		if (typeof this._l === "undefined") {
			this._l = (this.getMax() + this.getMin()) / 510;
		}
		return this._l;
	}
	getValue() {
		if (typeof this._v === "undefined") {
			this._v = this.getMax() / 255;
		}
		return this._v;
	}
	/**
	* Returns the perceived brightness of the color, from 0-255.
	* Note: this is not the b of HSB
	* @see http://www.w3.org/TR/AERT#color-contrast
	*/
	getBrightness() {
		if (typeof this._brightness === "undefined") {
			this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3;
		}
		return this._brightness;
	}
	// ======================== Func ========================
	darken(amount = 10) {
		const h = this.getHue();
		const s = this.getSaturation();
		let l = this.getLightness() - amount / 100;
		if (l < 0) {
			l = 0;
		}
		return this._c({
			h,
			s,
			l,
			a: this.a
		});
	}
	lighten(amount = 10) {
		const h = this.getHue();
		const s = this.getSaturation();
		let l = this.getLightness() + amount / 100;
		if (l > 1) {
			l = 1;
		}
		return this._c({
			h,
			s,
			l,
			a: this.a
		});
	}
	/**
	* Mix the current color a given amount with another color, from 0 to 100.
	* 0 means no mixing (return current color).
	*/
	mix(input, amount = 50) {
		const color = this._c(input);
		const p = amount / 100;
		const calc = (key) => (color[key] - this[key]) * p + this[key];
		const rgba = {
			r: round(calc("r")),
			g: round(calc("g")),
			b: round(calc("b")),
			a: round(calc("a") * 100) / 100
		};
		return this._c(rgba);
	}
	/**
	* Mix the color with pure white, from 0 to 100.
	* Providing 0 will do nothing, providing 100 will always return white.
	*/
	tint(amount = 10) {
		return this.mix({
			r: 255,
			g: 255,
			b: 255,
			a: 1
		}, amount);
	}
	/**
	* Mix the color with pure black, from 0 to 100.
	* Providing 0 will do nothing, providing 100 will always return black.
	*/
	shade(amount = 10) {
		return this.mix({
			r: 0,
			g: 0,
			b: 0,
			a: 1
		}, amount);
	}
	onBackground(background) {
		const bg = this._c(background);
		const alpha = this.a + bg.a * (1 - this.a);
		const calc = (key) => {
			return round((this[key] * this.a + bg[key] * bg.a * (1 - this.a)) / alpha);
		};
		return this._c({
			r: calc("r"),
			g: calc("g"),
			b: calc("b"),
			a: alpha
		});
	}
	// ======================= Status =======================
	isDark() {
		return this.getBrightness() < 128;
	}
	isLight() {
		return this.getBrightness() >= 128;
	}
	// ======================== MISC ========================
	equals(other) {
		return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
	}
	clone() {
		return this._c(this);
	}
	// ======================= Format =======================
	toHexString() {
		let hex = "#";
		const rHex = (this.r || 0).toString(16);
		hex += rHex.length === 2 ? rHex : "0" + rHex;
		const gHex = (this.g || 0).toString(16);
		hex += gHex.length === 2 ? gHex : "0" + gHex;
		const bHex = (this.b || 0).toString(16);
		hex += bHex.length === 2 ? bHex : "0" + bHex;
		if (typeof this.a === "number" && this.a >= 0 && this.a < 1) {
			const aHex = round(this.a * 255).toString(16);
			hex += aHex.length === 2 ? aHex : "0" + aHex;
		}
		return hex;
	}
	/** CSS support color pattern */
	toHsl() {
		return {
			h: this.getHue(),
			s: this.getHSLSaturation(),
			l: this.getLightness(),
			a: this.a
		};
	}
	/** CSS support color pattern */
	toHslString() {
		const h = this.getHue();
		const s = round(this.getHSLSaturation() * 100);
		const l = round(this.getLightness() * 100);
		return this.a !== 1 ? `hsla(${h},${s}%,${l}%,${this.a})` : `hsl(${h},${s}%,${l}%)`;
	}
	/** Same as toHsb */
	toHsv() {
		return {
			h: this.getHue(),
			s: this.getHSVSaturation(),
			v: this.getValue(),
			a: this.a
		};
	}
	toRgb() {
		return {
			r: this.r,
			g: this.g,
			b: this.b,
			a: this.a
		};
	}
	toRgbString() {
		return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
	}
	toString() {
		return this.toRgbString();
	}
	// ====================== Privates ======================
	/** Return a new FastColor object with one channel changed */
	_sc(rgb, value, max) {
		const clone = this.clone();
		clone[rgb] = limitRange(value, max);
		return clone;
	}
	_c(input) {
		return new this.constructor(input);
	}
	getMax() {
		if (typeof this._max === "undefined") {
			this._max = Math.max(this.r, this.g, this.b);
		}
		return this._max;
	}
	getMin() {
		if (typeof this._min === "undefined") {
			this._min = Math.min(this.r, this.g, this.b);
		}
		return this._min;
	}
	fromHexString(trimStr) {
		const withoutPrefix = trimStr.replace("#", "");
		function connectNum(index1, index2) {
			return parseInt(withoutPrefix[index1] + withoutPrefix[index2 || index1], 16);
		}
		if (withoutPrefix.length < 6) {
			// #rgb or #rgba
			this.r = connectNum(0);
			this.g = connectNum(1);
			this.b = connectNum(2);
			this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1;
		} else {
			// #rrggbb or #rrggbbaa
			this.r = connectNum(0, 1);
			this.g = connectNum(2, 3);
			this.b = connectNum(4, 5);
			this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1;
		}
	}
	fromHsl({ h: _h, s, l, a }) {
		const h = (_h % 360 + 360) % 360;
		this._h = h;
		this._hsl_s = s;
		this._l = l;
		this.a = typeof a === "number" ? a : 1;
		if (s <= 0) {
			const rgb = round(l * 255);
			this.r = rgb;
			this.g = rgb;
			this.b = rgb;
			return;
		}
		let r = 0, g = 0, b = 0;
		const huePrime = h / 60;
		const chroma = (1 - Math.abs(2 * l - 1)) * s;
		const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
		if (huePrime >= 0 && huePrime < 1) {
			r = chroma;
			g = secondComponent;
		} else if (huePrime >= 1 && huePrime < 2) {
			r = secondComponent;
			g = chroma;
		} else if (huePrime >= 2 && huePrime < 3) {
			g = chroma;
			b = secondComponent;
		} else if (huePrime >= 3 && huePrime < 4) {
			g = secondComponent;
			b = chroma;
		} else if (huePrime >= 4 && huePrime < 5) {
			r = secondComponent;
			b = chroma;
		} else if (huePrime >= 5 && huePrime < 6) {
			r = chroma;
			b = secondComponent;
		}
		const lightnessModification = l - chroma / 2;
		this.r = round((r + lightnessModification) * 255);
		this.g = round((g + lightnessModification) * 255);
		this.b = round((b + lightnessModification) * 255);
	}
	fromHsv({ h: _h, s, v, a }) {
		const h = (_h % 360 + 360) % 360;
		this._h = h;
		this._hsv_s = s;
		this._v = v;
		this.a = typeof a === "number" ? a : 1;
		const vv = round(v * 255);
		this.r = vv;
		this.g = vv;
		this.b = vv;
		if (s <= 0) {
			return;
		}
		const hh = h / 60;
		const i = Math.floor(hh);
		const ff = hh - i;
		const p = round(v * (1 - s) * 255);
		const q = round(v * (1 - s * ff) * 255);
		const t = round(v * (1 - s * (1 - ff)) * 255);
		switch (i) {
			case 0:
				this.g = t;
				this.b = p;
				break;
			case 1:
				this.r = q;
				this.b = p;
				break;
			case 2:
				this.r = p;
				this.b = t;
				break;
			case 3:
				this.r = p;
				this.g = q;
				break;
			case 4:
				this.r = t;
				this.g = p;
				break;
			case 5:
			default:
				this.g = p;
				this.b = q;
				break;
		}
	}
	fromHsvString(trimStr) {
		const cells = splitColorStr(trimStr, parseHSVorHSL);
		this.fromHsv({
			h: cells[0],
			s: cells[1],
			v: cells[2],
			a: cells[3]
		});
	}
	fromHslString(trimStr) {
		const cells = splitColorStr(trimStr, parseHSVorHSL);
		this.fromHsl({
			h: cells[0],
			s: cells[1],
			l: cells[2],
			a: cells[3]
		});
	}
	fromRgbString(trimStr) {
		const cells = splitColorStr(trimStr, (num, txt) => txt.includes("%") ? round(num / 100 * 255) : num);
		this.r = cells[0];
		this.g = cells[1];
		this.b = cells[2];
		this.a = cells[3];
	}
}
const saturationStep = .16;
const saturationStep2 = .05;
const brightnessStep1 = .05;
const brightnessStep2 = .15;
function getHue(hsv, i, light) {
	let hue;
	// 
	if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
		hue = light ? Math.round(hsv.h) - 2 * i : Math.round(hsv.h) + 2 * i;
	} else {
		hue = light ? Math.round(hsv.h) + 2 * i : Math.round(hsv.h) - 2 * i;
	}
	if (hue < 0) {
		hue += 360;
	} else if (hue >= 360) {
		hue -= 360;
	}
	return hue;
}
function getSaturation(hsv, i, light) {
	// grey color don't change saturation
	if (hsv.h === 0 && hsv.s === 0) {
		return hsv.s;
	}
	let saturation;
	if (light) {
		saturation = hsv.s - saturationStep * i;
	} else if (i === 4) {
		saturation = hsv.s + saturationStep;
	} else {
		saturation = hsv.s + saturationStep2 * i;
	}
	// 
	if (saturation > 1) {
		saturation = 1;
	}
	//  s  0.06-0.1 
	if (light && i === 5 && saturation > .1) {
		saturation = .1;
	}
	if (saturation < .06) {
		saturation = .06;
	}
	return Math.round(saturation * 100) / 100;
}
function getValue$1(hsv, i, light) {
	let value;
	if (light) {
		value = hsv.v + brightnessStep1 * i;
	} else {
		value = hsv.v - brightnessStep2 * i;
	}
	// Clamp value between 0 and 1
	value = Math.max(0, Math.min(1, value));
	return Math.round(value * 100) / 100;
}
function generate$1(color) {
	const patterns = [];
	const pColor = new FastColor(color);
	const hsv = pColor.toHsv();
	for (let i = 5; i > 0; i -= 1) {
		const c = new FastColor({
			h: getHue(hsv, i, true),
			s: getSaturation(hsv, i, true),
			v: getValue$1(hsv, i, true)
		});
		patterns.push(c);
	}
	patterns.push(pColor);
	for (let i = 1; i <= 4; i += 1) {
		const c = new FastColor({
			h: getHue(hsv, i),
			s: getSaturation(hsv, i),
			v: getValue$1(hsv, i)
		});
		patterns.push(c);
	}
	return patterns.map((c) => c.toHexString());
}
// Generated by script. Do NOT modify!
const presetPrimaryColors = {
	"red": "#F5222D",
	"volcano": "#FA541C",
	"orange": "#FA8C16",
	"gold": "#FAAD14",
	"yellow": "#FADB14",
	"lime": "#A0D911",
	"green": "#52C41A",
	"cyan": "#13C2C2",
	"blue": "#1677FF",
	"geekblue": "#2F54EB",
	"purple": "#722ED1",
	"magenta": "#EB2F96",
	"grey": "#666666"
};
const red = [
	"#fff1f0",
	"#ffccc7",
	"#ffa39e",
	"#ff7875",
	"#ff4d4f",
	"#f5222d",
	"#cf1322",
	"#a8071a",
	"#820014",
	"#5c0011"
];
red.primary = "#f5222d";
const volcano = [
	"#fff2e8",
	"#ffd8bf",
	"#ffbb96",
	"#ff9c6e",
	"#ff7a45",
	"#fa541c",
	"#d4380d",
	"#ad2102",
	"#871400",
	"#610b00"
];
volcano.primary = "#fa541c";
const orange = [
	"#fff7e6",
	"#ffe7ba",
	"#ffd591",
	"#ffc069",
	"#ffa940",
	"#fa8c16",
	"#d46b08",
	"#ad4e00",
	"#873800",
	"#612500"
];
orange.primary = "#fa8c16";
const gold = [
	"#fffbe6",
	"#fff1b8",
	"#ffe58f",
	"#ffd666",
	"#ffc53d",
	"#faad14",
	"#d48806",
	"#ad6800",
	"#874d00",
	"#613400"
];
gold.primary = "#faad14";
const yellow = [
	"#feffe6",
	"#ffffb8",
	"#fffb8f",
	"#fff566",
	"#ffec3d",
	"#fadb14",
	"#d4b106",
	"#ad8b00",
	"#876800",
	"#614700"
];
yellow.primary = "#fadb14";
const lime = [
	"#fcffe6",
	"#f4ffb8",
	"#eaff8f",
	"#d3f261",
	"#bae637",
	"#a0d911",
	"#7cb305",
	"#5b8c00",
	"#3f6600",
	"#254000"
];
lime.primary = "#a0d911";
const green = [
	"#f6ffed",
	"#d9f7be",
	"#b7eb8f",
	"#95de64",
	"#73d13d",
	"#52c41a",
	"#389e0d",
	"#237804",
	"#135200",
	"#092b00"
];
green.primary = "#52c41a";
const cyan = [
	"#e6fffb",
	"#b5f5ec",
	"#87e8de",
	"#5cdbd3",
	"#36cfc9",
	"#13c2c2",
	"#08979c",
	"#006d75",
	"#00474f",
	"#002329"
];
cyan.primary = "#13c2c2";
const blue = [
	"#e6f4ff",
	"#bae0ff",
	"#91caff",
	"#69b1ff",
	"#4096ff",
	"#1677ff",
	"#0958d9",
	"#003eb3",
	"#002c8c",
	"#001d66"
];
blue.primary = "#1677ff";
const geekblue = [
	"#f0f5ff",
	"#d6e4ff",
	"#adc6ff",
	"#85a5ff",
	"#597ef7",
	"#2f54eb",
	"#1d39c4",
	"#10239e",
	"#061178",
	"#030852"
];
geekblue.primary = "#2f54eb";
const purple = [
	"#f9f0ff",
	"#efdbff",
	"#d3adf7",
	"#b37feb",
	"#9254de",
	"#722ed1",
	"#531dab",
	"#391085",
	"#22075e",
	"#120338"
];
purple.primary = "#722ed1";
const magenta = [
	"#fff0f6",
	"#ffd6e7",
	"#ffadd2",
	"#ff85c0",
	"#f759ab",
	"#eb2f96",
	"#c41d7f",
	"#9e1068",
	"#780650",
	"#520339"
];
magenta.primary = "#eb2f96";
const grey = [
	"#a6a6a6",
	"#999999",
	"#8c8c8c",
	"#808080",
	"#737373",
	"#666666",
	"#404040",
	"#1a1a1a",
	"#000000",
	"#000000"
];
grey.primary = "#666666";
const presetPalettes = {
	red,
	volcano,
	orange,
	gold,
	yellow,
	lime,
	green,
	cyan,
	blue,
	geekblue,
	purple,
	magenta,
	grey
};
function genColorMapToken(seed, { a: generateColorPalettes, b: generateNeutralColorPalettes }) {
	const { colorSuccess: colorSuccessBase, colorWarning: colorWarningBase, colorError: colorErrorBase, colorInfo: colorInfoBase, colorPrimary: colorPrimaryBase, colorBgBase, colorTextBase } = seed;
	const primaryColors = generateColorPalettes(colorPrimaryBase);
	const successColors = generateColorPalettes(colorSuccessBase);
	const warningColors = generateColorPalettes(colorWarningBase);
	const errorColors = generateColorPalettes(colorErrorBase);
	const infoColors = generateColorPalettes(colorInfoBase);
	const neutralColors = generateNeutralColorPalettes(colorBgBase, colorTextBase);
	// Color Link
	const colorLink = seed.colorLink || seed.colorInfo;
	const linkColors = generateColorPalettes(colorLink);
	const colorErrorBgFilledHover = new FastColor(errorColors[1]).mix(new FastColor(errorColors[3]), 50).toHexString();
	return {
		...neutralColors,
		colorPrimaryBg: primaryColors[1],
		colorPrimaryBgHover: primaryColors[2],
		colorPrimaryBorder: primaryColors[3],
		colorPrimaryBorderHover: primaryColors[4],
		colorPrimaryHover: primaryColors[5],
		colorPrimary: primaryColors[6],
		colorPrimaryActive: primaryColors[7],
		colorPrimaryTextHover: primaryColors[8],
		colorPrimaryText: primaryColors[9],
		colorPrimaryTextActive: primaryColors[10],
		colorSuccessBg: successColors[1],
		colorSuccessBgHover: successColors[2],
		colorSuccessBorder: successColors[3],
		colorSuccessBorderHover: successColors[4],
		colorSuccessHover: successColors[4],
		colorSuccess: successColors[6],
		colorSuccessActive: successColors[7],
		colorSuccessTextHover: successColors[8],
		colorSuccessText: successColors[9],
		colorSuccessTextActive: successColors[10],
		colorErrorBg: errorColors[1],
		colorErrorBgHover: errorColors[2],
		colorErrorBgFilledHover,
		colorErrorBgActive: errorColors[3],
		colorErrorBorder: errorColors[3],
		colorErrorBorderHover: errorColors[4],
		colorErrorHover: errorColors[5],
		colorError: errorColors[6],
		colorErrorActive: errorColors[7],
		colorErrorTextHover: errorColors[8],
		colorErrorText: errorColors[9],
		colorErrorTextActive: errorColors[10],
		colorWarningBg: warningColors[1],
		colorWarningBgHover: warningColors[2],
		colorWarningBorder: warningColors[3],
		colorWarningBorderHover: warningColors[4],
		colorWarningHover: warningColors[4],
		colorWarning: warningColors[6],
		colorWarningActive: warningColors[7],
		colorWarningTextHover: warningColors[8],
		colorWarningText: warningColors[9],
		colorWarningTextActive: warningColors[10],
		colorInfoBg: infoColors[1],
		colorInfoBgHover: infoColors[2],
		colorInfoBorder: infoColors[3],
		colorInfoBorderHover: infoColors[4],
		colorInfoHover: infoColors[4],
		colorInfo: infoColors[6],
		colorInfoActive: infoColors[7],
		colorInfoTextHover: infoColors[8],
		colorInfoText: infoColors[9],
		colorInfoTextActive: infoColors[10],
		colorLinkHover: linkColors[4],
		colorLink: linkColors[6],
		colorLinkActive: linkColors[7],
		colorBgMask: new FastColor("#000").setA(.45).toRgbString(),
		colorWhite: "#fff"
	};
}
const genRadius = (radiusBase) => {
	let radiusLG = radiusBase;
	let radiusSM = radiusBase;
	let radiusXS = radiusBase;
	let radiusOuter = radiusBase;
	// radiusLG
	if (radiusBase < 6 && radiusBase >= 5) {
		radiusLG = radiusBase + 1;
	} else if (radiusBase < 16 && radiusBase >= 6) {
		radiusLG = radiusBase + 2;
	} else if (radiusBase >= 16) {
		radiusLG = 16;
	}
	// radiusSM
	if (radiusBase < 7 && radiusBase >= 5) {
		radiusSM = 4;
	} else if (radiusBase < 8 && radiusBase >= 7) {
		radiusSM = 5;
	} else if (radiusBase < 14 && radiusBase >= 8) {
		radiusSM = 6;
	} else if (radiusBase < 16 && radiusBase >= 14) {
		radiusSM = 7;
	} else if (radiusBase >= 16) {
		radiusSM = 8;
	}
	// radiusXS
	if (radiusBase < 6 && radiusBase >= 2) {
		radiusXS = 1;
	} else if (radiusBase >= 6) {
		radiusXS = 2;
	}
	// radiusOuter
	if (radiusBase > 4 && radiusBase < 8) {
		radiusOuter = 4;
	} else if (radiusBase >= 8) {
		radiusOuter = 6;
	}
	return {
		borderRadius: radiusBase,
		borderRadiusXS: radiusXS,
		borderRadiusSM: radiusSM,
		borderRadiusLG: radiusLG,
		borderRadiusOuter: radiusOuter
	};
};
function genCommonMapToken(token) {
	const { motionUnit, motionBase, borderRadius, lineWidth } = token;
	return {
		motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
		motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
		motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
		lineWidthBold: lineWidth + 1,
		...genRadius(borderRadius)
	};
}
const genControlHeight = (token) => {
	const { controlHeight } = token;
	return {
		controlHeightSM: controlHeight * .75,
		controlHeightXS: controlHeight * .5,
		controlHeightLG: controlHeight * 1.25
	};
};
const genFontMapToken = (fontSize) => {
	const fontSizePairs = getFontSizes(fontSize);
	const fontSizes = fontSizePairs.map((pair) => pair.size);
	const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
	const fontSizeMD = fontSizes[1];
	const fontSizeSM = fontSizes[0];
	const fontSizeLG = fontSizes[2];
	const lineHeight = lineHeights[1];
	const lineHeightSM = lineHeights[0];
	const lineHeightLG = lineHeights[2];
	return {
		fontSizeSM,
		fontSize: fontSizeMD,
		fontSizeLG,
		fontSizeXL: fontSizes[3],
		fontSizeHeading1: fontSizes[6],
		fontSizeHeading2: fontSizes[5],
		fontSizeHeading3: fontSizes[4],
		fontSizeHeading4: fontSizes[3],
		fontSizeHeading5: fontSizes[2],
		lineHeight,
		lineHeightLG,
		lineHeightSM,
		fontHeight: Math.round(lineHeight * fontSizeMD),
		fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
		fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
		lineHeightHeading1: lineHeights[6],
		lineHeightHeading2: lineHeights[5],
		lineHeightHeading3: lineHeights[4],
		lineHeightHeading4: lineHeights[3],
		lineHeightHeading5: lineHeights[2]
	};
};
function genSizeMapToken(token) {
	const { sizeUnit, sizeStep } = token;
	return {
		sizeXXL: sizeUnit * (sizeStep + 8),
		sizeXL: sizeUnit * (sizeStep + 4),
		sizeLG: sizeUnit * (sizeStep + 2),
		sizeMD: sizeUnit * (sizeStep + 1),
		sizeMS: sizeUnit * sizeStep,
		size: sizeUnit * sizeStep,
		sizeSM: sizeUnit * (sizeStep - 1),
		sizeXS: sizeUnit * (sizeStep - 2),
		sizeXXS: sizeUnit * (sizeStep - 3)
	};
}
const getAlphaColor$1 = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
const getSolidColor = (baseColor, brightness) => {
	const instance = new FastColor(baseColor);
	return instance.darken(brightness).toHexString();
};
const generateColorPalettes = (baseColor) => {
	const colors = generate$1(baseColor);
	return {
		1: colors[0],
		2: colors[1],
		3: colors[2],
		4: colors[3],
		5: colors[4],
		6: colors[5],
		7: colors[6],
		8: colors[4],
		9: colors[5],
		10: colors[6]
	};
};
const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
	const colorBgBase = bgBaseColor || "#fff";
	const colorTextBase = textBaseColor || "#000";
	return {
		colorBgBase,
		colorTextBase,
		colorText: getAlphaColor$1(colorTextBase, .88),
		colorTextSecondary: getAlphaColor$1(colorTextBase, .65),
		colorTextTertiary: getAlphaColor$1(colorTextBase, .45),
		colorTextQuaternary: getAlphaColor$1(colorTextBase, .25),
		colorFill: getAlphaColor$1(colorTextBase, .15),
		colorFillSecondary: getAlphaColor$1(colorTextBase, .06),
		colorFillTertiary: getAlphaColor$1(colorTextBase, .04),
		colorFillQuaternary: getAlphaColor$1(colorTextBase, .02),
		colorBgSolid: getAlphaColor$1(colorTextBase, 1),
		colorBgSolidHover: getAlphaColor$1(colorTextBase, .75),
		colorBgSolidActive: getAlphaColor$1(colorTextBase, .95),
		colorBgLayout: getSolidColor(colorBgBase, 4),
		colorBgContainer: getSolidColor(colorBgBase, 0),
		colorBgElevated: getSolidColor(colorBgBase, 0),
		colorBgSpotlight: getAlphaColor$1(colorTextBase, .85),
		colorBgBlur: "transparent",
		colorBorder: getSolidColor(colorBgBase, 15),
		colorBorderDisabled: getSolidColor(colorBgBase, 15),
		colorBorderSecondary: getSolidColor(colorBgBase, 6)
	};
};
function derivative(token) {
	// pink is deprecated name of magenta, keep this for backwards compatibility
	presetPrimaryColors.pink = "#EB2F96";
	presetPalettes.pink = presetPalettes.magenta;
	const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
		const colors = token[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate$1(token[colorKey]);
		return Array.from({ length: 10 }, () => 1).reduce((prev, __unused_1561, i) => {
			prev[`${colorKey}-${i + 1}`] = colors[i];
			prev[`${colorKey}${i + 1}`] = colors[i];
			return prev;
		}, {});
	}).reduce((prev, cur) => {
		prev = {
			...prev,
			...cur
		};
		return prev;
	}, {});
	return {
		...token,
		...colorPalettes,
		...genColorMapToken(token, {
			a: generateColorPalettes,
			b: generateNeutralColorPalettes
		}),
		...genFontMapToken(token.fontSize),
		...genSizeMapToken(token),
		...genControlHeight(token),
		...genCommonMapToken(token)
	};
}
const defaultTheme = createTheme(derivative);
// ================================ Context =================================
// To ensure snapshot stable. We disable hashed in test env.
const defaultConfig = {
	token: seedToken,
	override: { override: seedToken },
	hashed: true
};
const DesignTokenContext = React.createContext(defaultConfig);
function isStableColor(color) {
	return color >= 0 && color <= 255;
}
function getAlphaColor(frontColor, backgroundColor) {
	const { r: fR, g: fG, b: fB, a: originAlpha } = new FastColor(frontColor).toRgb();
	if (originAlpha < 1) {
		return frontColor;
	}
	const { r: bR, g: bG, b: bB } = new FastColor(backgroundColor).toRgb();
	for (let fA = .01; fA <= 1; fA += .01) {
		const r = Math.round((fR - bR * (1 - fA)) / fA);
		const g = Math.round((fG - bG * (1 - fA)) / fA);
		const b = Math.round((fB - bB * (1 - fA)) / fA);
		if (isStableColor(r) && isStableColor(g) && isStableColor(b)) {
			return new FastColor({
				r,
				g,
				b,
				a: Math.round(fA * 100) / 100
			}).toRgbString();
		}
	}
	// fallback
	/* istanbul ignore next */
	return new FastColor({
		r: fR,
		g: fG,
		b: fB,
		a: 1
	}).toRgbString();
}
/**
* Seed (designer) > Derivative (designer) > Alias (developer).
*
* Merge seed & derivative & override token and generate alias token for developer.
*/
function formatToken(derivativeToken) {
	const { override, ...restToken } = derivativeToken;
	const overrideTokens = { ...override };
	Object.keys(seedToken).forEach((token) => {
		delete overrideTokens[token];
	});
	const mergedToken = {
		...restToken,
		...overrideTokens
	};
	// Motion
	if (mergedToken.motion === false) {
		mergedToken.motionDurationFast = "0s";
		mergedToken.motionDurationMid = "0s";
		mergedToken.motionDurationSlow = "0s";
	}
	// Generate alias token
	const aliasToken = {
		...mergedToken,
		colorFillContent: mergedToken.colorFillSecondary,
		colorFillContentHover: mergedToken.colorFill,
		colorFillAlter: mergedToken.colorFillQuaternary,
		colorBgContainerDisabled: mergedToken.colorFillTertiary,
		colorBorderBg: mergedToken.colorBgContainer,
		colorSplit: getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
		colorTextPlaceholder: mergedToken.colorTextQuaternary,
		colorTextDisabled: mergedToken.colorTextQuaternary,
		colorTextHeading: mergedToken.colorText,
		colorTextLabel: mergedToken.colorTextSecondary,
		colorTextDescription: mergedToken.colorTextTertiary,
		colorTextLightSolid: mergedToken.colorWhite,
		colorHighlight: mergedToken.colorError,
		colorBgTextHover: mergedToken.colorFillSecondary,
		colorBgTextActive: mergedToken.colorFill,
		colorIcon: mergedToken.colorTextTertiary,
		colorIconHover: mergedToken.colorText,
		colorErrorOutline: getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
		colorWarningOutline: getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
		fontSizeIcon: mergedToken.fontSizeSM,
		lineWidthFocus: mergedToken.lineWidth * 3,
		lineWidth: mergedToken.lineWidth,
		controlOutlineWidth: mergedToken.lineWidth * 2,
		controlInteractiveSize: mergedToken.controlHeight / 2,
		controlItemBgHover: mergedToken.colorFillTertiary,
		controlItemBgActive: mergedToken.colorPrimaryBg,
		controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
		controlItemBgActiveDisabled: mergedToken.colorFill,
		controlTmpOutline: mergedToken.colorFillQuaternary,
		controlOutline: getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
		lineType: mergedToken.lineType,
		borderRadius: mergedToken.borderRadius,
		borderRadiusXS: mergedToken.borderRadiusXS,
		borderRadiusSM: mergedToken.borderRadiusSM,
		borderRadiusLG: mergedToken.borderRadiusLG,
		fontWeightStrong: 600,
		opacityLoading: .65,
		linkDecoration: "none",
		linkHoverDecoration: "none",
		linkFocusDecoration: "none",
		controlPaddingHorizontal: 12,
		controlPaddingHorizontalSM: 8,
		paddingXXS: mergedToken.sizeXXS,
		paddingXS: mergedToken.sizeXS,
		paddingSM: mergedToken.sizeSM,
		padding: mergedToken.size,
		paddingMD: mergedToken.sizeMD,
		paddingLG: mergedToken.sizeLG,
		paddingXL: mergedToken.sizeXL,
		paddingContentHorizontalLG: mergedToken.sizeLG,
		paddingContentVerticalLG: mergedToken.sizeMS,
		paddingContentHorizontal: mergedToken.sizeMS,
		paddingContentVertical: mergedToken.sizeSM,
		paddingContentHorizontalSM: mergedToken.size,
		paddingContentVerticalSM: mergedToken.sizeXS,
		marginXXS: mergedToken.sizeXXS,
		marginXS: mergedToken.sizeXS,
		marginSM: mergedToken.sizeSM,
		margin: mergedToken.size,
		marginMD: mergedToken.sizeMD,
		marginLG: mergedToken.sizeLG,
		marginXL: mergedToken.sizeXL,
		marginXXL: mergedToken.sizeXXL,
		boxShadow: "\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
		boxShadowSecondary: "\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
		boxShadowTertiary: "\n      0 1px 2px 0 rgba(0, 0, 0, 0.03),\n      0 1px 6px -1px rgba(0, 0, 0, 0.02),\n      0 2px 4px 0 rgba(0, 0, 0, 0.02)\n    ",
		screenXS: 480,
		screenXSMin: 480,
		screenXSMax: 575,
		screenSM: 576,
		screenSMMin: 576,
		screenSMMax: 767,
		screenMD: 768,
		screenMDMin: 768,
		screenMDMax: 991,
		screenLG: 992,
		screenLGMin: 992,
		screenLGMax: 1199,
		screenXL: 1200,
		screenXLMin: 1200,
		screenXLMax: 1599,
		screenXXL: 1600,
		screenXXLMin: 1600,
		boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
		boxShadowCard: `
      0 1px 2px -2px ${new FastColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new FastColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new FastColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
		boxShadowDrawerRight: "\n      -6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      -3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      -9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ",
		boxShadowDrawerLeft: "\n      6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ",
		boxShadowDrawerUp: "\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
		boxShadowDrawerDown: "\n      0 -6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 -3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 -9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
		boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
		boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
		boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
		boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
		...overrideTokens
	};
	return aliasToken;
}
const unitless = {
	lineHeight: true,
	lineHeightSM: true,
	lineHeightLG: true,
	lineHeightHeading1: true,
	lineHeightHeading2: true,
	lineHeightHeading3: true,
	lineHeightHeading4: true,
	lineHeightHeading5: true,
	opacityLoading: true,
	fontWeightStrong: true,
	zIndexPopupBase: true,
	zIndexBase: true,
	opacityImage: true
};
const ignore = {
	motionBase: true,
	motionUnit: true
};
const preserve = {
	screenXS: true,
	screenXSMin: true,
	screenXSMax: true,
	screenSM: true,
	screenSMMin: true,
	screenSMMax: true,
	screenMD: true,
	screenMDMin: true,
	screenMDMax: true,
	screenLG: true,
	screenLGMin: true,
	screenLGMax: true,
	screenXL: true,
	screenXLMin: true,
	screenXLMax: true,
	screenXXL: true,
	screenXXLMin: true
};
const getComputedToken = (originToken, overrideToken, theme) => {
	const derivativeToken = theme.getDerivativeToken(originToken);
	const { override, ...components } = overrideToken;
	// Merge with override
	let mergedDerivativeToken = {
		...derivativeToken,
		override
	};
	// Format if needed
	mergedDerivativeToken = formatToken(mergedDerivativeToken);
	{
		{
			Object.entries(components).forEach(([key, value]) => {
				const { theme: componentTheme, ...componentTokens } = value;
				let mergedComponentToken = componentTokens;
				if (componentTheme) {
					mergedComponentToken = getComputedToken({
						...mergedDerivativeToken,
						...componentTokens
					}, { override: componentTokens }, componentTheme);
				}
				mergedDerivativeToken[key] = mergedComponentToken;
			});
		}
	}
	return mergedDerivativeToken;
};
// ================================== Hook ==================================
function useToken() {
	const { token: rootDesignToken, hashed, theme, override, cssVar: ctxCssVar, zeroRuntime } = React.useContext(DesignTokenContext);
	const cssVar = {
		prefix: ctxCssVar?.prefix ?? "ant",
		key: ctxCssVar?.key ?? "css-var-root"
	};
	const salt = `${"6.2.3"}-${hashed || ""}`;
	const mergedTheme = theme || defaultTheme;
	const [token, hashId, realToken] = useCacheToken(mergedTheme, [seedToken, rootDesignToken], {
		a: salt,
		b: override,
		c: getComputedToken,
		d: {
			...cssVar,
			unitless,
			ignore,
			preserve
		}
	});
	return [
		mergedTheme,
		realToken,
		hashed ? hashId : "",
		token,
		cssVar,
		!!zeroRuntime
	];
}
const textEllipsis = {
	overflow: "hidden",
	whiteSpace: "nowrap",
	textOverflow: "ellipsis"
};
const resetComponent = (token) => ({
	boxSizing: "border-box",
	margin: 0,
	padding: 0,
	color: token.colorText,
	fontSize: token.fontSize,
	lineHeight: token.lineHeight,
	listStyle: "none",
	fontFamily: token.fontFamily
});
const resetIcon = () => ({
	display: "inline-flex",
	alignItems: "center",
	color: "inherit",
	fontStyle: "normal",
	lineHeight: 0,
	textAlign: "center",
	textTransform: "none",
	verticalAlign: "-0.125em",
	textRendering: "optimizeLegibility",
	"-webkit-font-smoothing": "antialiased",
	"-moz-osx-font-smoothing": "grayscale",
	"> *": { lineHeight: 1 },
	svg: { display: "inline-block" }
});
const clearFix = () => ({
	"&::before": {
		display: "table",
		content: "\"\""
	},
	"&::after": {
		display: "table",
		clear: "both",
		content: "\"\""
	}
});
const genLinkStyle = (token) => ({ a: {
	color: token.colorLink,
	textDecoration: token.linkDecoration,
	backgroundColor: "transparent",
	outline: "none",
	cursor: "pointer",
	transition: `color ${token.motionDurationSlow}`,
	"-webkit-text-decoration-skip": "objects",
	"&:hover": { color: token.colorLinkHover },
	"&:active": { color: token.colorLinkActive },
	"&:active, &:hover": {
		textDecoration: token.linkHoverDecoration,
		outline: 0
	},
	"&:focus": {
		textDecoration: token.linkFocusDecoration,
		outline: 0
	},
	"&[disabled]": {
		color: token.colorTextDisabled,
		cursor: "not-allowed"
	}
} });
const genCommonStyle = (token, componentPrefixCls, rootCls, resetFont) => {
	const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
	const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
	const resetStyle = {
		boxSizing: "border-box",
		"&::before, &::after": { boxSizing: "border-box" }
	};
	let resetFontStyle = {};
	if (resetFont !== false) {
		resetFontStyle = {
			fontFamily: token.fontFamily,
			fontSize: token.fontSize
		};
	}
	return { [rootPrefixSelector]: {
		...resetFontStyle,
		...resetStyle,
		[prefixSelector]: resetStyle
	} };
};
const genFocusOutline = (token) => ({
	outline: `${unit$1(token.lineWidthFocus)} solid ${token.colorPrimaryBorder}`,
	outlineOffset: 1,
	transition: "outline-offset 0s, outline 0s"
});
const genFocusStyle = (token) => ({ "&:focus-visible": genFocusOutline(token) });
const genIconStyle = (iconPrefixCls) => ({ [`.${iconPrefixCls}`]: {
	...resetIcon(),
	[`.${iconPrefixCls} .${iconPrefixCls}-icon`]: { display: "block" }
} });
const { a: genStyleHooks, c: genComponentStyleHook, b: genSubStyleComponent } = genStyleUtils({
	c: () => {
		const { getPrefixCls, iconPrefixCls } = reactExports.useContext(ConfigContext);
		const rootPrefixCls = getPrefixCls();
		return {
			a: rootPrefixCls,
			b: iconPrefixCls
		};
	},
	b: () => {
		const [theme, realToken, hashId, token, cssVar, zeroRuntime] = useToken();
		return {
			c: theme,
			b: realToken,
			d: hashId,
			e: token,
			a: cssVar,
			f: zeroRuntime
		};
	},
	a: () => {
		const { csp } = reactExports.useContext(ConfigContext);
		return csp ?? {};
	},
	d: (token, config) => {
		const linkStyle = genLinkStyle(token);
		return [
			linkStyle,
			{ "&": linkStyle },
			genIconStyle(config.a.a ?? "anticon")
		];
	},
	e: genCommonStyle,
	f: () => unitless
});
const genCssVar = (antCls, component) => {
	const cssPrefix = `--${antCls.replace(/\./g, "")}-${component}-`;
	const varName = (name) => {
		return `${cssPrefix}${name}`;
	};
	const varRef = (name, fallback) => {
		return fallback ? `var(${cssPrefix}${"color"}, ${fallback})` : `var(${cssPrefix}${name})`;
	};
	return [varName, varRef];
};
const useResetIconStyle = (iconPrefixCls, csp) => {
	useToken();
	// Generate style for icons
	return useStyleRegister({
		hashId: "",
		path: ["ant-design-icons", iconPrefixCls],
		nonce: () => csp?.nonce,
		layer: { name: "antd" }
	}, () => genIconStyle(iconPrefixCls));
};
const IconContext = reactExports.createContext({});
function getRoot(ele) {
	return ele?.getRootNode?.();
}
/**
* Check if is in shadowRoot
*/
function inShadow(ele) {
	return getRoot(ele) instanceof ShadowRoot;
}
/**
* Return shadowRoot if possible
*/
function getShadowRoot(ele) {
	return inShadow(ele) ? getRoot(ele) : null;
}
function camelCase(input) {
	return input.replace(/-(.)/g, (__unused_359B, g) => g.toUpperCase());
}
function warning$1(valid, message) {
	warningOnce(valid, `[@ant-design/icons] ${message}`);
}
function isIconDefinition(target) {
	return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
}
function normalizeAttrs(attrs = {}) {
	return Object.keys(attrs).reduce((acc, key) => {
		const val = attrs[key];
		switch (key) {
			case "class":
				acc.className = val;
				delete acc.class;
				break;
			default:
				delete acc[key];
				acc[camelCase(key)] = val;
		}
		return acc;
	}, {});
}
function generate(node, key, rootProps) {
	if (!rootProps) {
		return React.createElement(node.tag, {
			key,
			...normalizeAttrs(node.attrs)
		}, (node.children || []).map((child, index) => generate(child, `${key}-${node.tag}-${index}`)));
	}
	return React.createElement(node.tag, {
		key,
		...normalizeAttrs(node.attrs),
		...rootProps
	}, (node.children || []).map((child, index) => generate(child, `${key}-${node.tag}-${index}`)));
}
function getSecondaryColor(primaryColor) {
	// choose the second color
	return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
	if (!twoToneColor) {
		return [];
	}
	return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
const iconStyles = "\n.anticon {\n  display: inline-flex;\n  align-items: center;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n  vertical-align: inherit;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
const useInsertStyles = (eleRef) => {
	const { csp, prefixCls, layer } = reactExports.useContext(IconContext);
	let mergedStyleStr = iconStyles;
	if (prefixCls) {
		mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
	}
	if (layer) {
		mergedStyleStr = `@layer ${layer} {
${mergedStyleStr}
}`;
	}
	reactExports.useEffect(() => {
		const ele = eleRef.current;
		const shadowRoot = getShadowRoot(ele);
		updateCSS(mergedStyleStr, "@ant-design-icons", {
			prepend: !layer,
			csp,
			attachTo: shadowRoot
		});
	}, []);
};
const twoToneColorPalette = {};
function setTwoToneColors({ primaryColor, secondaryColor }) {
	twoToneColorPalette.primaryColor = primaryColor;
	twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
	twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
	return { ...twoToneColorPalette };
}
const IconBase = (props) => {
	const { icon, className, onClick, style, primaryColor, secondaryColor, ...restProps } = props;
	const svgRef = reactExports.useRef(null);
	let colors = twoToneColorPalette;
	if (primaryColor) {
		colors = {
			primaryColor,
			secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
		};
	}
	useInsertStyles(svgRef);
	warning$1(isIconDefinition(icon), `icon should be icon definiton, but got ${icon}`);
	if (!isIconDefinition(icon)) {
		return null;
	}
	let target = icon;
	if (target && typeof target.icon === "function") {
		target = {
			...target,
			icon: target.icon(colors.primaryColor, colors.secondaryColor)
		};
	}
	return generate(target.icon, `svg-${target.name}`, {
		className,
		onClick,
		style,
		"data-icon": target.name,
		width: "1em",
		height: "1em",
		fill: "currentColor",
		"aria-hidden": "true",
		...restProps,
		ref: svgRef
	});
};
IconBase.displayName = "IconReact";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
function setTwoToneColor(twoToneColor) {
	const [primaryColor, secondaryColor] = normalizeTwoToneColors(twoToneColor);
	return IconBase.setTwoToneColors({
		primaryColor,
		secondaryColor
	});
}
function getTwoToneColor() {
	const colors = IconBase.getTwoToneColors();
	if (!colors.calculated) {
		return colors.primaryColor;
	}
	return [colors.primaryColor, colors.secondaryColor];
}
function _extends$w() {
	_extends$w = Object.assign.bind();
	return _extends$w.apply(this, arguments);
}
// Initial setting
// should move it to antd main repo?
setTwoToneColor(blue.primary);
// https://github.com/DefinitelyTyped/DefinitelyTyped/issues/34757#issuecomment-488848720
const Icon$1 = reactExports.forwardRef((props, ref) => {
	const { className, icon, spin, rotate, tabIndex, onClick, twoToneColor, ...restProps } = props;
	const { prefixCls = "anticon", rootClassName } = reactExports.useContext(IconContext);
	const classString = clsx(rootClassName, prefixCls, {
		[`${prefixCls}-${icon.name}`]: !!icon.name,
		[`${prefixCls}-spin`]: !!spin || icon.name === "loading"
	}, className);
	let iconTabIndex = tabIndex;
	if (iconTabIndex === void 0 && onClick) {
		iconTabIndex = -1;
	}
	const svgStyle = rotate ? {
		msTransform: `rotate(${rotate}deg)`,
		transform: `rotate(${rotate}deg)`
	} : void 0;
	const [primaryColor, secondaryColor] = normalizeTwoToneColors(twoToneColor);
	return reactExports.createElement("span", _extends$w({
		role: "img",
		"aria-label": icon.name
	}, restProps, {
		ref,
		tabIndex: iconTabIndex,
		onClick,
		className: classString
	}), reactExports.createElement(IconBase, {
		icon,
		primaryColor,
		secondaryColor,
		style: svgStyle
	}));
});
Icon$1.getTwoToneColor = getTwoToneColor;
Icon$1.setTwoToneColor = setTwoToneColor;
// This icon file is generated automatically.
var CloseCircleFilled$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"fill-rule": "evenodd",
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" }
		}]
	},
	"name": "close-circle",
	"theme": "filled"
};
var CloseCircleFilledSvg = CloseCircleFilled$1;
function _extends$v() {
	_extends$v = Object.assign.bind();
	return _extends$v.apply(this, arguments);
}
const CloseCircleFilled = (props, ref) => reactExports.createElement(Icon$1, _extends$v({}, props, {
	ref,
	icon: CloseCircleFilledSvg
}));
/**![close-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdmlld0JveD0iNjQgNjQgODk2IDg5NiIgZm9jdXNhYmxlPSJmYWxzZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNTEyIDY0YzI0Ny40IDAgNDQ4IDIwMC42IDQ0OCA0NDhTNzU5LjQgOTYwIDUxMiA5NjAgNjQgNzU5LjQgNjQgNTEyIDI2NC42IDY0IDUxMiA2NHptMTI3Ljk4IDI3NC44MmgtLjA0bC0uMDguMDZMNTEyIDQ2Ni43NSAzODQuMTQgMzM4Ljg4Yy0uMDQtLjA1LS4wNi0uMDYtLjA4LS4wNmEuMTIuMTIgMCAwMC0uMDcgMGMtLjAzIDAtLjA1LjAxLS4wOS4wNWwtNDUuMDIgNDUuMDJhLjIuMiAwIDAwLS4wNS4wOS4xMi4xMiAwIDAwMCAuMDd2LjAyYS4yNy4yNyAwIDAwLjA2LjA2TDQ2Ni43NSA1MTIgMzM4Ljg4IDYzOS44NmMtLjA1LjA0LS4wNi4wNi0uMDYuMDhhLjEyLjEyIDAgMDAwIC4wN2MwIC4wMy4wMS4wNS4wNS4wOWw0NS4wMiA0NS4wMmEuMi4yIDAgMDAuMDkuMDUuMTIuMTIgMCAwMC4wNyAwYy4wMiAwIC4wNC0uMDEuMDgtLjA1TDUxMiA1NTcuMjVsMTI3Ljg2IDEyNy44N2MuMDQuMDQuMDYuMDUuMDguMDVhLjEyLjEyIDAgMDAuMDcgMGMuMDMgMCAuMDUtLjAxLjA5LS4wNWw0NS4wMi00NS4wMmEuMi4yIDAgMDAuMDUtLjA5LjEyLjEyIDAgMDAwLS4wN3YtLjAyYS4yNy4yNyAwIDAwLS4wNS0uMDZMNTU3LjI1IDUxMmwxMjcuODctMTI3Ljg2Yy4wNC0uMDQuMDUtLjA2LjA1LS4wOGEuMTIuMTIgMCAwMDAtLjA3YzAtLjAzLS4wMS0uMDUtLjA1LS4wOWwtNDUuMDItNDUuMDJhLjIuMiAwIDAwLS4wOS0uMDUuMTIuMTIgMCAwMC0uMDcgMHoiIC8+PC9zdmc+) */
const RefIcon$8 = reactExports.forwardRef(CloseCircleFilled);
// This icon file is generated automatically.
var CloseOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"fill-rule": "evenodd",
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" }
		}]
	},
	"name": "close",
	"theme": "outlined"
};
var CloseOutlinedSvg = CloseOutlined$1;
function _extends$u() {
	_extends$u = Object.assign.bind();
	return _extends$u.apply(this, arguments);
}
const CloseOutlined = (props, ref) => reactExports.createElement(Icon$1, _extends$u({}, props, {
	ref,
	icon: CloseOutlinedSvg
}));
/**![close](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdmlld0JveD0iNjQgNjQgODk2IDg5NiIgZm9jdXNhYmxlPSJmYWxzZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNzk5Ljg2IDE2Ni4zMWMuMDIgMCAuMDQuMDIuMDguMDZsNTcuNjkgNTcuN2MuMDQuMDMuMDUuMDUuMDYuMDhhLjEyLjEyIDAgMDEwIC4wNmMwIC4wMy0uMDIuMDUtLjA2LjA5TDU2OS45MyA1MTJsMjg3LjcgMjg3LjdjLjA0LjA0LjA1LjA2LjA2LjA5YS4xMi4xMiAwIDAxMCAuMDdjMCAuMDItLjAyLjA0LS4wNi4wOGwtNTcuNyA1Ny42OWMtLjAzLjA0LS4wNS4wNS0uMDcuMDZhLjEyLjEyIDAgMDEtLjA3IDBjLS4wMyAwLS4wNS0uMDItLjA5LS4wNkw1MTIgNTY5LjkzbC0yODcuNyAyODcuN2MtLjA0LjA0LS4wNi4wNS0uMDkuMDZhLjEyLjEyIDAgMDEtLjA3IDBjLS4wMiAwLS4wNC0uMDItLjA4LS4wNmwtNTcuNjktNTcuN2MtLjA0LS4wMy0uMDUtLjA1LS4wNi0uMDdhLjEyLjEyIDAgMDEwLS4wN2MwLS4wMy4wMi0uMDUuMDYtLjA5TDQ1NC4wNyA1MTJsLTI4Ny43LTI4Ny43Yy0uMDQtLjA0LS4wNS0uMDYtLjA2LS4wOWEuMTIuMTIgMCAwMTAtLjA3YzAtLjAyLjAyLS4wNC4wNi0uMDhsNTcuNy01Ny42OWMuMDMtLjA0LjA1LS4wNS4wNy0uMDZhLjEyLjEyIDAgMDEuMDcgMGMuMDMgMCAuMDUuMDIuMDkuMDZMNTEyIDQ1NC4wN2wyODcuNy0yODcuN2MuMDQtLjA0LjA2LS4wNS4wOS0uMDZhLjEyLjEyIDAgMDEuMDcgMHoiIC8+PC9zdmc+) */
const RefIcon$7 = reactExports.forwardRef(CloseOutlined);
const Context$1 = reactExports.createContext({});
function MotionProvider({ children, ...props }) {
	return reactExports.createElement(Context$1.Provider, { value: props }, children);
}
/**
* Same as React.useState but will always get latest state.
* This is useful when React merge multiple state updates into one.
* e.g. onTransitionEnd trigger multiple event at once will be merged state update in React.
*/
function useSyncState$1() {
	const [, forceUpdate] = reactExports.useReducer((x) => x + 1, 0);
	const currentValueRef = reactExports.useRef("none");
	const getValue = useEvent(() => {
		return currentValueRef.current;
	});
	const setValue = useEvent((updater) => {
		currentValueRef.current = typeof updater === "function" ? updater(currentValueRef.current) : updater;
		forceUpdate();
	});
	return [getValue, setValue];
}
// ================= Transition =================
// Event wrapper. Copy from react source code
function makePrefixMap(styleProp, eventName) {
	const prefixes = {};
	prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	prefixes[`Webkit${styleProp}`] = `webkit${eventName}`;
	prefixes[`Moz${styleProp}`] = `moz${eventName}`;
	prefixes[`ms${styleProp}`] = `MS${eventName}`;
	prefixes[`O${styleProp}`] = `o${eventName.toLowerCase()}`;
	return prefixes;
}
function getVendorPrefixes(domSupport, win) {
	const prefixes = {
		a: makePrefixMap("Animation", "AnimationEnd"),
		b: makePrefixMap("Transition", "TransitionEnd")
	};
	if (domSupport) {
		if (!("AnimationEvent" in win)) {
			delete prefixes.a.animation;
		}
		if (!("TransitionEvent" in win)) {
			delete prefixes.b.transition;
		}
	}
	return prefixes;
}
const vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
let style = {};
if (canUseDom()) {
	({style: style} = document.createElement("div"));
}
const prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
	const prefixMap = vendorPrefixes[eventName];
	{
		{
			const stylePropList = Object.keys(prefixMap);
			const len = stylePropList.length;
			for (let i = 0; i < len; i += 1) {
				const styleProp = stylePropList[i];
				if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
					prefixedEventNames[eventName] = prefixMap[styleProp];
					return prefixedEventNames[eventName];
				}
			}
		}
	}
	return "";
}
const internalAnimationEndName = getVendorPrefixedEventName("a");
const internalTransitionEndName = getVendorPrefixedEventName("b");
const supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
const animationEndName = internalAnimationEndName || "animationend";
const transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName(transitionName, transitionType) {
	if (!transitionName) return null;
	if (typeof transitionName === "object") {
		const type = transitionType.replace(/-\w/g, (match) => match[1].toUpperCase());
		return transitionName[type];
	}
	return `${transitionName}-${transitionType}`;
}
var useDomMotionEvents = (onInternalMotionEnd) => {
	const cacheElementRef = reactExports.useRef();
	// Remove events
	function removeMotionEvents(element) {
		if (element) {
			element.removeEventListener(transitionEndName, onInternalMotionEnd);
			element.removeEventListener(animationEndName, onInternalMotionEnd);
		}
	}
	// Patch events
	function patchMotionEvents(element) {
		if (cacheElementRef.current && cacheElementRef.current !== element) {
			removeMotionEvents(cacheElementRef.current);
		}
		if (element && element !== cacheElementRef.current) {
			element.addEventListener(transitionEndName, onInternalMotionEnd);
			element.addEventListener(animationEndName, onInternalMotionEnd);
			// Save as cache in case dom removed trigger by `motionDeadline`
			cacheElementRef.current = element;
		}
	}
	// Clean up when removed
	reactExports.useEffect(() => () => {
		removeMotionEvents(cacheElementRef.current);
		cacheElementRef.current = null;
	}, []);
	return [patchMotionEvents, ,];
};
// It's safe to use `useLayoutEffect` but the warning is annoying
const useIsomorphicLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
var useNextFrame = () => {
	const nextFrameRef = reactExports.useRef(null);
	function cancelNextFrame() {
		wrapperRaf.a(nextFrameRef.current);
	}
	function nextFrame(callback, delay = 2) {
		cancelNextFrame();
		const nextFrameId = wrapperRaf(() => {
			if (delay <= 1) {
				callback({ a: () => nextFrameId !== nextFrameRef.current });
			} else {
				nextFrame(callback, 1);
			}
		});
		nextFrameRef.current = nextFrameId;
	}
	reactExports.useEffect(() => () => {
		cancelNextFrame();
	}, []);
	return [nextFrame, cancelNextFrame];
};
const FULL_STEP_QUEUE = [
	"prepare",
	"start",
	"active",
	"end"
];
const SIMPLE_STEP_QUEUE = ["prepare", "prepared"];
function isActive(step) {
	return step === "active" || step === "end";
}
var useStepQueue = (status, prepareOnly, callback) => {
	const [step, setStep] = useSafeState("none");
	const [nextFrame, cancelNextFrame] = useNextFrame();
	function startQueue() {
		setStep("prepare", true);
	}
	const STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
	useIsomorphicLayoutEffect(() => {
		if (step !== "none" && step !== "end") {
			const index = STEP_QUEUE.indexOf(step);
			const nextStep = STEP_QUEUE[index + 1];
			const result = callback(step);
			if (result === false) {
				// Skip when no needed
				setStep(nextStep, true);
			} else if (nextStep) {
				// Do as frame for step update
				nextFrame((info) => {
					function doNext() {
						// Skip since current queue is ood
						if (info.a()) return;
						setStep(nextStep, true);
					}
					if (result === true) {
						doNext();
					} else {
						// Only promise should be async
						Promise.resolve(result).then(doNext);
					}
				});
			}
		}
	}, [status, step]);
	reactExports.useEffect(() => () => {
		cancelNextFrame();
	}, []);
	return [startQueue, step];
};
function useStatus(supportMotion, visible, getElement, { motionEnter = true, motionAppear = true, motionLeave = true, motionDeadline, motionLeaveImmediately, onAppearPrepare, onEnterPrepare, onLeavePrepare, onAppearStart, onEnterStart, onLeaveStart, onAppearActive, onEnterActive, onLeaveActive, onAppearEnd, onEnterEnd, onLeaveEnd, onVisibleChanged }) {
	// Used for outer render usage to avoid `visible: false & status: none` to render nothing
	const [asyncVisible, setAsyncVisible] = useSafeState();
	const [getStatus, setStatus] = useSyncState$1();
	const [style, setStyle] = useSafeState(null);
	const currentStatus = getStatus();
	const mountedRef = reactExports.useRef(false);
	const deadlineRef = reactExports.useRef(null);
	// =========================== Dom Node ===========================
	function getDomElement() {
		return getElement();
	}
	// ========================== Motion End ==========================
	const activeRef = reactExports.useRef(false);
	/**
	* Clean up status & style
	*/
	function updateMotionEndStatus() {
		setStatus("none");
		setStyle(null, true);
	}
	const onInternalMotionEnd = useEvent((event) => {
		const status = getStatus();
		// Do nothing since not in any transition status.
		// This may happen when `motionDeadline` trigger.
		if (status === "none") {
			return;
		}
		const element = getDomElement();
		if (event && !event.deadline && event.target !== element) {
			// event exists
			// not initiated by deadline
			// transitionEnd not fired by inner elements
			return;
		}
		const currentActive = activeRef.current;
		let canEnd;
		if (status === "appear" && currentActive) {
			canEnd = onAppearEnd?.(element, event);
		} else if (status === "enter" && currentActive) {
			canEnd = onEnterEnd?.(element, event);
		} else if (status === "leave" && currentActive) {
			canEnd = onLeaveEnd?.(element, event);
		}
		// Only update status when `canEnd` and not destroyed
		if (currentActive && canEnd !== false) {
			updateMotionEndStatus();
		}
	});
	const [patchMotionEvents] = useDomMotionEvents(onInternalMotionEnd);
	// ============================= Step =============================
	const getEventHandlers = (targetStatus) => {
		switch (targetStatus) {
			case "appear": return {
				["prepare"]: onAppearPrepare,
				["start"]: onAppearStart,
				["active"]: onAppearActive
			};
			case "enter": return {
				["prepare"]: onEnterPrepare,
				["start"]: onEnterStart,
				["active"]: onEnterActive
			};
			case "leave": return {
				["prepare"]: onLeavePrepare,
				["start"]: onLeaveStart,
				["active"]: onLeaveActive
			};
			default: return {};
		}
	};
	const eventHandlers = reactExports.useMemo(() => getEventHandlers(currentStatus), [currentStatus]);
	const [startStep, step] = useStepQueue(currentStatus, !supportMotion, (newStep) => {
		// Only prepare step can be skip
		if (newStep === "prepare") {
			const onPrepare = eventHandlers["prepare"];
			if (!onPrepare) {
				return false;
			}
			return onPrepare(getDomElement());
		}
		// Rest step is sync update
		if (step in eventHandlers) {
			setStyle(eventHandlers[step]?.(getDomElement(), null) || null);
		}
		if (step === "active" && currentStatus !== "none") {
			// Patch events when motion needed
			patchMotionEvents(getDomElement());
			if (motionDeadline > 0) {
				clearTimeout(deadlineRef.current);
				deadlineRef.current = setTimeout(() => {
					onInternalMotionEnd({ deadline: true });
				}, motionDeadline);
			}
		}
		if (step === "prepared") {
			updateMotionEndStatus();
		}
		return true;
	});
	const active = isActive(step);
	activeRef.current = active;
	// ============================ Status ============================
	const visibleRef = reactExports.useRef(null);
	// Update with new status
	useIsomorphicLayoutEffect(() => {
		// When use Suspense, the `visible` will repeat trigger,
		// But not real change of the `visible`, we need to skip it.
		// https://github.com/ant-design/ant-design/issues/44379
		if (mountedRef.current && visibleRef.current === visible) {
			return;
		}
		setAsyncVisible(visible);
		const isMounted = mountedRef.current;
		mountedRef.current = true;
		// if (!supportMotion) {
		//   return;
		// }
		let nextStatus;
		// Appear
		if (!isMounted && visible && motionAppear) {
			nextStatus = "appear";
		}
		// Enter
		if (isMounted && visible && motionEnter) {
			nextStatus = "enter";
		}
		// Leave
		if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
			nextStatus = "leave";
		}
		const nextEventHandlers = getEventHandlers(nextStatus);
		// Update to next status
		if (nextStatus && (supportMotion || nextEventHandlers["prepare"])) {
			setStatus(nextStatus);
			startStep();
		} else {
			// Set back in case no motion but prev status has prepare step
			setStatus("none");
		}
		visibleRef.current = visible;
	}, [visible]);
	// ============================ Effect ============================
	// Reset when motion changed
	reactExports.useEffect(() => {
		if (currentStatus === "appear" && !motionAppear || currentStatus === "enter" && !motionEnter || currentStatus === "leave" && !motionLeave) {
			setStatus("none");
		}
	}, [
		motionAppear,
		motionEnter,
		motionLeave
	]);
	reactExports.useEffect(() => () => {
		mountedRef.current = false;
		clearTimeout(deadlineRef.current);
	}, []);
	// Trigger `onVisibleChanged`
	const firstMountChangeRef = reactExports.useRef(false);
	reactExports.useEffect(() => {
		// [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged
		if (asyncVisible) {
			firstMountChangeRef.current = true;
		}
		if (asyncVisible !== void 0 && currentStatus === "none") {
			// Skip first render is invisible since it's nothing changed
			if (firstMountChangeRef.current || asyncVisible) {
				onVisibleChanged?.(asyncVisible);
			}
			firstMountChangeRef.current = true;
		}
	}, [asyncVisible, currentStatus]);
	// ============================ Styles ============================
	let mergedStyle = style;
	if (eventHandlers["prepare"] && step === "start") {
		mergedStyle = {
			transition: "none",
			...mergedStyle
		};
	}
	return [
		getStatus,
		step,
		mergedStyle,
		asyncVisible ?? visible
	];
}
/* eslint-disable react/default-props-match-prop-types, react/no-multi-comp, react/prop-types */
/**
* `transitionSupport` is used for none transition test case.
* Default we use browser transition event support check.
*/
function genCSSMotion(config) {
	let transitionSupport = config;
	function isSupportTransition(props, contextMotion) {
		return !!(props.motionName && transitionSupport && contextMotion !== false);
	}
	const CSSMotion = reactExports.forwardRef((props, ref) => {
		const { visible = true, removeOnLeave = true, forceRender, children, motionName, leavedClassName, eventProps } = props;
		const { motion: contextMotion } = reactExports.useContext(Context$1);
		const supportMotion = isSupportTransition(props, contextMotion);
		// Ref to the react node, it may be a HTMLElement
		const nodeRef = reactExports.useRef();
		function getDomElement() {
			return getDOM(nodeRef.current);
		}
		const [getStatus, statusStep, statusStyle, mergedVisible] = useStatus(supportMotion, visible, getDomElement, props);
		const status = getStatus();
		// Record whether content has rendered
		// Will return null for un-rendered even when `removeOnLeave={false}`
		const renderedRef = reactExports.useRef(mergedVisible);
		if (mergedVisible) {
			renderedRef.current = true;
		}
		// ====================== Refs ======================
		const refObj = reactExports.useMemo(() => {
			const obj = {};
			Object.defineProperties(obj, {
				nativeElement: {
					enumerable: true,
					get: getDomElement
				},
				inMotion: {
					enumerable: true,
					get: () => () => getStatus() !== "none"
				},
				enableMotion: {
					enumerable: true,
					get: () => () => supportMotion
				}
			});
			return obj;
		}, []);
		// We lock `deps` here since function return object
		// will repeat trigger ref from `refConfig` -> `null` -> `refConfig`
		reactExports.useImperativeHandle(ref, () => refObj, []);
		// ===================== Render =====================
		let motionChildren;
		const mergedProps = {
			...eventProps,
			visible
		};
		if (!children) {
			// No children
			motionChildren = null;
		} else if (status === "none") {
			// Stable children
			if (mergedVisible) {
				motionChildren = children({ ...mergedProps }, nodeRef);
			} else if (!removeOnLeave && renderedRef.current && leavedClassName) {
				motionChildren = children({
					...mergedProps,
					className: leavedClassName
				}, nodeRef);
			} else if (forceRender || !removeOnLeave && !leavedClassName) {
				motionChildren = children({
					...mergedProps,
					style: { display: "none" }
				}, nodeRef);
			} else {
				motionChildren = null;
			}
		} else {
			// In motion
			let statusSuffix;
			if (statusStep === "prepare") {
				statusSuffix = "prepare";
			} else if (isActive(statusStep)) {
				statusSuffix = "active";
			} else if (statusStep === "start") {
				statusSuffix = "start";
			}
			const motionCls = getTransitionName(motionName, `${status}-${statusSuffix}`);
			motionChildren = children({
				...mergedProps,
				className: clsx(getTransitionName(motionName, status), {
					[motionCls]: motionCls && statusSuffix,
					[motionName]: typeof motionName === "string"
				}),
				style: statusStyle
			}, nodeRef);
		}
		// Auto inject ref if child node not have `ref` props
		if (reactExports.isValidElement(motionChildren) && supportRef(motionChildren)) {
			const originNodeRef = getNodeRef(motionChildren);
			if (!originNodeRef) {
				motionChildren = reactExports.cloneElement(motionChildren, { ref: nodeRef });
			}
		}
		return motionChildren;
	});
	CSSMotion.displayName = "CSSMotion";
	return CSSMotion;
}
var CSSMotion = genCSSMotion(supportTransition);
const attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
const eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
const propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
function match(key, prefix) {
	return key.indexOf(prefix) === 0;
}
/**
* Picker props from exist props with filter
* @param props Passed props
* @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
*/
function pickAttrs(props, ariaOnly) {
	let mergedConfig;
	if (ariaOnly === false) {
		mergedConfig = { a: true };
	} else {
		{
			mergedConfig = { ...ariaOnly };
		}
	}
	const attrs = {};
	Object.keys(props).forEach((key) => {
		if (key === "role" || match(key, "aria-") || match(key, "data-") || mergedConfig.a && propList.includes(key)) {
			attrs[key] = props[key];
		}
	});
	return attrs;
}
var commonLocale = {
	yearFormat: "YYYY",
	dayFormat: "D",
	cellMeridiemFormat: "A",
	monthBeforeYear: true
};
function _typeof$t(o) {
	"@babel/helpers - typeof";
	return _typeof$t = function(o) {
		return typeof o;
	}, _typeof$t(o);
}
function ownKeys$h(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$h(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$h(Object(t), true).forEach(function(r) {
			_defineProperty$r(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$r(obj, key, value) {
	key = _toPropertyKey$r(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$r(t) {
	var i = _toPrimitive$r(t);
	return "symbol" == _typeof$t(i) ? i : String(i);
}
function _toPrimitive$r(t) {
	if ("object" != _typeof$t(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$t(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
var locale$2 = _objectSpread$h(_objectSpread$h({}, commonLocale), {}, {
	locale: "en_US",
	today: "Today",
	now: "Now",
	backToToday: "Back to today",
	ok: "OK",
	clear: "Clear",
	week: "Week",
	month: "Month",
	year: "Year",
	timeSelect: "select time",
	dateSelect: "select date",
	weekSelect: "Choose a week",
	monthSelect: "Choose a month",
	yearSelect: "Choose a year",
	decadeSelect: "Choose a decade",
	previousMonth: "Previous month (PageUp)",
	nextMonth: "Next month (PageDown)",
	previousYear: "Last year (Control + left)",
	nextYear: "Next year (Control + right)",
	previousDecade: "Last decade",
	nextDecade: "Next decade",
	previousCentury: "Last century",
	nextCentury: "Next century"
});
var CalendarLocale = locale$2;
const locale$1 = {
	placeholder: "Select time",
	rangePlaceholder: ["Start time", "End time"]
};
// Merge into a locale object
const locale = {
	lang: {
		placeholder: "Select date",
		yearPlaceholder: "Select year",
		quarterPlaceholder: "Select quarter",
		monthPlaceholder: "Select month",
		weekPlaceholder: "Select week",
		rangePlaceholder: ["Start date", "End date"],
		rangeYearPlaceholder: ["Start year", "End year"],
		rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
		rangeMonthPlaceholder: ["Start month", "End month"],
		rangeWeekPlaceholder: ["Start week", "End week"],
		...CalendarLocale
	},
	timePickerLocale: { ...locale$1 }
};
const typeTemplate$1 = "${label} is not a valid ${type}";
const localeValues = {
	a: {
		okText: "OK",
		cancelText: "Cancel",
		justOkText: "OK"
	},
	b: { a: {
		default: "Field validation error for ${label}",
		required: "Please enter ${label}",
		enum: "${label} must be one of [${enum}]",
		whitespace: "${label} cannot be a blank character",
		date: {
			format: "${label} date format is invalid",
			parse: "${label} cannot be converted to a date",
			invalid: "${label} is an invalid date"
		},
		types: {
			string: typeTemplate$1,
			method: typeTemplate$1,
			array: typeTemplate$1,
			object: typeTemplate$1,
			number: typeTemplate$1,
			date: typeTemplate$1,
			boolean: typeTemplate$1,
			integer: typeTemplate$1,
			float: typeTemplate$1,
			regexp: typeTemplate$1,
			email: typeTemplate$1,
			url: typeTemplate$1,
			hex: typeTemplate$1
		},
		string: {
			len: "${label} must be ${len} characters",
			min: "${label} must be at least ${min} characters",
			max: "${label} must be up to ${max} characters",
			range: "${label} must be between ${min}-${max} characters"
		},
		number: {
			len: "${label} must be equal to ${len}",
			min: "${label} must be minimum ${min}",
			max: "${label} must be maximum ${max}",
			range: "${label} must be between ${min}-${max}"
		},
		array: {
			len: "Must be ${len} ${label}",
			min: "At least ${min} ${label}",
			max: "At most ${max} ${label}",
			range: "The amount of ${label} must be between ${min}-${max}"
		},
		pattern: { mismatch: "${label} does not match the pattern ${pattern}" }
	} }
};
let localeList = [];
const generateLocale = () => localeList.reduce((merged, locale) => ({
	...merged,
	...locale
}), localeValues.a);
function changeConfirmLocale(newLocale) {
	if (newLocale) {
		const cloneLocale = { ...newLocale };
		localeList.push(cloneLocale);
		generateLocale();
		return () => {
			localeList = localeList.filter((locale) => locale !== cloneLocale);
			generateLocale();
		};
	}
}
const LocaleContext = reactExports.createContext(void 0);
const useLocale$1 = (componentName, defaultLocale) => {
	const fullLocale = reactExports.useContext(LocaleContext);
	const getLocale = reactExports.useMemo(() => {
		const locale = defaultLocale;
		const localeFromContext = fullLocale?.[componentName] ?? {};
		return {
			...locale,
			...localeFromContext || {}
		};
	}, [
		componentName,
		defaultLocale,
		fullLocale
	]);
	const __unused_997B = reactExports.useMemo(() => {
		const localeCode = fullLocale?.locale;
		// Had use LocaleProvide but didn't set locale
		if (fullLocale?.exist && !localeCode) {
			return "en";
		}
		return localeCode;
	}, [fullLocale]);
	return [getLocale, ,];
};
const LocaleProvider = (props) => {
	const { locale = {}, children } = props;
	reactExports.useEffect(() => {
		const clearLocale = changeConfirmLocale(locale.Modal);
		return clearLocale;
	}, [locale]);
	const getMemoizedContextValue = reactExports.useMemo(() => ({
		...locale,
		exist: true
	}), [locale]);
	return reactExports.createElement(LocaleContext.Provider, { value: getMemoizedContextValue }, children);
};
// \b([A-Za-z_$][\w$]*)\s*!==\s*(?:undefined\s*&&\s*\1\s*!==\s*null|null\s*&&\s*\1\s*!==\s*undefined)\b
// \b([A-Za-z_$][\w$\.]*)\s*===\s*(?:undefined|null)\s*\|\|\s*\1\s*===\s*(?:undefined|null)\b
const isNonNullable = (val) => {
	return val !== void 0 && val !== null;
};
// ========================= ClassNames =========================
const mergeClassNames = (schema, ...classNames) => {
	const mergedSchema = schema || {};
	return classNames.filter(Boolean).reduce((acc, cur) => {
		// Loop keys of the current classNames
		Object.keys(cur || {}).forEach((key) => {
			const keySchema = mergedSchema[key];
			const curVal = cur[key];
			if (keySchema && typeof keySchema === "object") {
				if (curVal && typeof curVal === "object") {
					// Loop fill
					acc[key] = mergeClassNames(keySchema, acc[key], curVal);
				} else {
					// Covert string to object structure
					const { _default: defaultField } = keySchema;
					if (defaultField) {
						acc[key] = acc[key] || {};
						acc[key][defaultField] = clsx(acc[key][defaultField], curVal);
					}
				}
			} else {
				// Flatten fill
				acc[key] = clsx(acc[key], curVal);
			}
		});
		return acc;
	}, {});
};
const useSemanticClassNames = (schema, ...classNames) => {
	return reactExports.useMemo(() => mergeClassNames.apply(0, [schema].concat(classNames)), [schema].concat(classNames));
};
// =========================== Styles ===========================
const mergeStyles = (...styles) => {
	return styles.filter(Boolean).reduce((acc, cur = {}) => {
		Object.keys(cur).forEach((key) => {
			acc[key] = {
				...acc[key],
				...cur[key]
			};
		});
		return acc;
	}, {});
};
const useSemanticStyles = (...styles) => {
	return reactExports.useMemo(() => mergeStyles.apply(0, styles), [].concat(styles));
};
// =========================== Export ===========================
const fillObjectBySchema = (obj, schema) => {
	const newObj = { ...obj };
	Object.keys(schema).forEach((key) => {
		if (key !== "_default") {
			const nestSchema = schema[key];
			const nextValue = newObj[key] || {};
			newObj[key] = nestSchema ? fillObjectBySchema(nextValue, nestSchema) : nextValue;
		}
	});
	return newObj;
};
const resolveStyleOrClass = (value, info) => {
	return typeof value === "function" ? value(info) : value;
};
/**
* @desc Merge classNames and styles from multiple sources. When `schema` is provided, it **must** provide the nest object structure.
* @descZH  classNames  styles `schema` 
*/
const useMergeSemantic = (classNamesList, stylesList, info, schema) => {
	const resolvedClassNamesList = classNamesList.map((classNames) => classNames ? resolveStyleOrClass(classNames, info) : void 0);
	const resolvedStylesList = stylesList.map((styles) => styles ? resolveStyleOrClass(styles, info) : void 0);
	const mergedClassNames = useSemanticClassNames.apply(0, [schema].concat(_toConsumableArray$8(resolvedClassNamesList)));
	const mergedStyles = useSemanticStyles.apply(0, _toConsumableArray$8(resolvedStylesList));
	return reactExports.useMemo(() => {
		if (!schema) {
			return [mergedClassNames, mergedStyles];
		}
		return [fillObjectBySchema(mergedClassNames, schema), fillObjectBySchema(mergedStyles, schema)];
	}, [
		mergedClassNames,
		mergedStyles,
		schema
	]);
};
const zIndexContext = React.createContext(void 0);
const containerBaseZIndexOffset = {
	Modal: 100,
	Drawer: 100,
	Popover: 100,
	Popconfirm: 100,
	Tooltip: 100,
	Tour: 100,
	FloatButton: 100
};
const isContainerType = () => {
	return "DatePicker" in containerBaseZIndexOffset;
};
const useZIndex = (__unused_A188, customZIndex) => {
	const [, token] = useToken();
	const parentZIndex = React.useContext(zIndexContext);
	const isContainer = isContainerType();
	let result;
	if (customZIndex !== void 0) {
		result = [customZIndex, ,];
	} else {
		let zIndex = parentZIndex ?? 0;
		if (isContainer) {
			zIndex += (parentZIndex ? 0 : token.zIndexPopupBase) + containerBaseZIndexOffset["DatePicker"];
		} else {
			zIndex += 50;
		}
		result = [parentZIndex === void 0 ? customZIndex : zIndex, ,];
	}
	return result;
};
/**
* This hook is only for cssVar to add root className for components.
* If root ClassName is needed, this hook could be refactored with `-root`
* @param prefixCls
*/
const useCSSVarCls = (prefixCls) => `${prefixCls}-css-var`;
// ZombieJ: We export single file here since
// ConfigProvider use this which will make loop deps
// to import whole `rc-component/form`
var ValidateMessagesContext = reactExports.createContext(void 0);
var reactDomExports = requireReactDom();
const OrderContext = reactExports.createContext(null);
const EMPTY_LIST$1 = [];
/**
* Will add `div` to document. Nest call will keep order
* @param render Render DOM in document
*/
function useDom(render) {
	const [ele] = reactExports.useState(() => {
		if (!canUseDom()) {
			return null;
		}
		const defaultEle = document.createElement("div");
		return defaultEle;
	});
	// ========================== Order ==========================
	const appendedRef = reactExports.useRef(false);
	const queueCreate = reactExports.useContext(OrderContext);
	const [queue, setQueue] = reactExports.useState(EMPTY_LIST$1);
	const mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : (appendFn) => {
		setQueue((origin) => {
			const newQueue = [appendFn, ...origin];
			return newQueue;
		});
	});
	// =========================== DOM ===========================
	function append() {
		if (!ele.parentElement) {
			document.body.appendChild(ele);
		}
		appendedRef.current = true;
	}
	function cleanup() {
		ele.parentElement?.removeChild(ele);
		appendedRef.current = false;
	}
	useLayoutEffect(() => {
		if (render) {
			if (queueCreate) {
				queueCreate(append);
			} else {
				append();
			}
		} else {
			cleanup();
		}
		return cleanup;
	}, [render]);
	useLayoutEffect(() => {
		if (queue.length) {
			queue.forEach((appendFn) => appendFn());
			setQueue(EMPTY_LIST$1);
		}
	}, [queue]);
	return [ele, mergedQueueCreate];
}
/* eslint-disable no-param-reassign */
function measureScrollbarSize(ele) {
	const randomId = `rc-scrollbar-measure-${Math.random().toString(36).substring(7)}`;
	const measureEle = document.createElement("div");
	measureEle.id = randomId;
	// Create Style
	const measureStyle = measureEle.style;
	measureStyle.position = "absolute";
	measureStyle.left = "0";
	measureStyle.top = "0";
	measureStyle.width = "100px";
	measureStyle.height = "100px";
	measureStyle.overflow = "scroll";
	// Clone Style if needed
	let fallbackWidth;
	if (ele) {
		const targetStyle = getComputedStyle(ele);
		measureStyle.scrollbarColor = targetStyle.scrollbarColor;
		measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
		// Set Webkit style
		const webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar");
		const width = parseInt(webkitScrollbarStyle.width, 10);
		const height = parseInt(webkitScrollbarStyle.height, 10);
		// Try wrap to handle CSP case
		try {
			const widthStyle = width ? `width: ${webkitScrollbarStyle.width};` : "";
			const heightStyle = height ? `height: ${webkitScrollbarStyle.height};` : "";
			updateCSS(`
#${randomId}::-webkit-scrollbar {
${widthStyle}
${heightStyle}
}`, randomId);
		} catch (e) {
			// Can't wrap, just log error
			console.error(e);
			// Get from style directly
			fallbackWidth = width;
		}
	}
	document.body.appendChild(measureEle);
	// Measure. Get fallback style if provided
	const scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
	// Clean up
	document.body.removeChild(measureEle);
	removeCSS(randomId);
	return { a: scrollWidth };
}
function getTargetScrollBarSize(target) {
	if (typeof document === "undefined" || !target || !(target instanceof Element)) {
		return { a: 0 };
	}
	return measureScrollbarSize(target);
}
/**
* Test usage export. Do not use in your production
*/
function isBodyOverflowing() {
	return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
const UNIQUE_ID = `rc-util-locker-${Date.now()}`;
let uuid$1 = 0;
function useScrollLocker(lock) {
	const mergedLock = !!lock;
	const [id] = reactExports.useState(() => {
		uuid$1 += 1;
		return `${UNIQUE_ID}_${uuid$1}`;
	});
	useLayoutEffect(() => {
		if (mergedLock) {
			const scrollbarSize = getTargetScrollBarSize(document.body).a;
			const isOverflow = isBodyOverflowing();
			updateCSS(`
html body {
  overflow-y: hidden;
  ${isOverflow ? `width: calc(100% - ${scrollbarSize}px);` : ""}
}`, id);
		} else {
			removeCSS(id);
		}
		return () => {
			removeCSS(id);
		};
	}, [mergedLock, id]);
}
function getUseId() {
	// We need fully clone React function here to avoid webpack warning React 17 do not export `useId`
	const fullClone = { ...React$1 };
	return fullClone.useId;
}
let uuid = 0;
const useOriginId = getUseId();
var useId = useOriginId ? function() {
	const reactId = useOriginId();
	return reactId;
} : function() {
	// Inner id for accessibility usage. Only work in client side
	const [innerId, setInnerId] = reactExports.useState("ssr-id");
	reactExports.useEffect(() => {
		const nextId = uuid;
		uuid += 1;
		setInnerId(`rc_unique_${nextId}`);
	}, []);
	// Return react native id or inner id
	return innerId;
};
let stack = [];
let lastCompositionEndTime = 0;
// Global event handlers
const onGlobalKeyDown = (event) => {
	if (event.key === "Escape" && !event.isComposing) {
		const now = Date.now();
		if (now - lastCompositionEndTime < 200) {
			return;
		}
		const len = stack.length;
		for (let i = len - 1; i >= 0; i -= 1) {
			stack[i].onEsc({
				top: i === len - 1,
				event
			});
		}
	}
};
const onGlobalCompositionEnd = () => {
	lastCompositionEndTime = Date.now();
};
function attachGlobalEventListeners() {
	window.addEventListener("keydown", onGlobalKeyDown);
	window.addEventListener("compositionend", onGlobalCompositionEnd);
}
function detachGlobalEventListeners() {
	if (stack.length === 0) {
		window.removeEventListener("keydown", onGlobalKeyDown);
		window.removeEventListener("compositionend", onGlobalCompositionEnd);
	}
}
function useEscKeyDown(open, onEsc) {
	const id = useId();
	const onEventEsc = useEvent(onEsc);
	const ensure = () => {
		if (!stack.find((item) => item.id === id)) {
			stack.push({
				id,
				onEsc: onEventEsc
			});
		}
	};
	const clear = () => {
		stack = stack.filter((item) => item.id !== id);
	};
	reactExports.useMemo(() => {
		if (open) {
			ensure();
		} else if (!open) {
			clear();
		}
	}, [open]);
	reactExports.useEffect(() => {
		if (open) {
			ensure();
			// Attach global event listeners
			attachGlobalEventListeners();
			return () => {
				clear();
				// Remove global event listeners if instances is empty
				detachGlobalEventListeners();
			};
		}
	}, [open]);
}
const getPortalContainer = (getContainer) => {
	if (getContainer === false) {
		return false;
	}
	if (!canUseDom() || !getContainer) {
		return null;
	}
	if (typeof getContainer === "string") {
		return document.querySelector(getContainer);
	}
	if (typeof getContainer === "function") {
		return getContainer();
	}
	return getContainer;
};
const Portal = reactExports.forwardRef((props, ref) => {
	const { open, autoLock, getContainer, autoDestroy = true, children, onEsc } = props;
	const [shouldRender, setShouldRender] = reactExports.useState(open);
	const mergedRender = shouldRender || open;
	// ====================== Should Render ======================
	reactExports.useEffect(() => {
		if (autoDestroy || open) {
			setShouldRender(open);
		}
	}, [open, autoDestroy]);
	// ======================== Container ========================
	const [innerContainer, setInnerContainer] = reactExports.useState(() => getPortalContainer(getContainer));
	reactExports.useEffect(() => {
		const customizeContainer = getPortalContainer(getContainer);
		// Tell component that we check this in effect which is safe to be `null`
		setInnerContainer(() => customizeContainer ?? null);
	});
	const [defaultContainer, queueCreate] = useDom(mergedRender && !innerContainer);
	const mergedContainer = innerContainer ?? defaultContainer;
	// ========================= Locker ==========================
	useScrollLocker(autoLock && open && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body));
	// ========================= Esc Keydown ==========================
	useEscKeyDown(open, onEsc);
	// =========================== Ref ===========================
	let childRef = null;
	if (children && supportRef(children) && ref) {
		childRef = getNodeRef(children);
	}
	const mergedRef = useComposeRef(childRef, ref);
	// ========================= Render ==========================
	// Do not render when nothing need render
	// When innerContainer is `undefined`, it may not ready since user use ref in the same render
	if (!mergedRender || !canUseDom() || innerContainer === void 0) {
		return null;
	}
	// Render inline
	const renderInline = mergedContainer === false || false;
	let reffedChildren = children;
	if (ref) {
		reffedChildren = reactExports.cloneElement(children, { ref: mergedRef });
	}
	return reactExports.createElement(OrderContext.Provider, { value: queueCreate }, renderInline ? reffedChildren : reactDomExports.b(reffedChildren, mergedContainer));
});
function Arrow(props) {
	const { prefixCls, align, arrow, arrowPos } = props;
	const { className, content, style } = arrow || {};
	const { x = 0, y = 0 } = arrowPos;
	const arrowRef = reactExports.useRef(null);
	// Skip if no align
	if (!align || !align.points) {
		return null;
	}
	const alignStyle = { position: "absolute" };
	// Skip if no need to align
	if (align.autoArrow !== false) {
		const popupPoints = align.points[0];
		const targetPoints = align.points[1];
		const popupTB = popupPoints[0];
		const popupLR = popupPoints[1];
		const targetTB = targetPoints[0];
		const targetLR = targetPoints[1];
		// Top & Bottom
		if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
			alignStyle.top = y;
		} else if (popupTB === "t") {
			alignStyle.top = 0;
		} else {
			alignStyle.bottom = 0;
		}
		// Left & Right
		if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
			alignStyle.left = x;
		} else if (popupLR === "l") {
			alignStyle.left = 0;
		} else {
			alignStyle.right = 0;
		}
	}
	return reactExports.createElement("div", {
		ref: arrowRef,
		className: clsx(`${prefixCls}-arrow`, className),
		style: {
			...alignStyle,
			...style
		}
	}, content);
}
function _extends$t() {
	_extends$t = Object.assign.bind();
	return _extends$t.apply(this, arguments);
}
function Mask(props) {
	const { prefixCls, open, zIndex, mask, motion, mobile } = props;
	if (!mask) {
		return null;
	}
	return reactExports.createElement(CSSMotion, _extends$t({}, motion, {
		motionAppear: true,
		visible: open,
		removeOnLeave: true
	}), ({ className }) => reactExports.createElement("div", {
		style: { zIndex },
		className: clsx(`${prefixCls}-mask`, mobile && `${prefixCls}-mobile-mask`, className)
	}));
}
const PopupContent = reactExports.memo(({ children }) => children, (__unused_578F, next) => next.cache);
function useOffsetStyle(isMobile, ready, open, align, offsetR, offsetB, offsetX, offsetY) {
	const offsetStyle = isMobile ? {} : {
		left: "-1000vw",
		top: "-1000vh",
		right: "auto",
		bottom: "auto"
	};
	// Set align style
	if (!isMobile && (ready || !open)) {
		const { points } = align;
		const dynamicInset = align.dynamicInset || align._experimental?.dynamicInset;
		const alignRight = dynamicInset && points[0][1] === "r";
		const alignBottom = dynamicInset && points[0][0] === "b";
		if (alignRight) {
			offsetStyle.right = offsetR;
			offsetStyle.left = "auto";
		} else {
			offsetStyle.left = offsetX;
			offsetStyle.right = "auto";
		}
		if (alignBottom) {
			offsetStyle.bottom = offsetB;
			offsetStyle.top = "auto";
		} else {
			offsetStyle.top = offsetY;
			offsetStyle.bottom = "auto";
		}
	}
	return offsetStyle;
}
function _extends$s() {
	_extends$s = Object.assign.bind();
	return _extends$s.apply(this, arguments);
}
const Popup$1 = reactExports.forwardRef((props, ref) => {
	const { onEsc, popup, className, prefixCls, style, target, onVisibleChanged, open, keepDom, fresh, onClick, mask, arrow, arrowPos, align, motion, maskMotion, mobile, forceRender, getPopupContainer, autoDestroy, portal: Portal, children, zIndex, onMouseEnter, onMouseLeave, onPointerEnter, onPointerDownCapture, ready, offsetX, offsetY, offsetR, offsetB, onAlign, onPrepare, onResize, stretch, targetWidth, targetHeight } = props;
	const popupContent = typeof popup === "function" ? popup() : popup;
	// We can not remove holder only when motion finished.
	const isNodeVisible = open || keepDom;
	// ========================= Mobile =========================
	const isMobile = !!mobile;
	// ========================== Mask ==========================
	const [mergedMask, mergedMaskMotion, mergedPopupMotion] = reactExports.useMemo(() => {
		if (mobile) {
			return [
				mobile.mask,
				mobile.maskMotion,
				mobile.motion
			];
		}
		return [
			mask,
			maskMotion,
			motion
		];
	}, [
		mobile,
		mask,
		maskMotion,
		motion
	]);
	// ======================= Container ========================
	const getPopupContainerNeedParams = getPopupContainer?.length > 0;
	const [show, setShow] = reactExports.useState(!getPopupContainer || !getPopupContainerNeedParams);
	// Delay to show since `getPopupContainer` need target element
	useLayoutEffect(() => {
		if (!show && getPopupContainerNeedParams && target) {
			setShow(true);
		}
	}, [
		show,
		getPopupContainerNeedParams,
		target
	]);
	// ========================= Resize =========================
	const onInternalResize = useEvent((size, ele) => {
		onResize?.(size, ele);
		onAlign();
	});
	// ========================= Styles =========================
	const offsetStyle = useOffsetStyle(isMobile, ready, open, align, offsetR, offsetB, offsetX, offsetY);
	// ========================= Render =========================
	if (!show) {
		return null;
	}
	// >>>>> Misc
	const miscStyle = {};
	if (stretch) {
		if (stretch.includes("height") && targetHeight) {
			miscStyle.height = targetHeight;
		} else if (stretch.includes("minHeight") && targetHeight) {
			miscStyle.minHeight = targetHeight;
		}
		if (stretch.includes("width") && targetWidth) {
			miscStyle.width = targetWidth;
		} else if (stretch.includes("minWidth") && targetWidth) {
			miscStyle.minWidth = targetWidth;
		}
	}
	if (!open) {
		miscStyle.pointerEvents = "none";
	}
	return reactExports.createElement(Portal, {
		open: forceRender || isNodeVisible,
		getContainer: getPopupContainer && (() => getPopupContainer(target)),
		autoDestroy,
		onEsc
	}, reactExports.createElement(Mask, {
		prefixCls,
		open,
		zIndex,
		mask: mergedMask,
		motion: mergedMaskMotion,
		mobile: isMobile
	}), reactExports.createElement(RefResizeObserver, {
		onResize: onInternalResize,
		disabled: !open
	}, (resizeObserverRef) => {
		return reactExports.createElement(CSSMotion, _extends$s({
			motionAppear: true,
			motionEnter: true,
			motionLeave: true,
			removeOnLeave: false,
			forceRender,
			leavedClassName: `${prefixCls}-hidden`
		}, mergedPopupMotion, {
			onAppearPrepare: onPrepare,
			onEnterPrepare: onPrepare,
			visible: open,
			onVisibleChanged: (nextVisible) => {
				motion?.onVisibleChanged?.(nextVisible);
				onVisibleChanged(nextVisible);
			}
		}), ({ className: motionClassName, style: motionStyle }, motionRef) => {
			const cls = clsx(prefixCls, motionClassName, className, { [`${prefixCls}-mobile`]: isMobile });
			return reactExports.createElement("div", {
				ref: composeRef(resizeObserverRef, ref, motionRef),
				className: cls,
				style: {
					"--arrow-x": `${arrowPos.x || 0}px`,
					"--arrow-y": `${arrowPos.y || 0}px`,
					...offsetStyle,
					...miscStyle,
					...motionStyle,
					boxSizing: "border-box",
					zIndex,
					...style
				},
				onMouseEnter,
				onMouseLeave,
				onPointerEnter,
				onClick,
				onPointerDownCapture
			}, arrow && reactExports.createElement(Arrow, {
				prefixCls,
				arrow,
				arrowPos,
				align
			}), reactExports.createElement(PopupContent, { cache: !open && !fresh }, popupContent));
		});
	}), children);
});
// ===================== Nest =====================
const TriggerContext = reactExports.createContext(null);
// ==================== Unique ====================
const UniqueContext = reactExports.createContext(null);
function toArray$2(val) {
	return val ? Array.isArray(val) ? val : [val] : [];
}
function useAction(action, showAction, hideAction) {
	return reactExports.useMemo(() => {
		const mergedShowAction = toArray$2(showAction ?? action);
		const mergedHideAction = toArray$2(hideAction ?? action);
		const showActionSet = new Set(mergedShowAction);
		const hideActionSet = new Set(mergedHideAction);
		if (showActionSet.has("hover") && !showActionSet.has("click")) {
			showActionSet.add("touch");
		}
		if (hideActionSet.has("hover") && !hideActionSet.has("click")) {
			hideActionSet.add("touch");
		}
		return [showActionSet, hideActionSet];
	}, [
		action,
		showAction,
		hideAction
	]);
}
var isVisible = (element) => {
	if (!element) {
		return false;
	}
	if (element instanceof Element) {
		if (element.offsetParent) {
			return true;
		}
		if (element.getBBox) {
			const { width, height } = element.getBBox();
			if (width || height) {
				return true;
			}
		}
		if (element.getBoundingClientRect) {
			const { width, height } = element.getBoundingClientRect();
			if (width || height) {
				return true;
			}
		}
	}
	return false;
};
function isPointsEq(a1 = [], a2 = [], isAlignPoint) {
	const getVal = (a, index) => a[index] || "";
	if (isAlignPoint) {
		return getVal(a1, 0) === getVal(a2, 0);
	}
	return getVal(a1, 0) === getVal(a2, 0) && getVal(a1, 1) === getVal(a2, 1);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
	const { points } = align;
	const placements = Object.keys(builtinPlacements);
	for (let i = 0; i < placements.length; i += 1) {
		const placement = placements[i];
		if (isPointsEq(builtinPlacements[placement]?.points, points, isAlignPoint)) {
			return `${prefixCls}-placement-${placement}`;
		}
	}
	return "";
}
function getWin(ele) {
	return ele.ownerDocument.defaultView;
}
/**
* Get all the scrollable parent elements of the element
* @param ele       The element to be detected
* @param areaOnly  Only return the parent which will cut visible area
*/
function collectScroller(ele) {
	const scrollerList = [];
	let current = ele?.parentElement;
	const scrollStyle = [
		"hidden",
		"scroll",
		"clip",
		"auto"
	];
	while (current) {
		const { overflowX, overflowY, overflow } = getWin(current).getComputedStyle(current);
		if ([
			overflowX,
			overflowY,
			overflow
		].some((o) => scrollStyle.includes(o))) {
			scrollerList.push(current);
		}
		current = current.parentElement;
	}
	return scrollerList;
}
function toNum(num, defaultValue = 1) {
	return Number.isNaN(num) ? defaultValue : num;
}
function getPxValue(val) {
	return toNum(parseFloat(val), 0);
}
/**
*
*
*  **************************************
*  *              Border                *
*  *     **************************     *
*  *     *                  *     *     *
*  *  B  *                  *  S  *  B  *
*  *  o  *                  *  c  *  o  *
*  *  r  *      Content     *  r  *  r  *
*  *  d  *                  *  o  *  d  *
*  *  e  *                  *  l  *  e  *
*  *  r  ********************  l  *  r  *
*  *     *        Scroll          *     *
*  *     **************************     *
*  *              Border                *
*  **************************************
*
*/
/**
* Get visible area of element
*/
function getVisibleArea(initArea, scrollerList) {
	const visibleArea = { ...initArea };
	(scrollerList || []).forEach((ele) => {
		if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
			return;
		}
		// Skip if static position which will not affect visible area
		const { overflow, overflowClipMargin, borderTopWidth, borderBottomWidth, borderLeftWidth, borderRightWidth } = getWin(ele).getComputedStyle(ele);
		const eleRect = ele.getBoundingClientRect();
		const { offsetHeight: eleOutHeight, clientHeight: eleInnerHeight, offsetWidth: eleOutWidth, clientWidth: eleInnerWidth } = ele;
		const borderTopNum = getPxValue(borderTopWidth);
		const borderBottomNum = getPxValue(borderBottomWidth);
		const borderLeftNum = getPxValue(borderLeftWidth);
		const borderRightNum = getPxValue(borderRightWidth);
		const scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
		const scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
		// Original visible area
		const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
		const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
		// Cut border size
		const scaledBorderTopWidth = borderTopNum * scaleY;
		const scaledBorderBottomWidth = borderBottomNum * scaleY;
		const scaledBorderLeftWidth = borderLeftNum * scaleX;
		const scaledBorderRightWidth = borderRightNum * scaleX;
		// Clip margin
		let clipMarginWidth = 0;
		let clipMarginHeight = 0;
		if (overflow === "clip") {
			const clipNum = getPxValue(overflowClipMargin);
			clipMarginWidth = clipNum * scaleX;
			clipMarginHeight = clipNum * scaleY;
		}
		// Region
		const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
		const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
		const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
		const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
		visibleArea.left = Math.max(visibleArea.left, eleLeft);
		visibleArea.top = Math.max(visibleArea.top, eleTop);
		visibleArea.right = Math.min(visibleArea.right, eleRight);
		visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
	});
	return visibleArea;
}
function getUnitOffset(size, offset = 0) {
	const offsetStr = `${offset}`;
	const cells = offsetStr.match(/^(.*)\%$/);
	if (cells) {
		return size * (parseFloat(cells[1]) / 100);
	}
	return parseFloat(offsetStr);
}
function getNumberOffset(rect, offset) {
	const [offsetX, offsetY] = offset || [];
	return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
}
function splitPoints(points = "") {
	return [points[0], points[1]];
}
function getAlignPoint(rect, points) {
	const topBottom = points[0];
	const leftRight = points[1];
	let x;
	let y;
	// Top & Bottom
	if (topBottom === "t") {
		y = rect.y;
	} else if (topBottom === "b") {
		y = rect.y + rect.height;
	} else {
		y = rect.y + rect.height / 2;
	}
	// Left & Right
	if (leftRight === "l") {
		x = rect.x;
	} else if (leftRight === "r") {
		x = rect.x + rect.width;
	} else {
		x = rect.x + rect.width / 2;
	}
	return {
		a: x,
		b: y
	};
}
function reversePoints(points, index) {
	const reverseMap = {
		t: "b",
		b: "t",
		l: "r",
		r: "l"
	};
	const clone = [...points];
	clone[index] = reverseMap[points[index]] || "c";
	return clone;
}
function flatPoints(points) {
	return points.join("");
}
function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {
	const [offsetInfo, setOffsetInfo] = reactExports.useState({
		ready: false,
		offsetX: 0,
		offsetY: 0,
		offsetR: 0,
		offsetB: 0,
		arrowX: 0,
		arrowY: 0,
		scaleX: 1,
		scaleY: 1,
		align: builtinPlacements[placement] || {}
	});
	const alignCountRef = reactExports.useRef(0);
	const scrollerList = reactExports.useMemo(() => {
		if (!popupEle || mobile) {
			return [];
		}
		return collectScroller(popupEle);
	}, [popupEle]);
	// ========================= Flip ==========================
	// We will memo flip info.
	// If size change to make flip, it will memo the flip info and use it in next align.
	const prevFlipRef = reactExports.useRef({});
	const resetFlipCache = () => {
		prevFlipRef.current = {};
	};
	if (!open) {
		resetFlipCache();
	}
	// ========================= Align =========================
	const onAlign = useEvent(() => {
		if (popupEle && target && open && !mobile) {
			const popupElement = popupEle;
			const doc = popupElement.ownerDocument;
			const win = getWin(popupElement);
			const { position: popupPosition } = win.getComputedStyle(popupElement);
			const originLeft = popupElement.style.left;
			const originTop = popupElement.style.top;
			const originRight = popupElement.style.right;
			const originBottom = popupElement.style.bottom;
			const originOverflow = popupElement.style.overflow;
			// Placement
			const placementInfo = {
				...builtinPlacements[placement],
				...popupAlign
			};
			// placeholder element
			const placeholderElement = doc.createElement("div");
			popupElement.parentElement?.appendChild(placeholderElement);
			placeholderElement.style.left = `${popupElement.offsetLeft}px`;
			placeholderElement.style.top = `${popupElement.offsetTop}px`;
			placeholderElement.style.position = popupPosition;
			placeholderElement.style.height = `${popupElement.offsetHeight}px`;
			placeholderElement.style.width = `${popupElement.offsetWidth}px`;
			// Reset first
			popupElement.style.left = "0";
			popupElement.style.top = "0";
			popupElement.style.right = "auto";
			popupElement.style.bottom = "auto";
			popupElement.style.overflow = "hidden";
			// Calculate align style, we should consider `transform` case
			let targetRect;
			if (Array.isArray(target)) {
				targetRect = {
					x: target[0],
					y: target[1],
					width: 0,
					height: 0
				};
			} else {
				const rect = target.getBoundingClientRect();
				rect.x = rect.x ?? rect.left;
				rect.y = rect.y ?? rect.top;
				targetRect = {
					x: rect.x,
					y: rect.y,
					width: rect.width,
					height: rect.height
				};
			}
			const popupRect = popupElement.getBoundingClientRect();
			const { height, width } = win.getComputedStyle(popupElement);
			popupRect.x = popupRect.x ?? popupRect.left;
			popupRect.y = popupRect.y ?? popupRect.top;
			const { clientWidth, clientHeight, scrollWidth, scrollHeight, scrollTop, scrollLeft } = doc.documentElement;
			const popupHeight = popupRect.height;
			const popupWidth = popupRect.width;
			const targetHeight = targetRect.height;
			const targetWidth = targetRect.width;
			// Get bounding of visible area
			const visibleRegion = {
				left: 0,
				top: 0,
				right: clientWidth,
				bottom: clientHeight
			};
			const scrollRegion = {
				left: -scrollLeft,
				top: -scrollTop,
				right: scrollWidth - scrollLeft,
				bottom: scrollHeight - scrollTop
			};
			let { htmlRegion } = placementInfo;
			if (htmlRegion !== "scroll" && htmlRegion !== "visibleFirst") {
				htmlRegion = "visible";
			}
			const isVisibleFirst = htmlRegion === "visibleFirst";
			const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
			const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
			const visibleArea = htmlRegion === "visible" ? visibleRegionArea : scrollRegionArea;
			// When set to `visibleFirst`,
			// the check `adjust` logic will use `visibleRegion` for check first.
			const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
			// Record right & bottom align data
			popupElement.style.left = "auto";
			popupElement.style.top = "auto";
			popupElement.style.right = "0";
			popupElement.style.bottom = "0";
			const popupMirrorRect = popupElement.getBoundingClientRect();
			// Reset back
			popupElement.style.left = originLeft;
			popupElement.style.top = originTop;
			popupElement.style.right = originRight;
			popupElement.style.bottom = originBottom;
			popupElement.style.overflow = originOverflow;
			popupElement.parentElement?.removeChild(placeholderElement);
			// Calculate scale
			const scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
			const scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
			// No need to align since it's not visible in view
			if (scaleX === 0 || scaleY === 0 || isDOM(target) && !isVisible(target)) {
				return;
			}
			// Offset
			const { offset, targetOffset } = placementInfo;
			let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset);
			const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset);
			targetRect.x -= targetOffsetX;
			targetRect.y -= targetOffsetY;
			// Points
			const [popupPoint, targetPoint] = placementInfo.points || [];
			const targetPoints = splitPoints(targetPoint);
			const popupPoints = splitPoints(popupPoint);
			const targetAlignPoint = getAlignPoint(targetRect, targetPoints);
			const popupAlignPoint = getAlignPoint(popupRect, popupPoints);
			// Real align info may not same as origin one
			const nextAlignInfo = { ...placementInfo };
			let nextPoints = [popupPoints, targetPoints];
			// Next Offset
			let nextOffsetX = targetAlignPoint.a - popupAlignPoint.a + popupOffsetX;
			let nextOffsetY = targetAlignPoint.b - popupAlignPoint.b + popupOffsetY;
			// ============== Intersection ===============
			// Get area by position. Used for check if flip area is better
			function getIntersectionVisibleArea(offsetX, offsetY, area = visibleArea) {
				const l = popupRect.x + offsetX;
				const t = popupRect.y + offsetY;
				const r = l + popupWidth;
				const b = t + popupHeight;
				const visibleL = Math.max(l, area.left);
				const visibleT = Math.max(t, area.top);
				const visibleR = Math.min(r, area.right);
				const visibleB = Math.min(b, area.bottom);
				return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
			}
			const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
			// As `visibleFirst`, we prepare this for check
			const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
			// ========================== Overflow ===========================
			const targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
			const popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
			const targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
			const popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
			const overflow = placementInfo.overflow || {};
			const { adjustX, adjustY, shiftX, shiftY } = overflow;
			const supportAdjust = (val) => {
				if (typeof val === "boolean") {
					return val;
				}
				return val >= 0;
			};
			// Prepare position
			let nextPopupY;
			let nextPopupBottom;
			let nextPopupX;
			let nextPopupRight;
			function syncNextPopupPosition() {
				nextPopupY = popupRect.y + nextOffsetY;
				nextPopupBottom = nextPopupY + popupHeight;
				nextPopupX = popupRect.x + nextOffsetX;
				nextPopupRight = nextPopupX + popupWidth;
			}
			syncNextPopupPosition();
			// >>>>>>>>>> Top & Bottom
			const needAdjustY = supportAdjust(adjustY);
			const sameTB = popupPoints[0] === targetPoints[0];
			// Bottom to Top
			if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
				let tmpNextOffsetY = nextOffsetY;
				if (sameTB) {
					tmpNextOffsetY -= popupHeight - targetHeight;
				} else {
					tmpNextOffsetY = targetAlignPointTL.b - popupAlignPointBR.b - popupOffsetY;
				}
				const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
				const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
				if (newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.bt = true;
					nextOffsetY = tmpNextOffsetY;
					popupOffsetY = -popupOffsetY;
					nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];
				} else {
					prevFlipRef.current.bt = false;
				}
			}
			// Top to Bottom
			if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
				let tmpNextOffsetY = nextOffsetY;
				if (sameTB) {
					tmpNextOffsetY += popupHeight - targetHeight;
				} else {
					tmpNextOffsetY = targetAlignPointBR.b - popupAlignPointTL.b - popupOffsetY;
				}
				const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
				const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
				if (newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.tb = true;
					nextOffsetY = tmpNextOffsetY;
					popupOffsetY = -popupOffsetY;
					nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];
				} else {
					prevFlipRef.current.tb = false;
				}
			}
			// >>>>>>>>>> Left & Right
			const needAdjustX = supportAdjust(adjustX);
			// >>>>> Flip
			const sameLR = popupPoints[1] === targetPoints[1];
			// Right to Left
			if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
				let tmpNextOffsetX = nextOffsetX;
				if (sameLR) {
					tmpNextOffsetX -= popupWidth - targetWidth;
				} else {
					tmpNextOffsetX = targetAlignPointTL.a - popupAlignPointBR.a - popupOffsetX;
				}
				const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
				const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
				if (newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.rl = true;
					nextOffsetX = tmpNextOffsetX;
					popupOffsetX = -popupOffsetX;
					nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];
				} else {
					prevFlipRef.current.rl = false;
				}
			}
			// Left to Right
			if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
				let tmpNextOffsetX = nextOffsetX;
				if (sameLR) {
					tmpNextOffsetX += popupWidth - targetWidth;
				} else {
					tmpNextOffsetX = targetAlignPointBR.a - popupAlignPointTL.a - popupOffsetX;
				}
				const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
				const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
				if (newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.lr = true;
					nextOffsetX = tmpNextOffsetX;
					popupOffsetX = -popupOffsetX;
					nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];
				} else {
					prevFlipRef.current.lr = false;
				}
			}
			nextAlignInfo.points = [flatPoints(nextPoints[0]), flatPoints(nextPoints[1])];
			// ============================ Shift ============================
			syncNextPopupPosition();
			const numShiftX = shiftX === true ? 0 : shiftX;
			if (typeof numShiftX === "number") {
				// Left
				if (nextPopupX < visibleRegionArea.left) {
					nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
					if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
						nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
					}
				}
				// Right
				if (nextPopupRight > visibleRegionArea.right) {
					nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
					if (targetRect.x > visibleRegionArea.right - numShiftX) {
						nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
					}
				}
			}
			const numShiftY = shiftY === true ? 0 : shiftY;
			if (typeof numShiftY === "number") {
				// Top
				if (nextPopupY < visibleRegionArea.top) {
					nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
					// When target if far away from visible area
					// Stop shift
					if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
						nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
					}
				}
				// Bottom
				if (nextPopupBottom > visibleRegionArea.bottom) {
					nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
					if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
						nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
					}
				}
			}
			// ============================ Arrow ============================
			// Arrow center align
			const popupLeft = popupRect.x + nextOffsetX;
			const popupRight = popupLeft + popupWidth;
			const popupTop = popupRect.y + nextOffsetY;
			const popupBottom = popupTop + popupHeight;
			const targetLeft = targetRect.x;
			const targetRight = targetLeft + targetWidth;
			const targetTop = targetRect.y;
			const targetBottom = targetTop + targetHeight;
			/** Max left of the popup and target element */
			const maxLeft = Math.max(popupLeft, targetLeft);
			/** Min right of the popup and target element */
			const minRight = Math.min(popupRight, targetRight);
			/** The center X of popup & target cross area */
			const xCenter = (maxLeft + minRight) / 2;
			/** Arrow X of popup offset */
			const nextArrowX = xCenter - popupLeft;
			const maxTop = Math.max(popupTop, targetTop);
			const minBottom = Math.min(popupBottom, targetBottom);
			const yCenter = (maxTop + minBottom) / 2;
			const nextArrowY = yCenter - popupTop;
			onPopupAlign?.(popupEle, nextAlignInfo);
			// Additional calculate right & bottom position
			let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
			let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
			if (scaleX === 1) {
				nextOffsetX = Math.floor(nextOffsetX);
				offsetX4Right = Math.floor(offsetX4Right);
			}
			if (scaleY === 1) {
				nextOffsetY = Math.floor(nextOffsetY);
				offsetY4Bottom = Math.floor(offsetY4Bottom);
			}
			const nextOffsetInfo = {
				ready: true,
				offsetX: nextOffsetX / scaleX,
				offsetY: nextOffsetY / scaleY,
				offsetR: offsetX4Right / scaleX,
				offsetB: offsetY4Bottom / scaleY,
				arrowX: nextArrowX / scaleX,
				arrowY: nextArrowY / scaleY,
				scaleX,
				scaleY,
				align: nextAlignInfo
			};
			setOffsetInfo(nextOffsetInfo);
		}
	});
	const triggerAlign = () => {
		alignCountRef.current += 1;
		const id = alignCountRef.current;
		// Merge all align requirement into one frame
		Promise.resolve().then(() => {
			if (alignCountRef.current === id) {
				onAlign();
			}
		});
	};
	// Reset ready status when placement & open changed
	const resetReady = () => {
		setOffsetInfo((ori) => ({
			...ori,
			ready: false
		}));
	};
	useLayoutEffect(resetReady, [placement]);
	useLayoutEffect(() => {
		if (!open) {
			resetReady();
		}
	}, [open]);
	return [
		offsetInfo.ready,
		offsetInfo.offsetX,
		offsetInfo.offsetY,
		offsetInfo.offsetR,
		offsetInfo.offsetB,
		offsetInfo.arrowX,
		offsetInfo.arrowY,
		offsetInfo.scaleX,
		offsetInfo.scaleY,
		offsetInfo.align,
		triggerAlign
	];
}
function useDelay() {
	const delayRef = reactExports.useRef(null);
	const clearDelay = () => {
		if (delayRef.current) {
			clearTimeout(delayRef.current);
			delayRef.current = null;
		}
	};
	const delayInvoke = (callback, delay) => {
		clearDelay();
		if (delay === 0) {
			callback();
		} else {
			delayRef.current = setTimeout(() => {
				callback();
			}, delay * 1e3);
		}
	};
	// Clean up on unmount
	reactExports.useEffect(() => {
		return () => {
			clearDelay();
		};
	}, []);
	return delayInvoke;
}
function useWatch$1(open, target, popup, onAlign, onScroll) {
	useLayoutEffect(() => {
		if (open && target && popup) {
			const targetElement = target;
			const popupElement = popup;
			const targetScrollList = collectScroller(targetElement);
			const popupScrollList = collectScroller(popupElement);
			const win = getWin(popupElement);
			const mergedList = new Set([
				win,
				...targetScrollList,
				...popupScrollList
			]);
			function notifyScroll() {
				onAlign();
				onScroll();
			}
			mergedList.forEach((scroller) => {
				scroller.addEventListener("scroll", notifyScroll, { passive: true });
			});
			win.addEventListener("resize", notifyScroll, { passive: true });
			// First time always do align
			onAlign();
			return () => {
				mergedList.forEach((scroller) => {
					scroller.removeEventListener("scroll", notifyScroll);
					win.removeEventListener("resize", notifyScroll);
				});
			};
		}
	}, [
		open,
		target,
		popup
	]);
}
/**
* Close if click on the window.
* Return the function that click on the Popup element.
*/
function useWinClick(open, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
	const openRef = reactExports.useRef(open);
	openRef.current = open;
	const popupPointerDownRef = reactExports.useRef(false);
	// Click to hide is special action since click popup element should not hide
	reactExports.useEffect(() => {
		if (clickToHide && popupEle && (!mask || maskClosable)) {
			const onPointerDown = () => {
				popupPointerDownRef.current = false;
			};
			const onTriggerClose = (e) => {
				if (openRef.current && !inPopupOrChild(e.composedPath?.()?.[0] || e.target) && !popupPointerDownRef.current) {
					triggerOpen(false);
				}
			};
			const win = getWin(popupEle);
			win.addEventListener("pointerdown", onPointerDown, true);
			win.addEventListener("mousedown", onTriggerClose, true);
			win.addEventListener("contextmenu", onTriggerClose, true);
			// shadow root
			const targetShadowRoot = getShadowRoot(targetEle);
			if (targetShadowRoot) {
				targetShadowRoot.addEventListener("mousedown", onTriggerClose, true);
				targetShadowRoot.addEventListener("contextmenu", onTriggerClose, true);
			}
			return () => {
				win.removeEventListener("pointerdown", onPointerDown, true);
				win.removeEventListener("mousedown", onTriggerClose, true);
				win.removeEventListener("contextmenu", onTriggerClose, true);
				if (targetShadowRoot) {
					targetShadowRoot.removeEventListener("mousedown", onTriggerClose, true);
					targetShadowRoot.removeEventListener("contextmenu", onTriggerClose, true);
				}
			};
		}
	}, [
		clickToHide,
		targetEle,
		popupEle,
		mask,
		maskClosable
	]);
	function onPopupPointerDown() {
		popupPointerDownRef.current = true;
	}
	return onPopupPointerDown;
}
/**
* Control the state of popup bind target:
* 1. When set `target`. Do show the popup.
* 2. When `target` is removed. Do hide the popup.
* 3. When `target` change to another one:
*  a. We wait motion finish of previous popup.
*  b. Then we set new target and show the popup.
* 4. During appear/enter animation, cache new options and apply after animation completes.
*/
function useTargetState() {
	const [options, setOptions] = React.useState(null);
	const [open, setOpen] = React.useState(false);
	const [isAnimating, setIsAnimating] = React.useState(false);
	const pendingOptionsRef = React.useRef(null);
	const trigger = useEvent((nextOptions) => {
		if (nextOptions === false) {
			// Clear pending options when hiding
			pendingOptionsRef.current = null;
			setOpen(false);
		} else {
			if (isAnimating && open) {
				// If animating (appear or enter), cache new options
				pendingOptionsRef.current = nextOptions;
			} else {
				setOpen(true);
				// Set new options
				setOptions(nextOptions);
				pendingOptionsRef.current = null;
				// Only mark as animating when transitioning from closed to open
				if (!open) {
					setIsAnimating(true);
				}
			}
		}
	});
	const onVisibleChanged = useEvent((visible) => {
		if (visible) {
			// Animation enter completed, check if there are pending options
			setIsAnimating(false);
			if (pendingOptionsRef.current) {
				// Apply pending options
				setOptions(pendingOptionsRef.current);
				pendingOptionsRef.current = null;
			}
		} else {
			// Animation leave completed
			setIsAnimating(false);
			pendingOptionsRef.current = null;
		}
	});
	return [
		trigger,
		open,
		options,
		onVisibleChanged
	];
}
function _extends$r() {
	_extends$r = Object.assign.bind();
	return _extends$r.apply(this, arguments);
}
const UniqueContainer = (props) => {
	const { prefixCls, isMobile, ready, open, align, offsetR, offsetB, offsetX, offsetY, arrowPos, popupSize, motion, uniqueContainerClassName, uniqueContainerStyle } = props;
	const containerCls = `${prefixCls}-unique-container`;
	const [motionVisible, setMotionVisible] = React.useState(false);
	// ========================= Styles =========================
	const offsetStyle = useOffsetStyle(isMobile, ready, open, align, offsetR, offsetB, offsetX, offsetY);
	// Cache for offsetStyle when ready is true
	const cachedOffsetStyleRef = React.useRef(offsetStyle);
	// Update cached offset style when ready is true
	if (ready) {
		cachedOffsetStyleRef.current = offsetStyle;
	}
	// Apply popup size if available
	const sizeStyle = {};
	if (popupSize) {
		sizeStyle.width = popupSize.width;
		sizeStyle.height = popupSize.height;
	}
	// ========================= Render =========================
	return React.createElement(CSSMotion, _extends$r({
		motionAppear: true,
		motionEnter: true,
		motionLeave: true,
		removeOnLeave: false,
		leavedClassName: `${containerCls}-hidden`
	}, motion, {
		visible: open,
		onVisibleChanged: (nextVisible) => {
			setMotionVisible(nextVisible);
		}
	}), ({ className: motionClassName, style: motionStyle }) => {
		const cls = clsx(containerCls, motionClassName, uniqueContainerClassName, { [`${containerCls}-visible`]: motionVisible });
		return React.createElement("div", {
			className: cls,
			style: {
				"--arrow-x": `${arrowPos?.x || 0}px`,
				"--arrow-y": `${arrowPos?.y || 0}px`,
				...cachedOffsetStyleRef.current,
				...sizeStyle,
				...motionStyle,
				...uniqueContainerStyle
			}
		});
	});
};
const UniqueProvider$1 = ({ children, postTriggerProps }) => {
	const [trigger, open, options, onTargetVisibleChanged] = useTargetState();
	// ========================== Options ===========================
	const mergedOptions = reactExports.useMemo(() => {
		if (!options || !postTriggerProps) {
			return options;
		}
		return postTriggerProps(options);
	}, [options, postTriggerProps]);
	// =========================== Popup ============================
	const [popupEle, setPopupEle] = reactExports.useState(null);
	const [popupSize, setPopupSize] = reactExports.useState(null);
	// Used for forwardRef popup. Not use internal
	const externalPopupRef = reactExports.useRef(null);
	const setPopupRef = useEvent((node) => {
		externalPopupRef.current = node;
		if (isDOM(node) && popupEle !== node) {
			setPopupEle(node);
		}
	});
	// ========================== Register ==========================
	// Store the isOpen function from the latest show call
	const isOpenRef = reactExports.useRef(null);
	const delayInvoke = useDelay();
	const show = useEvent((showOptions, isOpen) => {
		// Store the isOpen function for later use in hide
		isOpenRef.current = isOpen;
		delayInvoke(() => {
			trigger(showOptions);
		}, showOptions.delay);
	});
	const hide = (delay) => {
		delayInvoke(() => {
			// Check if we should still hide by calling the isOpen function
			// If isOpen returns true, it means another trigger wants to keep it open
			if (isOpenRef.current?.()) {
				return;
			}
			trigger(false);
			// Don't clear target, currentNode, options immediately, wait until animation completes
		}, delay);
	};
	// Callback after animation completes
	const onVisibleChanged = useEvent((visible) => {
		// Call useTargetState callback to handle animation state
		onTargetVisibleChanged(visible);
	});
	// =========================== Align ============================
	const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, , , alignInfo, onAlign] = useAlign(
		open,
		popupEle,
		mergedOptions?.target,
		mergedOptions?.popupPlacement,
		mergedOptions?.builtinPlacements || {},
		mergedOptions?.popupAlign,
		0,
		// onPopupAlign
		false
	);
	const alignedClassName = reactExports.useMemo(() => {
		if (!mergedOptions) {
			return "";
		}
		const baseClassName = getAlignPopupClassName(mergedOptions.builtinPlacements || {}, mergedOptions.prefixCls || "", alignInfo, false);
		return clsx(baseClassName, mergedOptions.getPopupClassNameFromAlign?.(alignInfo));
	}, [
		alignInfo,
		mergedOptions?.getPopupClassNameFromAlign,
		mergedOptions?.builtinPlacements,
		mergedOptions?.prefixCls
	]);
	const contextValue = reactExports.useMemo(() => ({
		show,
		hide
	}), []);
	// =========================== Align ============================
	reactExports.useEffect(() => {
		onAlign();
	}, [mergedOptions?.target]);
	// =========================== Motion ===========================
	const onPrepare = useEvent(() => {
		onAlign();
		return Promise.resolve();
	});
	// ======================== Trigger Context =====================
	const subPopupElements = reactExports.useRef({});
	const parentContext = reactExports.useContext(TriggerContext);
	const triggerContextValue = reactExports.useMemo(() => ({ registerSubPopup: (id, subPopupEle) => {
		subPopupElements.current[id] = subPopupEle;
		parentContext?.registerSubPopup(id, subPopupEle);
	} }), [parentContext]);
	// =========================== Render ===========================
	const prefixCls = mergedOptions?.prefixCls;
	return reactExports.createElement(UniqueContext.Provider, { value: contextValue }, children, mergedOptions && reactExports.createElement(TriggerContext.Provider, { value: triggerContextValue }, reactExports.createElement(Popup$1, {
		ref: setPopupRef,
		portal: Portal,
		onEsc: mergedOptions.onEsc,
		prefixCls,
		popup: mergedOptions.popup,
		className: clsx(mergedOptions.popupClassName, alignedClassName, `${prefixCls}-unique-controlled`),
		style: mergedOptions.popupStyle,
		target: mergedOptions.target,
		open,
		keepDom: true,
		fresh: true,
		autoDestroy: false,
		onVisibleChanged,
		ready,
		offsetX,
		offsetY,
		offsetR,
		offsetB,
		onAlign,
		onPrepare,
		onResize: (size) => setPopupSize({
			width: size.offsetWidth,
			height: size.offsetHeight
		}),
		arrowPos: {
			x: arrowX,
			y: arrowY
		},
		align: alignInfo,
		zIndex: mergedOptions.zIndex,
		mask: mergedOptions.mask,
		arrow: mergedOptions.arrow,
		motion: mergedOptions.popupMotion,
		maskMotion: mergedOptions.maskMotion,
		getPopupContainer: mergedOptions.getPopupContainer
	}, reactExports.createElement(UniqueContainer, {
		prefixCls,
		isMobile: false,
		ready,
		open,
		align: alignInfo,
		offsetR,
		offsetB,
		offsetX,
		offsetY,
		arrowPos: {
			x: arrowX,
			y: arrowY
		},
		popupSize,
		motion: mergedOptions.popupMotion,
		uniqueContainerClassName: clsx(mergedOptions.uniqueContainerClassName, alignedClassName),
		uniqueContainerStyle: mergedOptions.uniqueContainerStyle
	}))));
};
// Removed Props List
// Seems this can be auto
// getDocument?: (element?: HTMLElement) => Document;
// New version will not wrap popup with `rc-trigger-popup-content` when multiple children
function generateTrigger(PortalComponent = Portal) {
	const Trigger = reactExports.forwardRef((props, ref) => {
		const { prefixCls = "rc-trigger-popup", children, action = "hover", showAction, hideAction, popupVisible, defaultPopupVisible, onOpenChange, afterOpenChange, onPopupVisibleChange, afterPopupVisibleChange, mouseEnterDelay, mouseLeaveDelay = .1, focusDelay, blurDelay, mask, maskClosable = true, getPopupContainer, forceRender, autoDestroy, popup, popupClassName, uniqueContainerClassName, uniqueContainerStyle, popupStyle, popupPlacement, builtinPlacements = {}, popupAlign, zIndex, stretch, getPopupClassNameFromAlign, fresh, unique, alignPoint, onPopupClick, onPopupAlign, arrow, popupMotion, maskMotion, mobile, ...restProps } = props;
		const mergedAutoDestroy = autoDestroy || false;
		const openUncontrolled = popupVisible === void 0;
		// =========================== Mobile ===========================
		const isMobile = !!mobile;
		// ========================== Context ===========================
		const subPopupElements = reactExports.useRef({});
		const parentContext = reactExports.useContext(TriggerContext);
		const context = reactExports.useMemo(() => {
			return { registerSubPopup: (id, subPopupEle) => {
				subPopupElements.current[id] = subPopupEle;
				parentContext?.registerSubPopup(id, subPopupEle);
			} };
		}, [parentContext]);
		// ======================== UniqueContext =========================
		const uniqueContext = reactExports.useContext(UniqueContext);
		// =========================== Popup ============================
		const id = useId();
		const [popupEle, setPopupEle] = reactExports.useState(null);
		// Used for forwardRef popup. Not use internal
		const externalPopupRef = reactExports.useRef(null);
		const setPopupRef = useEvent((node) => {
			externalPopupRef.current = node;
			if (isDOM(node) && popupEle !== node) {
				setPopupEle(node);
			}
			parentContext?.registerSubPopup(id, node);
		});
		// =========================== Target ===========================
		// Use state to control here since `useRef` update not trigger render
		const [targetEle, setTargetEle] = reactExports.useState(null);
		// Used for forwardRef target. Not use internal
		const externalForwardRef = reactExports.useRef(null);
		const setTargetRef = useEvent((node) => {
			const domNode = getDOM(node);
			if (isDOM(domNode) && targetEle !== domNode) {
				setTargetEle(domNode);
				externalForwardRef.current = domNode;
			}
		});
		const cloneProps = {};
		const inPopupOrChild = useEvent((ele) => {
			const childDOM = targetEle;
			return childDOM?.contains(ele) || getShadowRoot(childDOM)?.host === ele || ele === childDOM || popupEle?.contains(ele) || getShadowRoot(popupEle)?.host === ele || ele === popupEle || Object.values(subPopupElements.current).some((subPopupEle) => subPopupEle?.contains(ele) || ele === subPopupEle);
		});
		// =========================== Arrow ============================
		const innerArrow = arrow ? { ...arrow !== true ? arrow : {} } : null;
		// ============================ Open ============================
		const [internalOpen, setInternalOpen] = useControlledState(defaultPopupVisible || false, popupVisible);
		const mergedOpen = internalOpen || false;
		// ========================== Children ==========================
		const child = reactExports.useMemo(() => {
			const nextChild = typeof children === "function" ? children({ open: mergedOpen }) : children;
			return reactExports.Children.only(nextChild);
		}, [children, mergedOpen]);
		const originChildProps = child?.props || {};
		// Support ref
		const isOpen = useEvent(() => mergedOpen);
		// Extract common options for UniqueProvider
		const getUniqueOptions = useEvent((delay = 0) => ({
			popup,
			target: targetEle,
			delay,
			prefixCls,
			popupClassName,
			uniqueContainerClassName,
			uniqueContainerStyle,
			popupStyle,
			popupPlacement,
			builtinPlacements,
			popupAlign,
			zIndex,
			mask,
			maskClosable,
			popupMotion,
			maskMotion,
			arrow: innerArrow,
			getPopupContainer,
			getPopupClassNameFromAlign,
			id,
			onEsc
		}));
		// Handle controlled state changes for UniqueProvider
		// Only sync to UniqueProvider when it's controlled mode
		// If there is a parentContext, don't call uniqueContext methods
		useLayoutEffect(() => {
			if (uniqueContext && unique && targetEle && !openUncontrolled && !parentContext) {
				if (mergedOpen) {
					uniqueContext.show(getUniqueOptions(mouseEnterDelay), isOpen);
				} else {
					uniqueContext.hide(mouseLeaveDelay);
				}
			}
		}, [mergedOpen, targetEle]);
		const openRef = reactExports.useRef(mergedOpen);
		openRef.current = mergedOpen;
		const internalTriggerOpen = useEvent((nextOpen) => {
			reactDomExports.c(() => {
				if (mergedOpen !== nextOpen) {
					setInternalOpen(nextOpen);
					onOpenChange?.(nextOpen);
					onPopupVisibleChange?.(nextOpen);
				}
			});
		});
		// Trigger for delay
		const delayInvoke = useDelay();
		const triggerOpen = (nextOpen, delay = 0) => {
			// If it's controlled mode, always use internal trigger logic
			// UniqueProvider will be synced through useLayoutEffect
			if (popupVisible !== void 0) {
				delayInvoke(() => {
					internalTriggerOpen(nextOpen);
				}, delay);
				return;
			}
			// If UniqueContext exists and not controlled, pass delay to Provider instead of handling it internally
			// If there is a parentContext, don't call uniqueContext methods
			if (uniqueContext && unique && openUncontrolled && !parentContext) {
				if (nextOpen) {
					uniqueContext.show(getUniqueOptions(delay), isOpen);
				} else {
					uniqueContext.hide(delay);
				}
				return;
			}
			delayInvoke(() => {
				internalTriggerOpen(nextOpen);
			}, delay);
		};
		function onEsc({ top }) {
			if (top) {
				triggerOpen(false);
			}
		}
		// ========================== Motion ============================
		const [inMotion, setInMotion] = reactExports.useState(false);
		useLayoutEffect((firstMount) => {
			if (!firstMount || mergedOpen) {
				setInMotion(true);
			}
		}, [mergedOpen]);
		const [motionPrepareResolve, setMotionPrepareResolve] = reactExports.useState(null);
		// =========================== Align ============================
		const [mousePos, setMousePos] = reactExports.useState(null);
		const setMousePosByEvent = (event) => {
			setMousePos([event.clientX, event.clientY]);
		};
		const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, scaleX, scaleY, alignInfo, onAlign] = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign, isMobile);
		const [showActions, hideActions] = useAction(action, showAction, hideAction);
		const clickToShow = showActions.has("click");
		const clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
		const triggerAlign = useEvent(() => {
			if (!inMotion) {
				onAlign();
			}
		});
		const onScroll = () => {
			if (openRef.current && alignPoint && clickToHide) {
				triggerOpen(false);
			}
		};
		useWatch$1(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
		useLayoutEffect(() => {
			triggerAlign();
		}, [mousePos, popupPlacement]);
		// When no builtinPlacements and popupAlign changed
		useLayoutEffect(() => {
			if (mergedOpen && !builtinPlacements[popupPlacement]) {
				triggerAlign();
			}
		}, [JSON.stringify(popupAlign)]);
		const alignedClassName = reactExports.useMemo(() => {
			const baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
			return clsx(baseClassName, getPopupClassNameFromAlign?.(alignInfo));
		}, [
			alignInfo,
			getPopupClassNameFromAlign,
			builtinPlacements,
			prefixCls,
			alignPoint
		]);
		// ============================ Refs ============================
		reactExports.useImperativeHandle(ref, () => ({
			nativeElement: externalForwardRef.current,
			popupElement: externalPopupRef.current,
			forceAlign: triggerAlign
		}));
		// ========================== Stretch ===========================
		const [targetWidth, setTargetWidth] = reactExports.useState(0);
		const [targetHeight, setTargetHeight] = reactExports.useState(0);
		const syncTargetSize = () => {
			if (stretch && targetEle) {
				const rect = targetEle.getBoundingClientRect();
				setTargetWidth(rect.width);
				setTargetHeight(rect.height);
			}
		};
		const onTargetResize = () => {
			syncTargetSize();
			triggerAlign();
		};
		// ========================== Motion ============================
		const onVisibleChanged = (visible) => {
			setInMotion(false);
			onAlign();
			afterOpenChange?.(visible);
			afterPopupVisibleChange?.(visible);
		};
		// We will trigger align when motion is in prepare
		const onPrepare = () => new Promise((resolve) => {
			syncTargetSize();
			setMotionPrepareResolve(() => resolve);
		});
		useLayoutEffect(() => {
			if (motionPrepareResolve) {
				onAlign();
				motionPrepareResolve();
				setMotionPrepareResolve(null);
			}
		}, [motionPrepareResolve]);
		// =========================== Action ===========================
		/**
		* Util wrapper for trigger action
		* @param eventName  Listen event name
		* @param nextOpen  Next open state after trigger
		* @param delay Delay to trigger open change
		* @param callback Callback if current event need additional action
		* @param ignoreCheck  Ignore current event if check return true
		*/
		function wrapperAction(eventName, nextOpen, delay, callback, ignoreCheck) {
			cloneProps[eventName] = (event, ...args) => {
				if (!ignoreCheck || !ignoreCheck()) {
					callback?.(event);
					triggerOpen(nextOpen, delay);
				}
				// Pass to origin
				originChildProps[eventName]?.(event, ...args);
			};
		}
		// ======================= Action: Touch ========================
		const touchToShow = showActions.has("touch");
		const touchToHide = hideActions.has("touch");
		/** Used for prevent `hover` event conflict with mobile env */
		const touchedRef = reactExports.useRef(false);
		if (touchToShow || touchToHide) {
			cloneProps.onTouchStart = (...args) => {
				touchedRef.current = true;
				if (openRef.current && touchToHide) {
					triggerOpen(false);
				} else if (!openRef.current && touchToShow) {
					triggerOpen(true);
				}
				// Pass to origin
				originChildProps.onTouchStart?.(...args);
			};
		}
		// ======================= Action: Click ========================
		if (clickToShow || clickToHide) {
			cloneProps.onClick = (event, ...args) => {
				if (openRef.current && clickToHide) {
					triggerOpen(false);
				} else if (!openRef.current && clickToShow) {
					setMousePosByEvent(event);
					triggerOpen(true);
				}
				// Pass to origin
				originChildProps.onClick?.(event, ...args);
				touchedRef.current = false;
			};
		}
		// Click to hide is special action since click popup element should not hide
		const onPopupPointerDown = useWinClick(mergedOpen, clickToHide || touchToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
		// ======================= Action: Hover ========================
		const hoverToShow = showActions.has("hover");
		const hoverToHide = hideActions.has("hover");
		let onPopupMouseEnter;
		let onPopupMouseLeave;
		const ignoreMouseTrigger = () => {
			return touchedRef.current;
		};
		if (hoverToShow) {
			const onMouseEnterCallback = (event) => {
				setMousePosByEvent(event);
			};
			// Compatible with old browser which not support pointer event
			wrapperAction("onMouseEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
			wrapperAction("onPointerEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
			onPopupMouseEnter = (event) => {
				// Only trigger re-open when popup is visible
				if ((mergedOpen || inMotion) && popupEle?.contains(event.target)) {
					triggerOpen(true, mouseEnterDelay);
				}
			};
			// Align Point
			if (alignPoint) {
				cloneProps.onMouseMove = (event) => {
					originChildProps.onMouseMove?.(event);
				};
			}
		}
		if (hoverToHide) {
			wrapperAction("onMouseLeave", false, mouseLeaveDelay, 0, ignoreMouseTrigger);
			wrapperAction("onPointerLeave", false, mouseLeaveDelay, 0, ignoreMouseTrigger);
			onPopupMouseLeave = () => {
				triggerOpen(false, mouseLeaveDelay);
			};
		}
		// ======================= Action: Focus ========================
		if (showActions.has("focus")) {
			wrapperAction("onFocus", true, focusDelay);
		}
		if (hideActions.has("focus")) {
			wrapperAction("onBlur", false, blurDelay);
		}
		// ==================== Action: ContextMenu =====================
		if (showActions.has("contextMenu")) {
			cloneProps.onContextMenu = (event, ...args) => {
				if (openRef.current && hideActions.has("contextMenu")) {
					triggerOpen(false);
				} else {
					setMousePosByEvent(event);
					triggerOpen(true);
				}
				event.preventDefault();
				// Pass to origin
				originChildProps.onContextMenu?.(event, ...args);
			};
		}
		// ============================ Perf ============================
		const rendedRef = reactExports.useRef(false);
		rendedRef.current ||= forceRender || mergedOpen || inMotion;
		// =========================== Render ===========================
		const mergedChildrenProps = {
			...originChildProps,
			...cloneProps
		};
		// Pass props into cloneProps for nest usage
		const passedProps = {};
		const passedEventList = [
			"onContextMenu",
			"onClick",
			"onMouseDown",
			"onTouchStart",
			"onMouseEnter",
			"onMouseLeave",
			"onFocus",
			"onBlur"
		];
		passedEventList.forEach((eventName) => {
			if (restProps[eventName]) {
				passedProps[eventName] = (...args) => {
					mergedChildrenProps[eventName]?.(...args);
					restProps[eventName](...args);
				};
			}
		});
		const arrowPos = {
			x: arrowX,
			y: arrowY
		};
		// =================== Resize Observer ===================
		// Use hook to observe target element resize
		// Pass targetEle directly instead of a function so the hook will re-observe when target changes
		useResizeObserver(mergedOpen, targetEle, onTargetResize);
		// Compose refs
		const mergedRef = useComposeRef(setTargetRef, getNodeRef(child));
		// Child Node
		const triggerNode = reactExports.cloneElement(child, {
			...mergedChildrenProps,
			...passedProps,
			ref: mergedRef
		});
		// Render
		return reactExports.createElement(reactExports.Fragment, null, triggerNode, rendedRef.current && (!uniqueContext || !unique) && reactExports.createElement(TriggerContext.Provider, { value: context }, reactExports.createElement(Popup$1, {
			portal: PortalComponent,
			ref: setPopupRef,
			prefixCls,
			popup,
			className: clsx(popupClassName, !isMobile && alignedClassName),
			style: popupStyle,
			target: targetEle,
			onMouseEnter: onPopupMouseEnter,
			onMouseLeave: onPopupMouseLeave,
			onPointerEnter: onPopupMouseEnter,
			zIndex,
			open: mergedOpen,
			keepDom: inMotion,
			fresh,
			onClick: onPopupClick,
			onPointerDownCapture: onPopupPointerDown,
			mask,
			motion: popupMotion,
			maskMotion,
			onVisibleChanged,
			onPrepare,
			forceRender,
			autoDestroy: mergedAutoDestroy,
			getPopupContainer,
			onEsc,
			align: alignInfo,
			arrow: innerArrow,
			arrowPos,
			ready,
			offsetX,
			offsetY,
			offsetR,
			offsetB,
			onAlign: triggerAlign,
			stretch,
			targetWidth: targetWidth / scaleX,
			targetHeight: targetHeight / scaleY,
			mobile
		})));
	});
	return Trigger;
}
var Trigger = generateTrigger(Portal);
function isFragment(child) {
	return child && React.isValidElement(child) && child.type === React.Fragment;
}
const replaceElement = (element, replacement, props) => {
	if (!React.isValidElement(element)) {
		return replacement;
	}
	return React.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
};
function cloneElement(element, props) {
	return replaceElement(element, element, props);
}
const MotionContent = ({ children }) => {
	const { getPrefixCls } = React.useContext(ConfigContext);
	const rootPrefixCls = getPrefixCls();
	// This will never reach since we will not render this when no children
	/* istanbul ignore next */
	if (!React.isValidElement(children)) {
		return children;
	}
	return React.createElement(CSSMotion, {
		visible: true,
		motionName: `${rootPrefixCls}-fade`,
		motionAppear: true,
		motionEnter: true,
		motionLeave: false,
		removeOnLeave: false
	}, ({ style: motionStyle, className: motionClassName }) => {
		return cloneElement(children, (oriProps) => ({
			className: clsx(oriProps.className, motionClassName),
			style: {
				...oriProps.style,
				...motionStyle
			}
		}));
	});
};
const cachedPlacements = [null, null];
function uniqueBuiltinPlacements(ori) {
	if (cachedPlacements[0] !== ori) {
		const target = {};
		Object.keys(ori).forEach((placement) => {
			target[placement] = {
				...ori[placement],
				dynamicInset: false
			};
		});
		cachedPlacements[0] = ori;
		cachedPlacements[1] = target;
	}
	return cachedPlacements[1];
}
const UniqueProvider = ({ children }) => {
	const renderPopup = (options) => {
		const { id, builtinPlacements, popup } = options;
		const popupEle = typeof popup === "function" ? popup() : popup;
		const parsedPlacements = uniqueBuiltinPlacements(builtinPlacements);
		return {
			...options,
			getPopupContainer: null,
			arrow: false,
			popup: React.createElement(MotionContent, { key: id }, popupEle),
			builtinPlacements: parsedPlacements
		};
	};
	return React.createElement(UniqueProvider$1, { postTriggerProps: renderPopup }, children);
};
const DisabledContext = reactExports.createContext(false);
const DisabledContextProvider = ({ children, disabled }) => {
	const originDisabled = reactExports.useContext(DisabledContext);
	return reactExports.createElement(DisabledContext.Provider, { value: disabled ?? originDisabled }, children);
};
const SizeContext = reactExports.createContext(void 0);
const SizeContextProvider = ({ children, size }) => {
	const originSize = reactExports.useContext(SizeContext);
	return reactExports.createElement(SizeContext.Provider, { value: size || originSize }, children);
};
function useConfig() {
	const componentDisabled = reactExports.useContext(DisabledContext);
	const componentSize = reactExports.useContext(SizeContext);
	return {
		componentDisabled,
		componentSize
	};
}
function useTheme(theme, parentTheme, config) {
	const themeConfig = theme || {};
	const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? {
		...defaultConfig,
		hashed: parentTheme?.hashed ?? defaultConfig.hashed,
		cssVar: parentTheme?.cssVar
	} : parentTheme;
	// Generate a unique key for cssVar
	const themeKey = reactExports.useId();
	return useMemo(() => {
		if (!theme) {
			return parentTheme;
		}
		// Override
		const mergedComponents = { ...parentThemeConfig.components };
		Object.keys(theme.components || {}).forEach((componentName) => {
			mergedComponents[componentName] = {
				...mergedComponents[componentName],
				...theme.components[componentName]
			};
		});
		const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
		const mergedCssVar = {
			prefix: config.a,
			...parentThemeConfig.cssVar,
			...themeConfig.cssVar,
			key: themeConfig.cssVar?.key || cssVarKey
		};
		// Base token
		return {
			...parentThemeConfig,
			...themeConfig,
			token: {
				...parentThemeConfig.token,
				...themeConfig.token
			},
			components: mergedComponents,
			cssVar: mergedCssVar
		};
	}, [themeConfig, parentThemeConfig], (prev, next) => prev.some((prevTheme, index) => {
		const nextTheme = next[index];
		return !isEqual(prevTheme, nextTheme, true);
	}));
}
const MotionCacheContext = reactExports.createContext(true);
function MotionWrapper(props) {
	const parentMotion = reactExports.useContext(MotionCacheContext);
	const { children } = props;
	const [, token] = useToken();
	const { motion } = token;
	const needWrapMotionProviderRef = reactExports.useRef(false);
	needWrapMotionProviderRef.current || (needWrapMotionProviderRef.current = parentMotion !== motion);
	if (needWrapMotionProviderRef.current) {
		return reactExports.createElement(MotionCacheContext.Provider, { value: motion }, reactExports.createElement(MotionProvider, { motion }, children));
	}
	return children;
}
var PropWarning = () => null;
/**
* This component registers icon styles inside the DesignTokenContext.Provider
* so that CSS variables use the correct cssVar key from the theme config.
*/
const IconStyle = ({ iconPrefixCls, csp }) => {
	useResetIconStyle(iconPrefixCls, csp);
	return null;
};
// These props is used by `useContext` directly in sub component
const PASSED_PROPS = [
	"getTargetContainer",
	"getPopupContainer",
	"renderEmpty",
	"input",
	"pagination",
	"form",
	"select",
	"button"
];
const setGlobalConfig = () => {};
const ProviderChildren = (props) => {
	const { children, csp: customCsp, autoInsertSpaceInButton, alert, affix, anchor, form, locale, componentSize, direction, space, splitter, virtual, dropdownMatchSelectWidth, popupMatchSelectWidth, popupOverflow, legacyLocale, parentContext, iconPrefixCls: customIconPrefixCls, theme, componentDisabled, segmented, statistic, spin, calendar, carousel, cascader, collapse, typography, checkbox, descriptions, divider, drawer, skeleton, steps, image, layout, list, mentions, modal, progress, result, slider, breadcrumb, masonry, menu, pagination, input, textArea, otp, empty, badge, radio, rate, ribbon, switch: SWITCH, transfer, avatar, message, tag, table, card, cardMeta, tabs, timeline, timePicker, upload, notification, tree, colorPicker, datePicker, rangePicker, flex, wave, dropdown, warning: warningConfig, tour, tooltip, popover, popconfirm, qrcode, floatButton, floatButtonGroup, variant, inputNumber, treeSelect, watermark } = props;
	// =================================== Context ===================================
	const getPrefixCls = reactExports.useCallback((suffixCls, customizePrefixCls) => {
		const { prefixCls } = props;
		if (customizePrefixCls) {
			return customizePrefixCls;
		}
		const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
		return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
	}, [parentContext.getPrefixCls, props.prefixCls]);
	const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || "anticon";
	const csp = customCsp || parentContext.csp;
	const mergedTheme = useTheme(theme, parentContext.theme, { a: getPrefixCls("") });
	const baseConfig = {
		csp,
		autoInsertSpaceInButton,
		alert,
		affix,
		anchor,
		locale: locale || legacyLocale,
		direction,
		space,
		splitter,
		virtual,
		popupMatchSelectWidth: popupMatchSelectWidth ?? dropdownMatchSelectWidth,
		popupOverflow,
		getPrefixCls,
		iconPrefixCls,
		theme: mergedTheme,
		segmented,
		statistic,
		spin,
		calendar,
		carousel,
		cascader,
		collapse,
		typography,
		checkbox,
		descriptions,
		divider,
		drawer,
		skeleton,
		steps,
		image,
		input,
		textArea,
		otp,
		layout,
		list,
		mentions,
		modal,
		progress,
		result,
		slider,
		breadcrumb,
		masonry,
		menu,
		pagination,
		empty,
		badge,
		radio,
		rate,
		ribbon,
		switch: SWITCH,
		transfer,
		avatar,
		message,
		tag,
		table,
		card,
		cardMeta,
		tabs,
		timeline,
		timePicker,
		upload,
		notification,
		tree,
		colorPicker,
		datePicker,
		rangePicker,
		flex,
		wave,
		dropdown,
		warning: warningConfig,
		tour,
		tooltip,
		popover,
		popconfirm,
		qrcode,
		floatButton,
		floatButtonGroup,
		variant,
		inputNumber,
		treeSelect,
		watermark
	};
	const config = { ...parentContext };
	Object.keys(baseConfig).forEach((key) => {
		if (baseConfig[key] !== void 0) {
			config[key] = baseConfig[key];
		}
	});
	// Pass the props used by `useContext` directly with child component.
	// These props should merged into `config`.
	PASSED_PROPS.forEach((propName) => {
		const propValue = props[propName];
		if (propValue) {
			config[propName] = propValue;
		}
	});
	if (typeof autoInsertSpaceInButton !== "undefined") {
		// merge deprecated api
		config.button = {
			autoInsertSpace: autoInsertSpaceInButton,
			...config.button
		};
	}
	// https://github.com/ant-design/ant-design/issues/27617
	const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
		const prevKeys = Object.keys(prevConfig);
		const currentKeys = Object.keys(currentConfig);
		return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
	});
	const { layer } = reactExports.useContext(StyleContext);
	const memoIconContextValue = reactExports.useMemo(() => ({
		prefixCls: iconPrefixCls,
		csp,
		layer: layer ? "antd" : void 0
	}), [
		iconPrefixCls,
		csp,
		layer
	]);
	let childNode = reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(IconStyle, {
		iconPrefixCls,
		csp
	}), reactExports.createElement(PropWarning, { dropdownMatchSelectWidth }), children);
	const validateMessages = reactExports.useMemo(() => merge$1(localeValues.b.a, memoedConfig.locale?.Form?.defaultValidateMessages || {}, memoedConfig.form?.validateMessages || {}, form?.validateMessages || {}), [memoedConfig, form?.validateMessages]);
	if (Object.keys(validateMessages).length > 0) {
		childNode = reactExports.createElement(ValidateMessagesContext.Provider, { value: validateMessages }, childNode);
	}
	if (locale) {
		childNode = reactExports.createElement(LocaleProvider, {
			locale,
			_ANT_MARK__: "internalMark"
		}, childNode);
	}
	{
		childNode = reactExports.createElement(IconContext.Provider, { value: memoIconContextValue }, childNode);
	}
	if (componentSize) {
		childNode = reactExports.createElement(SizeContextProvider, { size: componentSize }, childNode);
	}
	// =================================== Motion ===================================
	childNode = reactExports.createElement(MotionWrapper, null, childNode);
	// ================================ Tooltip Unique ===============================
	if (tooltip?.unique) {
		childNode = reactExports.createElement(UniqueProvider, null, childNode);
	}
	// ================================ Dynamic theme ================================
	const memoTheme = reactExports.useMemo(() => {
		const { algorithm, token, components, cssVar, ...rest } = mergedTheme || {};
		const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : defaultTheme;
		const parsedComponents = {};
		Object.entries(components || {}).forEach(([componentName, componentToken]) => {
			const parsedToken = { ...componentToken };
			if ("algorithm" in parsedToken) {
				if (parsedToken.algorithm === true) {
					parsedToken.theme = themeObj;
				} else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") {
					parsedToken.theme = createTheme(parsedToken.algorithm);
				}
				delete parsedToken.algorithm;
			}
			parsedComponents[componentName] = parsedToken;
		});
		const mergedToken = {
			...seedToken,
			...token
		};
		return {
			...rest,
			theme: themeObj,
			token: mergedToken,
			components: parsedComponents,
			override: {
				override: mergedToken,
				...parsedComponents
			},
			cssVar
		};
	}, [mergedTheme]);
	if (theme) {
		childNode = reactExports.createElement(DesignTokenContext.Provider, { value: memoTheme }, childNode);
	}
	// ================================== Warning ===================================
	if (memoedConfig.warning) {
		childNode = reactExports.createElement(WarningContext.Provider, { value: memoedConfig.warning }, childNode);
	}
	// =================================== Render ===================================
	if (componentDisabled !== void 0) {
		childNode = reactExports.createElement(DisabledContextProvider, { disabled: componentDisabled }, childNode);
	}
	return reactExports.createElement(ConfigContext.Provider, { value: memoedConfig }, childNode);
};
const ConfigProvider = (props) => {
	const context = reactExports.useContext(ConfigContext);
	const antLocale = reactExports.useContext(LocaleContext);
	return reactExports.createElement(ProviderChildren, {
		parentContext: context,
		legacyLocale: antLocale,
		...props
	});
};
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.config = setGlobalConfig;
ConfigProvider.useConfig = useConfig;
Object.defineProperty(ConfigProvider, "SizeContext", { get: () => {
	return SizeContext;
} });
// This icon file is generated automatically.
var LoadingOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "0 0 1024 1024",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" }
		}]
	},
	"name": "loading",
	"theme": "outlined"
};
var LoadingOutlinedSvg = LoadingOutlined$1;
function _extends$q() {
	_extends$q = Object.assign.bind();
	return _extends$q.apply(this, arguments);
}
const LoadingOutlined = (props, ref) => reactExports.createElement(Icon$1, _extends$q({}, props, {
	ref,
	icon: LoadingOutlinedSvg
}));
/**![loading](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk4OCA1NDhjLTE5LjkgMC0zNi0xNi4xLTM2LTM2IDAtNTkuNC0xMS42LTExNy0zNC42LTE3MS4zYTQ0MC40NSA0NDAuNDUgMCAwMC05NC4zLTEzOS45IDQzNy43MSA0MzcuNzEgMCAwMC0xMzkuOS05NC4zQzYyOSA4My42IDU3MS40IDcyIDUxMiA3MmMtMTkuOSAwLTM2LTE2LjEtMzYtMzZzMTYuMS0zNiAzNi0zNmM2OS4xIDAgMTM2LjIgMTMuNSAxOTkuMyA0MC4zQzc3Mi4zIDY2IDgyNyAxMDMgODc0IDE1MGM0NyA0NyA4My45IDEwMS44IDEwOS43IDE2Mi43IDI2LjcgNjMuMSA0MC4yIDEzMC4yIDQwLjIgMTk5LjMuMSAxOS45LTE2IDM2LTM1LjkgMzZ6IiAvPjwvc3ZnPg==) */
const RefIcon$6 = reactExports.forwardRef(LoadingOutlined);
const MARK = "__rc_react_root__";
// ========================== Render ==========================
function render(node, container) {
	const root = container[MARK] || clientExports.a(container);
	root.render(node);
	container[MARK] = root;
}
// ========================= Unmount ==========================
async function unmount(container) {
	// Delay to unmount to avoid React 18 sync warning
	return Promise.resolve().then(() => {
		container[MARK]?.unmount();
		delete container[MARK];
	});
}
const genWaveStyle = (token) => {
	const { componentCls, colorPrimary, antCls } = token;
	const [, varRef] = genCssVar(antCls, "wave");
	return { [componentCls]: {
		position: "absolute",
		background: "transparent",
		pointerEvents: "none",
		boxSizing: "border-box",
		color: varRef("color", colorPrimary),
		boxShadow: "0 0 0 0 currentcolor",
		opacity: .2,
		"&.wave-motion-appear": {
			transition: [`box-shadow 0.4s ${token.motionEaseOutCirc}`, `opacity 2s ${token.motionEaseOutCirc}`].join(","),
			"&-active": {
				boxShadow: "0 0 0 6px currentcolor",
				opacity: 0
			},
			"&.wave-quick": { transition: [`box-shadow ${token.motionDurationSlow} ${token.motionEaseInOut}`, `opacity ${token.motionDurationSlow} ${token.motionEaseInOut}`].join(",") }
		}
	} };
};
var useStyle$2 = genComponentStyleHook("Wave", genWaveStyle);
const TARGET_CLS = `${"ant"}-wave-target`;
function isValidWaveColor(color) {
	return color && typeof color === "string" && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && !/rgba\((?:\d*, ){3}0\)/.test(color) && color !== "transparent" && color !== "canvastext";
}
function getTargetWaveColor(node, colorSource = null) {
	const style = getComputedStyle(node);
	const { borderTopColor, borderColor, backgroundColor } = style;
	if (colorSource && isValidWaveColor(style[colorSource])) {
		return style[colorSource];
	}
	return [
		borderTopColor,
		borderColor,
		backgroundColor
	].find(isValidWaveColor) ?? null;
}
function validateNum(value) {
	return Number.isNaN(value) ? 0 : value;
}
const WaveEffect = (props) => {
	const { className, target, component, colorSource } = props;
	const divRef = reactExports.useRef(null);
	const { getPrefixCls } = reactExports.useContext(ConfigContext);
	const rootPrefixCls = getPrefixCls();
	const [varName] = genCssVar(rootPrefixCls, "wave");
	// ===================== Effect =====================
	const [color, setWaveColor] = reactExports.useState(null);
	const [borderRadius, setBorderRadius] = reactExports.useState([]);
	const [left, setLeft] = reactExports.useState(0);
	const [top, setTop] = reactExports.useState(0);
	const [width, setWidth] = reactExports.useState(0);
	const [height, setHeight] = reactExports.useState(0);
	const [enabled, setEnabled] = reactExports.useState(false);
	const waveStyle = {
		left,
		top,
		width,
		height,
		borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
	};
	if (color) {
		waveStyle[varName("color")] = color;
	}
	function syncPos() {
		const nodeStyle = getComputedStyle(target);
		// Get wave color from target
		setWaveColor(getTargetWaveColor(target, colorSource));
		const isStatic = nodeStyle.position === "static";
		// Rect
		const { borderLeftWidth, borderTopWidth } = nodeStyle;
		setLeft(isStatic ? target.offsetLeft : validateNum(-Number.parseFloat(borderLeftWidth)));
		setTop(isStatic ? target.offsetTop : validateNum(-Number.parseFloat(borderTopWidth)));
		setWidth(target.offsetWidth);
		setHeight(target.offsetHeight);
		// Get border radius
		const { borderTopLeftRadius, borderTopRightRadius, borderBottomLeftRadius, borderBottomRightRadius } = nodeStyle;
		setBorderRadius([
			borderTopLeftRadius,
			borderTopRightRadius,
			borderBottomRightRadius,
			borderBottomLeftRadius
		].map((radius) => validateNum(Number.parseFloat(radius))));
	}
	reactExports.useEffect(() => {
		if (target) {
			// We need delay to check position here
			// since UI may change after click
			const id = wrapperRaf(() => {
				syncPos();
				setEnabled(true);
			});
			// Add resize observer to follow size
			let resizeObserver;
			if (typeof ResizeObserver !== "undefined") {
				resizeObserver = new ResizeObserver(syncPos);
				resizeObserver.observe(target);
			}
			return () => {
				wrapperRaf.a(id);
				resizeObserver?.disconnect();
			};
		}
	}, [target]);
	if (!enabled) {
		return null;
	}
	const isSmallComponent = (component === "Checkbox" || component === "Radio") && target?.classList.contains(TARGET_CLS);
	return reactExports.createElement(CSSMotion, {
		visible: true,
		motionAppear: true,
		motionName: "wave-motion",
		motionDeadline: 5e3,
		onAppearEnd: (__unused_8577, event) => {
			if (event.deadline || event.propertyName === "opacity") {
				const holder = divRef.current?.parentElement;
				unmount(holder).then(() => {
					holder?.remove();
				});
			}
			return false;
		}
	}, ({ className: motionClassName }, ref) => reactExports.createElement("div", {
		ref: composeRef(divRef, ref),
		className: clsx(className, motionClassName, { "wave-quick": isSmallComponent }),
		style: waveStyle
	}));
};
const showWaveEffect = (target, info) => {
	const { component } = info;
	// Skip for unchecked checkbox
	if (component === "Checkbox" && !target.querySelector("input")?.checked) {
		return;
	}
	// Create holder
	const holder = document.createElement("div");
	holder.style.position = "absolute";
	holder.style.left = "0px";
	holder.style.top = "0px";
	target?.insertBefore(holder, target?.firstChild);
	render(reactExports.createElement(WaveEffect, {
		...info,
		target
	}), holder);
};
const useWave = (nodeRef, className, component, colorSource) => {
	const { wave } = reactExports.useContext(ConfigContext);
	const [, token, hashId] = useToken();
	const showWave = useEvent((event) => {
		const node = nodeRef.current;
		if (wave?.disabled || !node) {
			return;
		}
		const targetNode = node.querySelector(`.${TARGET_CLS}`) || node;
		const { showEffect } = wave || {};
		// Customize wave effect
		(showEffect || showWaveEffect)(targetNode, {
			className,
			token,
			component,
			event,
			hashId,
			colorSource
		});
	});
	const rafId = reactExports.useRef(null);
	// Clean up RAF on unmount to prevent memory leaks and stale callbacks
	reactExports.useEffect(() => () => {
		wrapperRaf.a(rafId.current);
	}, []);
	// Merge trigger event into one for each frame
	const showDebounceWave = (event) => {
		wrapperRaf.a(rafId.current);
		rafId.current = wrapperRaf(() => {
			showWave(event);
		});
	};
	return showDebounceWave;
};
const Wave = (props) => {
	const { children, disabled, component, colorSource } = props;
	const { getPrefixCls } = reactExports.useContext(ConfigContext);
	const containerRef = reactExports.useRef(null);
	// ============================== Style ===============================
	const prefixCls = getPrefixCls("wave");
	const hashId = useStyle$2(prefixCls);
	// =============================== Wave ===============================
	const showWave = useWave(containerRef, clsx(prefixCls, hashId), component, colorSource);
	// ============================== Effect ==============================
	React.useEffect(() => {
		const node = containerRef.current;
		if (!node || node.nodeType !== window.Node.ELEMENT_NODE || disabled) {
			return;
		}
		// Click handler
		const onClick = (e) => {
			// Fix radio button click twice
			if (!isVisible(e.target) || !node.getAttribute || node.getAttribute("disabled") || node.disabled || node.className.includes("disabled") && !node.className.includes("disabled:") || node.getAttribute("aria-disabled") === "true" || node.className.includes("-leave")) {
				return;
			}
			showWave(e);
		};
		// Bind events
		node.addEventListener("click", onClick, true);
		return () => {
			node.removeEventListener("click", onClick, true);
		};
	}, [disabled]);
	// ============================== Render ==============================
	if (!React.isValidElement(children)) {
		return children ?? null;
	}
	const ref = supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef;
	return cloneElement(children, { ref });
};
const useSize = (customSize) => {
	const size = React.useContext(SizeContext);
	const mergedSize = React.useMemo(() => {
		{
			{
				return customSize(size);
			}
		}
	}, [customSize, size]);
	return mergedSize;
};
const SpaceCompactItemContext = reactExports.createContext(null);
const useCompactItemContext = (prefixCls, direction) => {
	const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
	const compactItemClassnames = reactExports.useMemo(() => {
		if (!compactItemContext) {
			return "";
		}
		const { compactDirection, isFirstItem, isLastItem } = compactItemContext;
		const separator = compactDirection === "vertical" ? "-vertical-" : "-";
		return clsx(`${prefixCls}-compact${separator}item`, {
			[`${prefixCls}-compact${separator}first-item`]: isFirstItem,
			[`${prefixCls}-compact${separator}last-item`]: isLastItem,
			[`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
		});
	}, [
		prefixCls,
		direction,
		compactItemContext
	]);
	return {
		a: compactItemContext?.compactSize,
		b: compactItemClassnames
	};
};
const NoCompactStyle = (props) => {
	const { children } = props;
	return reactExports.createElement(SpaceCompactItemContext.Provider, { value: null }, children);
};
const GroupSizeContext = reactExports.createContext(void 0);
const ButtonGroup = (props) => {
	const { getPrefixCls, direction } = reactExports.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, size, className, ...others } = props;
	const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
	const [, , hashId] = useToken();
	const sizeCls = reactExports.useMemo(() => {
		switch (size) {
			case "large": return "lg";
			case "small": return "sm";
			default: return "";
		}
	}, [size]);
	const classes = clsx(prefixCls, {
		[`${prefixCls}-${sizeCls}`]: sizeCls,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, hashId);
	return reactExports.createElement(GroupSizeContext.Provider, { value: size }, reactExports.createElement("div", {
		...others,
		className: classes
	}));
};
const rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/;
const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isString(str) {
	return typeof str === "string";
}
function isUnBorderedButtonVariant(type) {
	return type === "text" || type === "link";
}
function splitCNCharsBySpace(child, needInserted, style, className) {
	if (!isNonNullable(child) || child === "") {
		return;
	}
	const SPACE = needInserted ? " " : "";
	if (typeof child !== "string" && typeof child !== "number" && isString(child.type) && isTwoCNChar(child.props.children)) {
		return cloneElement(child, (oriProps) => {
			const mergedCls = clsx(oriProps.className, className) || void 0;
			const mergedStyle = {
				...style,
				...oriProps.style
			};
			return {
				...oriProps,
				children: oriProps.children.split("").join(SPACE),
				className: mergedCls,
				style: mergedStyle
			};
		});
	}
	if (isString(child)) {
		return React.createElement("span", {
			className,
			style
		}, isTwoCNChar(child) ? child.split("").join(SPACE) : child);
	}
	if (isFragment(child)) {
		return React.createElement("span", {
			className,
			style
		}, child);
	}
	return cloneElement(child, (oriProps) => ({
		...oriProps,
		className: clsx(oriProps.className, className) || void 0,
		style: {
			...oriProps.style,
			...style
		}
	}));
}
function spaceChildren(children, needInserted, style, className) {
	let isPrevChildPure = false;
	const childList = [];
	React.Children.forEach(children, (child) => {
		const type = typeof child;
		const isCurrentChildPure = type === "string" || type === "number";
		if (isPrevChildPure && isCurrentChildPure) {
			const lastIndex = childList.length - 1;
			const lastChild = childList[lastIndex];
			childList[lastIndex] = `${lastChild}${child}`;
		} else {
			childList.push(child);
		}
		isPrevChildPure = isCurrentChildPure;
	});
	return React.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted, style, className));
}
[
	"default",
	"primary",
	"danger"
].concat(_toConsumableArray$8(PresetColors));
const IconWrapper = reactExports.forwardRef((props, ref) => {
	const { className, style, children, prefixCls } = props;
	const iconWrapperCls = clsx(`${prefixCls}-icon`, className);
	return React.createElement("span", {
		ref,
		className: iconWrapperCls,
		style
	}, children);
});
const InnerLoadingIcon = reactExports.forwardRef((props, ref) => {
	const { prefixCls, className, style, iconClassName } = props;
	const mergedIconCls = clsx(`${prefixCls}-loading-icon`, className);
	return React.createElement(IconWrapper, {
		prefixCls,
		className: mergedIconCls,
		style,
		ref
	}, React.createElement(RefIcon$6, { className: iconClassName }));
});
const getCollapsedWidth = () => ({
	width: 0,
	opacity: 0,
	transform: "scale(0)"
});
const getRealWidth = (node) => ({
	width: node.scrollWidth,
	opacity: 1,
	transform: "scale(1)"
});
const DefaultLoadingIcon = (props) => {
	const { prefixCls, loading, existIcon, className, style, mount } = props;
	const visible = !!loading;
	if (existIcon) {
		return React.createElement(InnerLoadingIcon, {
			prefixCls,
			className,
			style
		});
	}
	return React.createElement(CSSMotion, {
		visible,
		motionName: `${prefixCls}-loading-icon-motion`,
		motionAppear: !mount,
		motionEnter: !mount,
		motionLeave: !mount,
		removeOnLeave: true,
		onAppearStart: getCollapsedWidth,
		onAppearActive: getRealWidth,
		onEnterStart: getCollapsedWidth,
		onEnterActive: getRealWidth,
		onLeaveStart: getRealWidth,
		onLeaveActive: getCollapsedWidth
	}, ({ className: motionCls, style: motionStyle }, ref) => {
		const mergedStyle = {
			...style,
			...motionStyle
		};
		return React.createElement(InnerLoadingIcon, {
			prefixCls,
			className: clsx(className, motionCls),
			style: mergedStyle,
			ref
		});
	});
};
const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({ [`> span, > ${buttonTypeCls}`]: {
	"&:not(:last-child)": { [`&, & > ${buttonTypeCls}`]: { "&:not(:disabled)": { borderInlineEndColor: borderColor } } },
	"&:not(:first-child)": { [`&, & > ${buttonTypeCls}`]: { "&:not(:disabled)": { borderInlineStartColor: borderColor } } }
} });
const genGroupStyle$1 = (token) => {
	const { componentCls, fontSize, lineWidth, groupBorderColor, colorErrorHover } = token;
	return { [`${componentCls}-group`]: [
		{
			position: "relative",
			display: "inline-flex",
			[`> span, > ${componentCls}`]: {
				"&:not(:last-child)": { [`&, & > ${componentCls}`]: {
					borderStartEndRadius: 0,
					borderEndEndRadius: 0
				} },
				"&:not(:first-child)": {
					marginInlineStart: token.calc(lineWidth).mul(-1).equal(),
					[`&, & > ${componentCls}`]: {
						borderStartStartRadius: 0,
						borderEndStartRadius: 0
					}
				}
			},
			[componentCls]: {
				position: "relative",
				zIndex: 1,
				"&:hover, &:focus, &:active": { zIndex: 2 },
				"&[disabled]": { zIndex: 0 }
			},
			[`${componentCls}-icon-only`]: { fontSize }
		},
		genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
		genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
	] };
};
const getRoundNumber = (value) => Math.round(Number(value || 0));
const convertHsb2Hsv = (color) => {
	if (color instanceof FastColor) {
		return color;
	}
	if (color && typeof color === "object" && "h" in color && "b" in color) {
		const { b, ...resets } = color;
		return {
			...resets,
			v: b
		};
	}
	if (typeof color === "string" && /hsb/.test(color)) {
		return color.replace(/hsb/, "hsv");
	}
	return color;
};
class Color extends FastColor {
	constructor(color) {
		super(convertHsb2Hsv(color));
	}
	toHsbString() {
		const hsb = this.toHsb();
		const saturation = getRoundNumber(hsb.s * 100);
		const lightness = getRoundNumber(hsb.b * 100);
		const hue = getRoundNumber(hsb.h);
		const alpha = hsb.a;
		const hsbString = `hsb(${hue}, ${saturation}%, ${lightness}%)`;
		const hsbaString = `hsba(${hue}, ${saturation}%, ${lightness}%, ${alpha.toFixed(alpha === 0 ? 0 : 2)})`;
		return alpha === 1 ? hsbString : hsbaString;
	}
	toHsb() {
		const { v, ...resets } = this.toHsv();
		return {
			...resets,
			b: v,
			a: this.a
		};
	}
}
const generateColor = () => {
	return new Color("#1677ff");
};
generateColor();
const toHexFormat = (value, alpha) => value?.replace(/[^0-9a-f]/gi, "").slice(0, alpha ? 8 : 6) || "";
const getHex = (value, alpha) => value ? toHexFormat(value, alpha) : "";
let AggregationColor = function() {
	function AggregationColor(color) {
		_classCallCheck$1(this, AggregationColor);
		this.cleared = false;
		// Clone from another AggregationColor
		if (color instanceof AggregationColor) {
			this.metaColor = color.metaColor.clone();
			this.colors = color.colors?.map((info) => ({
				color: new AggregationColor(info.color),
				percent: info.percent
			}));
			this.cleared = color.cleared;
			return;
		}
		const isArray = Array.isArray(color);
		if (isArray && color.length) {
			this.colors = color.map(({ color: c, percent }) => ({
				color: new AggregationColor(c),
				percent
			}));
			this.metaColor = new Color(this.colors[0].color.metaColor);
		} else {
			this.metaColor = new Color(isArray ? "" : color);
		}
		if (!color || isArray && !this.colors) {
			this.metaColor = this.metaColor.setA(0);
			this.cleared = true;
		}
	}
	return _createClass$1(AggregationColor, [
		{
			key: "toHsb",
			value: function() {
				return this.metaColor.toHsb();
			}
		},
		{
			key: "toHsbString",
			value: function() {
				return this.metaColor.toHsbString();
			}
		},
		{
			key: "toHex",
			value: function() {
				return getHex(this.toHexString(), this.metaColor.a < 1);
			}
		},
		{
			key: "toHexString",
			value: function() {
				return this.metaColor.toHexString();
			}
		},
		{
			key: "toRgb",
			value: function() {
				return this.metaColor.toRgb();
			}
		},
		{
			key: "toRgbString",
			value: function() {
				return this.metaColor.toRgbString();
			}
		},
		{
			key: "isGradient",
			value: function() {
				return !!this.colors && !this.cleared;
			}
		},
		{
			key: "getColors",
			value: function() {
				return this.colors || [{
					color: this,
					percent: 0
				}];
			}
		},
		{
			key: "toCssString",
			value: function() {
				const { colors } = this;
				// CSS line-gradient
				if (colors) {
					const colorsStr = colors.map((c) => `${c.color.toRgbString()} ${c.percent}%`).join(", ");
					return `linear-gradient(90deg, ${colorsStr})`;
				}
				return this.metaColor.toRgbString();
			}
		},
		{
			key: "equals",
			value: function(color) {
				if (!color || this.isGradient() !== color.isGradient()) {
					return false;
				}
				if (!this.isGradient()) {
					return this.toHexString() === color.toHexString();
				}
				return this.colors.length === color.colors.length && this.colors.every((c, i) => {
					const target = color.colors[i];
					return c.percent === target.percent && c.color.equals(target.color);
				});
			}
		}
	]);
}();
function _extends$p() {
	return _extends$p = Object.assign.bind(), _extends$p.apply(null, arguments);
}
const initMotionCommon = (duration) => ({
	animationDuration: duration,
	animationFillMode: "both"
});
// FIXME: origin less code seems same as initMotionCommon. Maybe we can safe remove
const initMotionCommonLeave = (duration) => ({
	animationDuration: duration,
	animationFillMode: "both"
});
const initMotion = (motionCls, inKeyframes, outKeyframes, duration) => {
	return {
		[`
      ${""}${motionCls}-enter,
      ${""}${motionCls}-appear
    `]: {
			...initMotionCommon(duration),
			animationPlayState: "paused"
		},
		[`${""}${motionCls}-leave`]: {
			...initMotionCommonLeave(duration),
			animationPlayState: "paused"
		},
		[`
      ${""}${motionCls}-enter${motionCls}-enter-active,
      ${""}${motionCls}-appear${motionCls}-appear-active
    `]: {
			animationName: inKeyframes,
			animationPlayState: "running"
		},
		[`${""}${motionCls}-leave${motionCls}-leave-active`]: {
			animationName: outKeyframes,
			animationPlayState: "running",
			pointerEvents: "none"
		}
	};
};
const moveDownIn = new Keyframe("antMoveDownIn", {
	"0%": {
		transform: "translate3d(0, 100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveDownOut = new Keyframe("antMoveDownOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(0, 100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
const moveUpIn = new Keyframe("antMoveUpIn", {
	"0%": {
		transform: "translate3d(0, -100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveUpOut = new Keyframe("antMoveUpOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(0, -100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
const moveMotion = {
	"move-up": {
		a: moveUpIn,
		b: moveUpOut
	},
	"move-down": {
		a: moveDownIn,
		b: moveDownOut
	}
};
const initMoveMotion = (token, motionName) => {
	const { antCls } = token;
	const motionCls = `${antCls}-${motionName}`;
	const { a: inKeyframes, b: outKeyframes } = moveMotion[motionName];
	return [initMotion(motionCls, inKeyframes, outKeyframes, token.motionDurationMid), {
		[`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
			opacity: 0,
			animationTimingFunction: token.motionEaseOutCirc
		},
		[`${motionCls}-leave`]: { animationTimingFunction: token.motionEaseInOutCirc }
	}];
};
const slideUpIn = new Keyframe("antSlideUpIn", {
	"0%": {
		transform: "scaleY(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	},
	"100%": {
		transform: "scaleY(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	}
});
const slideUpOut = new Keyframe("antSlideUpOut", {
	"0%": {
		transform: "scaleY(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	},
	"100%": {
		transform: "scaleY(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	}
});
const slideDownIn = new Keyframe("antSlideDownIn", {
	"0%": {
		transform: "scaleY(0.8)",
		transformOrigin: "100% 100%",
		opacity: 0
	},
	"100%": {
		transform: "scaleY(1)",
		transformOrigin: "100% 100%",
		opacity: 1
	}
});
const slideDownOut = new Keyframe("antSlideDownOut", {
	"0%": {
		transform: "scaleY(1)",
		transformOrigin: "100% 100%",
		opacity: 1
	},
	"100%": {
		transform: "scaleY(0.8)",
		transformOrigin: "100% 100%",
		opacity: 0
	}
});
const slideMotion = {
	"slide-up": {
		a: slideUpIn,
		b: slideUpOut
	},
	"slide-down": {
		a: slideDownIn,
		b: slideDownOut
	}
};
const initSlideMotion = (token, motionName) => {
	const { antCls } = token;
	const motionCls = `${antCls}-${motionName}`;
	const { a: inKeyframes, b: outKeyframes } = slideMotion[motionName];
	return [initMotion(motionCls, inKeyframes, outKeyframes, token.motionDurationMid), {
		[`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
			transform: "scale(0)",
			transformOrigin: "0% 0%",
			opacity: 0,
			animationTimingFunction: token.motionEaseOutQuint,
			"&-prepare": { transform: "scale(1)" }
		},
		[`${motionCls}-leave`]: { animationTimingFunction: token.motionEaseInQuint }
	}];
};
const isBright = (value) => {
	const { r, g, b, a } = value.toRgb();
	const hsv = new Color(value.toRgbString()).onBackground("#fff").toHsv();
	if (a <= .5) {
		// Adapted to dark mode
		return hsv.v > .5;
	}
	return r * .299 + g * .587 + b * .114 > 192;
};
const prepareToken = (token) => {
	const { paddingInline, onlyIconSize, borderColorDisabled } = token;
	const buttonToken = merge(token, {
		buttonPaddingHorizontal: paddingInline,
		buttonPaddingVertical: 0,
		buttonIconOnlyFontSize: onlyIconSize,
		colorBorderDisabled: borderColorDisabled
	});
	return buttonToken;
};
const prepareComponentToken$1 = (token) => {
	const contentFontSize = token.contentFontSize ?? token.fontSize;
	const contentFontSizeSM = token.contentFontSizeSM ?? token.fontSize;
	const contentFontSizeLG = token.contentFontSizeLG ?? token.fontSizeLG;
	const contentLineHeight = token.contentLineHeight ?? getLineHeight(contentFontSize);
	const contentLineHeightSM = token.contentLineHeightSM ?? getLineHeight(contentFontSizeSM);
	const contentLineHeightLG = token.contentLineHeightLG ?? getLineHeight(contentFontSizeLG);
	const solidTextColor = isBright(new AggregationColor(token.colorBgSolid)) ? "#000" : "#fff";
	const shadowColorTokens = PresetColors.reduce((prev, colorKey) => ({
		...prev,
		[`${colorKey}ShadowColor`]: `0 ${unit$1(token.controlOutlineWidth)} 0 ${getAlphaColor(token[`${colorKey}1`], token.colorBgContainer)}`
	}), {});
	const defaultBgDisabled = token.colorBgContainerDisabled;
	const dashedBgDisabled = token.colorBgContainerDisabled;
	return {
		...shadowColorTokens,
		fontWeight: 400,
		iconGap: token.marginXS,
		defaultShadow: `0 ${token.controlOutlineWidth}px 0 ${token.controlTmpOutline}`,
		primaryShadow: `0 ${token.controlOutlineWidth}px 0 ${token.controlOutline}`,
		dangerShadow: `0 ${token.controlOutlineWidth}px 0 ${token.colorErrorOutline}`,
		primaryColor: token.colorTextLightSolid,
		dangerColor: token.colorTextLightSolid,
		borderColorDisabled: token.colorBorderDisabled,
		defaultGhostColor: token.colorBgContainer,
		ghostBg: "transparent",
		defaultGhostBorderColor: token.colorBgContainer,
		paddingInline: token.paddingContentHorizontal - token.lineWidth,
		paddingInlineLG: token.paddingContentHorizontal - token.lineWidth,
		paddingInlineSM: 8 - token.lineWidth,
		onlyIconSize: "inherit",
		onlyIconSizeSM: "inherit",
		onlyIconSizeLG: "inherit",
		groupBorderColor: token.colorPrimaryHover,
		linkHoverBg: "transparent",
		textTextColor: token.colorText,
		textTextHoverColor: token.colorText,
		textTextActiveColor: token.colorText,
		textHoverBg: token.colorFillTertiary,
		defaultColor: token.colorText,
		defaultBg: token.colorBgContainer,
		defaultBorderColor: token.colorBorder,
		defaultBorderColorDisabled: token.colorBorder,
		defaultHoverBg: token.colorBgContainer,
		defaultHoverColor: token.colorPrimaryHover,
		defaultHoverBorderColor: token.colorPrimaryHover,
		defaultActiveBg: token.colorBgContainer,
		defaultActiveColor: token.colorPrimaryActive,
		defaultActiveBorderColor: token.colorPrimaryActive,
		solidTextColor,
		contentFontSize,
		contentFontSizeSM,
		contentFontSizeLG,
		contentLineHeight,
		contentLineHeightSM,
		contentLineHeightLG,
		paddingBlock: Math.max((token.controlHeight - contentFontSize * contentLineHeight) / 2 - token.lineWidth, 0),
		paddingBlockSM: Math.max((token.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token.lineWidth, 0),
		paddingBlockLG: Math.max((token.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token.lineWidth, 0),
		defaultBgDisabled,
		dashedBgDisabled
	};
};
const genVariantStyle = (token) => {
	const { componentCls, antCls } = token;
	const [varName, varRef] = genCssVar(antCls, "btn");
	return { [componentCls]: [
		(
		// ==============================================================
		// ==                         Variable                         ==
		// ==============================================================
		{
			[varName("border-width")]: "1px",
			[varName("border-color")]: "#000",
			[varName("border-color-hover")]: varRef("border-color"),
			[varName("border-color-active")]: varRef("border-color"),
			[varName("border-color-disabled")]: varRef("border-color"),
			[varName("border-style")]: "solid",
			[varName("text-color")]: "#000",
			[varName("text-color-hover")]: varRef("text-color"),
			[varName("text-color-active")]: varRef("text-color"),
			[varName("text-color-disabled")]: varRef("text-color"),
			[varName("bg-color")]: "#ddd",
			[varName("bg-color-hover")]: varRef("bg-color"),
			[varName("bg-color-active")]: varRef("bg-color"),
			[varName("bg-color-disabled")]: token.colorBgContainerDisabled,
			[varName("bg-color-container")]: token.colorBgContainer,
			[varName("shadow")]: "none"
		}),
		(
		// ==============================================================
		// ==                         Template                         ==
		// ==============================================================
		{
			border: [
				varRef("border-width"),
				varRef("border-style"),
				varRef("border-color")
			].join(" "),
			color: varRef("text-color"),
			backgroundColor: varRef("bg-color"),
			[`&:not(:disabled):not(${componentCls}-disabled)`]: {
				"&:hover": {
					border: [
						varRef("border-width"),
						varRef("border-style"),
						varRef("border-color-hover")
					].join(" "),
					color: varRef("text-color-hover"),
					backgroundColor: varRef("bg-color-hover")
				},
				"&:active": {
					border: [
						varRef("border-width"),
						varRef("border-style"),
						varRef("border-color-active")
					].join(" "),
					color: varRef("text-color-active"),
					backgroundColor: varRef("bg-color-active")
				}
			}
		}),
		(
		// ==============================================================
		// ==                         Variants                         ==
		// ==============================================================
		{
			[`&${componentCls}-variant-solid`]: {
				[varName("solid-bg-color")]: varRef("color-base"),
				[varName("solid-bg-color-hover")]: varRef("color-hover"),
				[varName("solid-bg-color-active")]: varRef("color-active"),
				[varName("border-color")]: "transparent",
				[varName("text-color")]: token.colorTextLightSolid,
				[varName("bg-color")]: varRef("solid-bg-color"),
				[varName("bg-color-hover")]: varRef("solid-bg-color-hover"),
				[varName("bg-color-active")]: varRef("solid-bg-color-active"),
				boxShadow: varRef("shadow")
			},
			[`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
				[varName("border-color")]: varRef("color-base"),
				[varName("border-color-hover")]: varRef("color-hover"),
				[varName("border-color-active")]: varRef("color-active"),
				[varName("bg-color")]: varRef("bg-color-container"),
				[varName("text-color")]: varRef("color-base"),
				[varName("text-color-hover")]: varRef("color-hover"),
				[varName("text-color-active")]: varRef("color-active"),
				boxShadow: varRef("shadow")
			},
			[`&${componentCls}-variant-dashed`]: {
				[varName("border-style")]: "dashed",
				[varName("bg-color-disabled")]: token.dashedBgDisabled
			},
			[`&${componentCls}-variant-filled`]: {
				[varName("border-color")]: "transparent",
				[varName("text-color")]: varRef("color-base"),
				[varName("bg-color")]: varRef("color-light"),
				[varName("bg-color-hover")]: varRef("color-light-hover"),
				[varName("bg-color-active")]: varRef("color-light-active")
			},
			[`&${componentCls}-variant-text, &${componentCls}-variant-link`]: {
				[varName("border-color")]: "transparent",
				[varName("text-color")]: varRef("color-base"),
				[varName("text-color-hover")]: varRef("color-hover"),
				[varName("text-color-active")]: varRef("color-active"),
				[varName("bg-color")]: "transparent",
				[varName("bg-color-hover")]: "transparent",
				[varName("bg-color-active")]: "transparent",
				[`&:disabled, &${token.componentCls}-disabled`]: {
					background: "transparent",
					borderColor: "transparent"
				}
			},
			[`&${componentCls}-variant-text`]: {
				[varName("bg-color-hover")]: varRef("color-light"),
				[varName("bg-color-active")]: varRef("color-light-active")
			}
		}),
		(
		// ==============================================================
		// ==                          Colors                          ==
		// ==============================================================
		{
			[`&${componentCls}-variant-link`]: {
				[varName("color-base")]: token.colorLink,
				[varName("color-hover")]: token.colorLinkHover,
				[varName("color-active")]: token.colorLinkActive
			},
			[`&${componentCls}-color-primary`]: {
				[varName("color-base")]: token.colorPrimary,
				[varName("color-hover")]: token.colorPrimaryHover,
				[varName("color-active")]: token.colorPrimaryActive,
				[varName("color-light")]: token.colorPrimaryBg,
				[varName("color-light-hover")]: token.colorPrimaryBgHover,
				[varName("color-light-active")]: token.colorPrimaryBorder,
				[varName("shadow")]: token.primaryShadow,
				[`&${componentCls}-variant-solid`]: {
					[varName("text-color")]: token.primaryColor,
					[varName("text-color-hover")]: varRef("text-color"),
					[varName("text-color-active")]: varRef("text-color")
				}
			},
			[`&${componentCls}-color-dangerous`]: {
				[varName("color-base")]: token.colorError,
				[varName("color-hover")]: token.colorErrorHover,
				[varName("color-active")]: token.colorErrorActive,
				[varName("color-light")]: token.colorErrorBg,
				[varName("color-light-hover")]: token.colorErrorBgFilledHover,
				[varName("color-light-active")]: token.colorErrorBgActive,
				[varName("shadow")]: token.dangerShadow,
				[`&${componentCls}-variant-solid`]: {
					[varName("text-color")]: token.dangerColor,
					[varName("text-color-hover")]: varRef("text-color"),
					[varName("text-color-active")]: varRef("text-color")
				}
			},
			[`&${componentCls}-color-default`]: {
				[varName("solid-bg-color")]: token.colorBgSolid,
				[varName("solid-bg-color-hover")]: token.colorBgSolidHover,
				[varName("solid-bg-color-active")]: token.colorBgSolidActive,
				[varName("color-base")]: token.defaultBorderColor,
				[varName("color-hover")]: token.defaultHoverBorderColor,
				[varName("color-active")]: token.defaultActiveBorderColor,
				[varName("color-light")]: token.colorFillTertiary,
				[varName("color-light-hover")]: token.colorFillSecondary,
				[varName("color-light-active")]: token.colorFill,
				[varName("text-color")]: token.defaultColor,
				[varName("text-color-hover")]: token.defaultHoverColor,
				[varName("text-color-active")]: token.defaultActiveColor,
				[varName("shadow")]: token.defaultShadow,
				[`&${componentCls}-variant-solid`]: {
					[varName("text-color")]: token.solidTextColor,
					[varName("text-color-hover")]: varRef("text-color"),
					[varName("text-color-active")]: varRef("text-color")
				},
				[`&${componentCls}-variant-filled, &${componentCls}-variant-text`]: {
					[varName("text-color-hover")]: varRef("text-color"),
					[varName("text-color-active")]: varRef("text-color")
				},
				[`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
					[varName("text-color")]: token.defaultColor,
					[varName("text-color-hover")]: token.defaultHoverColor,
					[varName("text-color-active")]: token.defaultActiveColor,
					[varName("bg-color-container")]: token.defaultBg,
					[varName("bg-color-hover")]: token.defaultHoverBg,
					[varName("bg-color-active")]: token.defaultActiveBg
				},
				[`&${componentCls}-variant-text`]: {
					[varName("text-color")]: token.textTextColor,
					[varName("text-color-hover")]: token.textTextHoverColor,
					[varName("text-color-active")]: token.textTextActiveColor,
					[varName("bg-color-hover")]: token.textHoverBg
				},
				[`&${componentCls}-background-ghost`]: { [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
					[varName("text-color")]: token.defaultGhostColor,
					[varName("border-color")]: token.defaultGhostBorderColor
				} }
			}
		}),
		PresetColors.map((colorKey) => {
			const darkColor = token[`${colorKey}6`];
			const lightColor = token[`${colorKey}1`];
			const hoverColor = token[`${colorKey}5`];
			const lightHoverColor = token[`${colorKey}2`];
			const lightActiveColor = token[`${colorKey}3`];
			const activeColor = token[`${colorKey}7`];
			const shadowColor = token[`${colorKey}ShadowColor`];
			return { [`&${componentCls}-color-${colorKey}`]: {
				[varName("color-base")]: darkColor,
				[varName("color-hover")]: hoverColor,
				[varName("color-active")]: activeColor,
				[varName("color-light")]: lightColor,
				[varName("color-light-hover")]: lightHoverColor,
				[varName("color-light-active")]: lightActiveColor,
				[varName("shadow")]: shadowColor
			} };
		}),
		(
		// ==============================================================
		// ==                         Disabled                         ==
		// ==============================================================
		{ [`&:disabled, &${token.componentCls}-disabled`]: {
			cursor: "not-allowed",
			borderColor: token.colorBorderDisabled,
			background: varRef("bg-color-disabled"),
			color: token.colorTextDisabled,
			boxShadow: "none"
		} }),
		(
		// ==============================================================
		// ==                          Ghost                           ==
		// ==============================================================
		{ [`&${componentCls}-background-ghost`]: {
			[varName("bg-color")]: "transparent",
			[varName("shadow")]: "none"
		} })
	] };
};
// ============================== Shared ==============================
const genSharedButtonStyle = (token) => {
	const { componentCls, iconCls, fontWeight, opacityLoading, motionDurationSlow, motionEaseInOut, iconGap, calc } = token;
	return { [componentCls]: {
		outline: "none",
		position: "relative",
		display: "inline-flex",
		gap: iconGap,
		alignItems: "center",
		justifyContent: "center",
		fontWeight,
		whiteSpace: "nowrap",
		textAlign: "center",
		backgroundImage: "none",
		cursor: "pointer",
		transition: `all ${token.motionDurationMid} ${token.motionEaseInOut}`,
		userSelect: "none",
		touchAction: "manipulation",
		"&:disabled > *": { pointerEvents: "none" },
		[`${componentCls}-icon > svg`]: resetIcon(),
		"> a": { color: "currentColor" },
		"&:not(:disabled)": genFocusStyle(token),
		[`&${componentCls}-two-chinese-chars::first-letter`]: { letterSpacing: "0.34em" },
		[`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
			marginInlineEnd: "-0.34em",
			letterSpacing: "0.34em"
		},
		[`&${componentCls}-icon-only`]: {
			paddingInline: 0,
			[`&${componentCls}-compact-item`]: { flex: "none" }
		},
		[`&${componentCls}-loading`]: {
			opacity: opacityLoading,
			cursor: "default"
		},
		[`${componentCls}-loading-icon`]: { transition: [
			"width",
			"opacity",
			"margin"
		].map((transition) => `${transition} ${motionDurationSlow} ${motionEaseInOut}`).join(",") },
		[`&:not(${componentCls}-icon-end)`]: { [`${componentCls}-loading-icon-motion`]: {
			"&-appear-start, &-enter-start": { marginInlineEnd: calc(iconGap).mul(-1).equal() },
			"&-appear-active, &-enter-active": { marginInlineEnd: 0 },
			"&-leave-start": { marginInlineEnd: 0 },
			"&-leave-active": { marginInlineEnd: calc(iconGap).mul(-1).equal() }
		} },
		"&-icon-end": {
			flexDirection: "row-reverse",
			[`${componentCls}-loading-icon-motion`]: {
				"&-appear-start, &-enter-start": { marginInlineStart: calc(iconGap).mul(-1).equal() },
				"&-appear-active, &-enter-active": { marginInlineStart: 0 },
				"&-leave-start": { marginInlineStart: 0 },
				"&-leave-active": { marginInlineStart: calc(iconGap).mul(-1).equal() }
			}
		}
	} };
};
// ============================== Shape ===============================
const genCircleButtonStyle = (token) => ({
	minWidth: token.controlHeight,
	paddingInline: 0,
	borderRadius: "50%"
});
// =============================== Size ===============================
const genButtonStyle = (token, prefixCls = "") => {
	const { componentCls, controlHeight, fontSize, borderRadius, buttonPaddingHorizontal, iconCls, buttonPaddingVertical, buttonIconOnlyFontSize } = token;
	return [
		{ [prefixCls]: {
			fontSize,
			height: controlHeight,
			padding: `${unit$1(buttonPaddingVertical)} ${unit$1(buttonPaddingHorizontal)}`,
			borderRadius,
			[`&${componentCls}-icon-only`]: {
				width: controlHeight,
				[iconCls]: { fontSize: buttonIconOnlyFontSize }
			}
		} },
		(
		// Shape - patch prefixCls again to override solid border radius style
		{ [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token) }),
		{ [`${componentCls}${componentCls}-round${prefixCls}`]: {
			borderRadius: token.controlHeight,
			[`&:not(${componentCls}-icon-only)`]: { paddingInline: token.buttonPaddingHorizontal }
		} }
	];
};
const genSizeBaseButtonStyle = (token) => {
	const baseToken = merge(token, { fontSize: token.contentFontSize });
	return genButtonStyle(baseToken, token.componentCls);
};
const genSizeSmallButtonStyle = (token) => {
	const smallToken = merge(token, {
		controlHeight: token.controlHeightSM,
		fontSize: token.contentFontSizeSM,
		padding: token.paddingXS,
		buttonPaddingHorizontal: token.paddingInlineSM,
		buttonPaddingVertical: 0,
		borderRadius: token.borderRadiusSM,
		buttonIconOnlyFontSize: token.onlyIconSizeSM
	});
	return genButtonStyle(smallToken, `${token.componentCls}-sm`);
};
const genSizeLargeButtonStyle = (token) => {
	const largeToken = merge(token, {
		controlHeight: token.controlHeightLG,
		fontSize: token.contentFontSizeLG,
		buttonPaddingHorizontal: token.paddingInlineLG,
		buttonPaddingVertical: 0,
		borderRadius: token.borderRadiusLG,
		buttonIconOnlyFontSize: token.onlyIconSizeLG
	});
	return genButtonStyle(largeToken, `${token.componentCls}-lg`);
};
const genBlockButtonStyle = (token) => {
	const { componentCls } = token;
	return { [componentCls]: { [`&${componentCls}-block`]: { width: "100%" } } };
};
// ============================== Export ==============================
var useStyle$1 = genStyleHooks("Button", (token) => {
	const buttonToken = prepareToken(token);
	return [
		genSharedButtonStyle(buttonToken),
		genSizeBaseButtonStyle(buttonToken),
		genSizeSmallButtonStyle(buttonToken),
		genSizeLargeButtonStyle(buttonToken),
		genBlockButtonStyle(buttonToken),
		genVariantStyle(buttonToken),
		genGroupStyle$1(buttonToken)
	];
}, prepareComponentToken$1, { unitless: {
	fontWeight: true,
	contentLineHeight: true,
	contentLineHeightSM: true,
	contentLineHeightLG: true
} });
// handle border collapse
function compactItemBorder(token, parentCls, options, prefixCls) {
	const { focusElCls, focus } = options;
	const hoverEffects = [
		"hover",
		focus ? "focus" : null,
		"active"
	].filter(Boolean).map((n) => `&:${n} ${""}`).join(",");
	return {
		[`&-item:not(${parentCls}-last-item)`]: { marginInlineEnd: token.calc(token.lineWidth).mul(-1).equal() },
		[`&-item:not(${prefixCls}-status-success)`]: { zIndex: 2 },
		"&-item": {
			[hoverEffects]: { zIndex: 3 },
			...focusElCls ? { [`&${focusElCls}`]: { zIndex: 3 } } : {},
			[`&[disabled] ${""}`]: { zIndex: 0 }
		}
	};
}
// handle border-radius
function compactItemBorderRadius(prefixCls, parentCls) {
	return {
		[`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${""}`]: { borderRadius: 0 },
		[`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: { [`& ${""}, &${prefixCls}-sm ${""}, &${prefixCls}-lg ${""}`]: {
			borderStartEndRadius: 0,
			borderEndEndRadius: 0
		} },
		[`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: { [`& ${""}, &${prefixCls}-sm ${""}, &${prefixCls}-lg ${""}`]: {
			borderStartStartRadius: 0,
			borderEndStartRadius: 0
		} }
	};
}
function genCompactItemStyle(token, options = { focus: true }) {
	const { componentCls } = token;
	const mergedComponentCls = componentCls;
	const compactCls = `${mergedComponentCls}-compact`;
	return { [compactCls]: {
		...compactItemBorder(token, compactCls, options, mergedComponentCls),
		...compactItemBorderRadius(mergedComponentCls, compactCls)
	} };
}
function compactItemVerticalBorder(token, parentCls, prefixCls) {
	return {
		[`&-item:not(${parentCls}-last-item)`]: { marginBottom: token.calc(token.lineWidth).mul(-1).equal() },
		[`&-item:not(${prefixCls}-status-success)`]: { zIndex: 2 },
		"&-item": {
			"&:hover,&:focus,&:active": { zIndex: 3 },
			"&[disabled]": { zIndex: 0 }
		}
	};
}
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
	return {
		[`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: { borderRadius: 0 },
		[`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: { [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
			borderEndEndRadius: 0,
			borderEndStartRadius: 0
		} },
		[`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: { [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
			borderStartStartRadius: 0,
			borderStartEndRadius: 0
		} }
	};
}
function genCompactItemVerticalStyle(token) {
	const compactCls = `${token.componentCls}-compact-vertical`;
	return { [compactCls]: {
		...compactItemVerticalBorder(token, compactCls, token.componentCls),
		...compactItemBorderVerticalRadius(token.componentCls, compactCls)
	} };
}
const genButtonCompactStyle = (token) => {
	const { antCls, componentCls, lineWidth, calc, colorBgContainer } = token;
	const solidSelector = `${componentCls}-variant-solid:not([disabled])`;
	const insetOffset = calc(lineWidth).mul(-1).equal();
	const [varName, varRef] = genCssVar(antCls, "btn");
	const getCompactBorderStyle = (vertical) => {
		const itemCls = `${componentCls}-compact${vertical ? "-vertical" : ""}-item`;
		return { [itemCls]: {
			[varName("compact-connect-border-color")]: varRef("bg-color-hover"),
			[`&${solidSelector}`]: {
				transition: "none",
				[`& + ${solidSelector}:before`]: [{
					position: "absolute",
					backgroundColor: varRef("compact-connect-border-color"),
					content: "\"\""
				}, vertical ? {
					top: insetOffset,
					insetInline: insetOffset,
					height: lineWidth
				} : {
					insetBlock: insetOffset,
					insetInlineStart: insetOffset,
					width: lineWidth
				}],
				"&:hover:before": { display: "none" }
			}
		} };
	};
	// Special styles for solid Button
	return [
		getCompactBorderStyle(),
		getCompactBorderStyle(true),
		{ [`${solidSelector}${componentCls}-color-default`]: { [varName("compact-connect-border-color")]: `color-mix(in srgb, ${varRef("bg-color-hover")} 75%, ${colorBgContainer})` } }
	];
};
// ============================== Export ==============================
var Compact = genSubStyleComponent(["Button", "compact"], (token) => {
	const buttonToken = prepareToken(token);
	return [
		genCompactItemStyle(buttonToken),
		genCompactItemVerticalStyle(buttonToken),
		genButtonCompactStyle(buttonToken)
	];
}, prepareComponentToken$1);
function getLoadingConfig(loading) {
	if (typeof loading === "object" && loading) {
		let delay = loading.delay;
		delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
		return {
			loading: delay <= 0,
			delay
		};
	}
	return {
		loading: !!loading,
		delay: 0
	};
}
const ButtonTypeMap = {
	default: ["default", "outlined"],
	primary: ["primary", "solid"],
	dashed: ["default", "dashed"],
	link: ["link", "link"],
	text: ["default", "text"]
};
const InternalCompoundedButton = React.forwardRef((props, ref) => {
	const { _skipSemantic, loading = false, prefixCls: customizePrefixCls, color, variant, type, danger = false, shape: customizeShape, size: customizeSize, disabled: customDisabled, className, rootClassName, children, icon, iconPosition, iconPlacement, ghost = false, block = false, htmlType = "button", classNames, styles, style, autoInsertSpace, autoFocus, ...rest } = props;
	const childNodes = toArray$3(children);
	// https://github.com/ant-design/ant-design/issues/47605
	// Compatible with original `type` behavior
	const mergedType = type || "default";
	const { button } = React.useContext(ConfigContext);
	const shape = customizeShape || button?.shape || "default";
	const [parsedColor, parsedVariant] = reactExports.useMemo(() => {
		// >>>>> Local
		// Color & Variant
		if (color && variant) {
			return [color, variant];
		}
		// Sugar syntax
		if (type || danger) {
			const colorVariantPair = ButtonTypeMap[mergedType] || [];
			if (danger) {
				return ["danger", colorVariantPair[1]];
			}
			return colorVariantPair;
		}
		// >>> Context fallback
		if (button?.color && button?.variant) {
			return [button.color, button.variant];
		}
		return ["default", "outlined"];
	}, [
		color,
		variant,
		type,
		danger,
		button?.color,
		button?.variant,
		mergedType
	]);
	const [mergedColor, mergedVariant] = reactExports.useMemo(() => {
		if (ghost && parsedVariant === "solid") {
			return [parsedColor, "outlined"];
		}
		return [parsedColor, parsedVariant];
	}, [
		parsedColor,
		parsedVariant,
		ghost
	]);
	const isDanger = mergedColor === "danger";
	const mergedColorText = isDanger ? "dangerous" : mergedColor;
	const { getPrefixCls, direction, autoInsertSpace: contextAutoInsertSpace, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("button");
	const mergedInsertSpace = autoInsertSpace ?? contextAutoInsertSpace ?? true;
	const prefixCls = getPrefixCls("btn", customizePrefixCls);
	const [hashId, cssVarCls] = useStyle$1(prefixCls);
	const disabled = reactExports.useContext(DisabledContext);
	const mergedDisabled = customDisabled ?? disabled;
	const groupSize = reactExports.useContext(GroupSizeContext);
	const loadingOrDelay = reactExports.useMemo(() => getLoadingConfig(loading), [loading]);
	const [innerLoading, setLoading] = reactExports.useState(loadingOrDelay.loading);
	const [hasTwoCNChar, setHasTwoCNChar] = reactExports.useState(false);
	const buttonRef = reactExports.useRef(null);
	const mergedRef = useComposeRef(ref, buttonRef);
	const needInserted = childNodes.length === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant);
	// ========================= Mount ==========================
	// Record for mount status.
	// This will help to no to show the animation of loading on the first mount.
	const isMountRef = reactExports.useRef(true);
	React.useEffect(() => {
		isMountRef.current = false;
		return () => {
			isMountRef.current = true;
		};
	}, []);
	// ========================= Effect =========================
	// Loading. Should use `useLayoutEffect` to avoid low perf multiple click issue.
	// https://github.com/ant-design/ant-design/issues/51325
	useLayoutEffect(() => {
		let delayTimer = null;
		if (loadingOrDelay.delay > 0) {
			delayTimer = setTimeout(() => {
				delayTimer = null;
				setLoading(true);
			}, loadingOrDelay.delay);
		} else {
			setLoading(loadingOrDelay.loading);
		}
		function cleanupTimer() {
			if (delayTimer) {
				clearTimeout(delayTimer);
				delayTimer = null;
			}
		}
		return cleanupTimer;
	}, [loadingOrDelay.delay, loadingOrDelay.loading]);
	// Two chinese characters check
	reactExports.useEffect(() => {
		// FIXME: for HOC usage like <FormatMessage />
		if (!buttonRef.current || !mergedInsertSpace) {
			return;
		}
		const buttonText = buttonRef.current.textContent || "";
		if (needInserted && isTwoCNChar(buttonText)) {
			if (!hasTwoCNChar) {
				setHasTwoCNChar(true);
			}
		} else if (hasTwoCNChar) {
			setHasTwoCNChar(false);
		}
	});
	// Auto focus
	reactExports.useEffect(() => {
		if (autoFocus && buttonRef.current) {
			buttonRef.current.focus();
		}
	}, []);
	// ========================= Events =========================
	const handleClick = React.useCallback((e) => {
		// FIXME: https://github.com/ant-design/ant-design/issues/30207
		if (innerLoading || mergedDisabled) {
			e.preventDefault();
			return;
		}
		props.onClick?.("href" in props ? e : e);
	}, [
		props.onClick,
		innerLoading,
		mergedDisabled
	]);
	// ========================== Size ==========================
	const { a: compactSize, b: compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const sizeClassNameMap = {
		large: "lg",
		small: "sm",
		middle: void 0
	};
	const sizeFullName = useSize((ctxSize) => customizeSize ?? compactSize ?? groupSize ?? ctxSize);
	const sizeCls = sizeFullName ? sizeClassNameMap[sizeFullName] ?? "" : "";
	const iconType = innerLoading ? "loading" : icon;
	const mergedIconPlacement = iconPlacement ?? iconPosition ?? "start";
	const linkButtonRestProps = omit(rest, ["navigate"]);
	// =========== Merged Props for Semantic ===========
	const mergedProps = {
		...props,
		type: mergedType,
		color: mergedColor,
		variant: mergedVariant,
		danger: isDanger,
		shape,
		size: sizeFullName,
		disabled: mergedDisabled,
		loading: innerLoading,
		iconPlacement: mergedIconPlacement
	};
	// ========================= Style ==========================
	const [mergedClassNames, mergedStyles] = useMergeSemantic([_skipSemantic ? void 0 : contextClassNames, classNames], [_skipSemantic ? void 0 : contextStyles, styles], { props: mergedProps });
	// ========================= Render =========================
	const classes = clsx(prefixCls, hashId, cssVarCls, {
		[`${prefixCls}-${shape}`]: shape !== "default" && shape !== "square" && shape,
		[`${prefixCls}-${mergedType}`]: mergedType,
		[`${prefixCls}-dangerous`]: danger,
		[`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
		[`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
		[`${prefixCls}-${sizeCls}`]: sizeCls,
		[`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
		[`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
		[`${prefixCls}-loading`]: innerLoading,
		[`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
		[`${prefixCls}-block`]: block,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-icon-end`]: mergedIconPlacement === "end"
	}, compactItemClassnames, className, rootClassName, contextClassName, mergedClassNames.root);
	const fullStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style
	};
	const iconSharedProps = {
		className: mergedClassNames.icon,
		style: mergedStyles.icon
	};
	/**
	* Extract icon node
	* If there is a custom icon and not in loading state: show custom icon
	*/
	const iconWrapperElement = (child) => React.createElement(IconWrapper, {
		prefixCls,
		...iconSharedProps
	}, child);
	const defaultLoadingIconElement = React.createElement(DefaultLoadingIcon, {
		existIcon: !!icon,
		prefixCls,
		loading: innerLoading,
		mount: isMountRef.current,
		...iconSharedProps
	});
	/**
	* Using if-else statements can improve code readability without affecting future expansion.
	*/
	let iconNode;
	if (icon && !innerLoading) {
		iconNode = iconWrapperElement(icon);
	} else if (loading && typeof loading === "object" && loading.icon) {
		iconNode = iconWrapperElement(loading.icon);
	} else {
		iconNode = defaultLoadingIconElement;
	}
	const contentNode = isNonNullable(children) ? spaceChildren(children, needInserted && mergedInsertSpace, mergedStyles.content, mergedClassNames.content) : null;
	if (linkButtonRestProps.href !== void 0) {
		return React.createElement("a", {
			...linkButtonRestProps,
			className: clsx(classes, { [`${prefixCls}-disabled`]: mergedDisabled }),
			href: mergedDisabled ? void 0 : linkButtonRestProps.href,
			style: fullStyle,
			onClick: handleClick,
			ref: mergedRef,
			tabIndex: mergedDisabled ? -1 : 0,
			"aria-disabled": mergedDisabled
		}, iconNode, contentNode);
	}
	let buttonNode = React.createElement("button", {
		...rest,
		type: htmlType,
		className: classes,
		style: fullStyle,
		onClick: handleClick,
		disabled: mergedDisabled,
		ref: mergedRef
	}, iconNode, contentNode, compactItemClassnames && React.createElement(Compact, { prefixCls }));
	if (!isUnBorderedButtonVariant(mergedVariant)) {
		buttonNode = React.createElement(Wave, {
			component: "Button",
			disabled: innerLoading
		}, buttonNode);
	}
	return buttonNode;
});
const Button = InternalCompoundedButton;
Button.Group = ButtonGroup;
Button.__ANT_BUTTON = true;
const HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const warningFunc = () => {
	warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
};
const Context = reactExports.createContext({
	getFieldValue: warningFunc,
	getFieldsValue: warningFunc,
	getFieldError: warningFunc,
	getFieldWarning: warningFunc,
	getFieldsError: warningFunc,
	isFieldsTouched: warningFunc,
	isFieldTouched: warningFunc,
	isFieldValidating: warningFunc,
	isFieldsValidating: warningFunc,
	resetFields: warningFunc,
	setFields: warningFunc,
	setFieldValue: warningFunc,
	setFieldsValue: warningFunc,
	validateFields: warningFunc,
	submit: warningFunc,
	getInternalHooks: () => {
		warningFunc();
		return {
			dispatch: warningFunc,
			initEntityValue: warningFunc,
			registerField: warningFunc,
			useSubscribe: warningFunc,
			setInitialValues: warningFunc,
			destroyForm: warningFunc,
			setCallbacks: warningFunc,
			registerWatch: warningFunc,
			getFields: warningFunc,
			setValidateMessages: warningFunc,
			setPreserve: warningFunc,
			getInitialValue: warningFunc
		};
	}
});
const ListContext = reactExports.createContext(null);
function toArray$1(value) {
	if (value === void 0 || value === null) {
		return [];
	}
	return Array.isArray(value) ? value : [value];
}
function isFormInstance(form) {
	return form && !!form._init;
}
function newMessages() {
	return {
		default: "Validation error on field %s",
		required: "%s is required",
		enum: "%s must be one of %s",
		whitespace: "%s cannot be empty",
		date: {
			format: "%s date %s is invalid for format %s",
			parse: "%s date could not be parsed, %s is invalid ",
			invalid: "%s date %s is invalid"
		},
		types: {
			string: "%s is not a %s",
			method: "%s is not a %s (function)",
			array: "%s is not an %s",
			object: "%s is not an %s",
			number: "%s is not a %s",
			date: "%s is not a %s",
			boolean: "%s is not a %s",
			integer: "%s is not an %s",
			float: "%s is not a %s",
			regexp: "%s is not a valid %s",
			email: "%s is not a valid %s",
			tel: "%s is not a valid %s",
			url: "%s is not a valid %s",
			hex: "%s is not a valid %s"
		},
		string: {
			len: "%s must be exactly %s characters",
			min: "%s must be at least %s characters",
			max: "%s cannot be longer than %s characters",
			range: "%s must be between %s and %s characters"
		},
		number: {
			len: "%s must equal %s",
			min: "%s cannot be less than %s",
			max: "%s cannot be greater than %s",
			range: "%s must be between %s and %s"
		},
		array: {
			len: "%s must be exactly %s in length",
			min: "%s cannot be less than %s in length",
			max: "%s cannot be greater than %s in length",
			range: "%s must be between %s and %s in length"
		},
		pattern: { mismatch: "%s value %s does not match pattern %s" },
		clone: function() {
			var cloned = JSON.parse(JSON.stringify(this));
			cloned.clone = this.clone;
			return cloned;
		}
	};
}
var messages = newMessages();
function _isNativeFunction(t) {
	try {
		return -1 !== Function.toString.call(t).indexOf("[native code]");
	} catch {
		return true;
	}
}
function _construct(t, e, r) {
	if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
	var o = [null];
	o.push.apply(o, e);
	var p = new (t.bind.apply(t, o))();
	return r && _setPrototypeOf(p, r.prototype), p;
}
function _wrapNativeSuper(t) {
	var r = new Map();
	return _wrapNativeSuper = function(t) {
		if (!_isNativeFunction(t)) return t;
		if (void 0 !== r) {
			if (r.has(t)) return r.get(t);
			r.set(t, Wrapper);
		}
		function Wrapper() {
			return _construct(t, arguments, _getPrototypeOf(this).constructor);
		}
		return Wrapper.prototype = Object.create(t.prototype, { constructor: {
			value: Wrapper,
			enumerable: false,
			writable: true,
			configurable: true
		} }), _setPrototypeOf(Wrapper, t);
	}, _wrapNativeSuper(t);
}
/* eslint no-console:0 */
var formatRegExp = /%[sdj%]/g;
var warning = function() {};
function convertFieldsError(errors) {
	if (!errors || !errors.length) return null;
	var fields = {};
	errors.forEach(function(error) {
		var field = error.field;
		fields[field] = fields[field] || [];
		fields[field].push(error);
	});
	return fields;
}
function format(template) {
	for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}
	var i = 0;
	var len = args.length;
	if (typeof template === "function") {
		// eslint-disable-next-line prefer-spread
		return template.apply(null, args);
	}
	if (typeof template === "string") {
		var str = template.replace(formatRegExp, function(x) {
			if (x === "%%") {
				return "%";
			}
			if (i >= len) {
				return x;
			}
			switch (x) {
				case "%s": return String(args[i++]);
				case "%d": return Number(args[i++]);
				case "%j":
					try {
						return JSON.stringify(args[i++]);
					} catch {
						return "[Circular]";
					}
					break;
				default: return x;
			}
		});
		return str;
	}
	return template;
}
function isNativeStringType(type) {
	return type === "string" || type === "url" || type === "hex" || type === "email" || type === "date" || type === "pattern" || type === "tel";
}
function isEmptyValue(value, type) {
	if (value === void 0 || value === null) {
		return true;
	}
	if (type === "array" && Array.isArray(value) && !value.length) {
		return true;
	}
	if (isNativeStringType(type) && typeof value === "string" && !value) {
		return true;
	}
	return false;
}
function asyncParallelArray(arr, func, callback) {
	var results = [];
	var total = 0;
	var arrLength = arr.length;
	function count(errors) {
		results.push.apply(results, _toConsumableArray$8(errors || []));
		total++;
		if (total === arrLength) {
			callback(results);
		}
	}
	arr.forEach(function(a) {
		func(a, count);
	});
}
function asyncSerialArray(arr, func, callback) {
	var index = 0;
	var arrLength = arr.length;
	function next(errors) {
		if (errors && errors.length) {
			callback(errors);
			return;
		}
		var original = index;
		index = index + 1;
		if (original < arrLength) {
			func(arr[original], next);
		} else {
			callback([]);
		}
	}
	next([]);
}
function flattenObjArr(objArr) {
	var ret = [];
	Object.keys(objArr).forEach(function(k) {
		ret.push.apply(ret, _toConsumableArray$8(objArr[k] || []));
	});
	return ret;
}
var AsyncValidationError = function(_Error) {
	_inherits(AsyncValidationError, _Error);
	var _super = _createSuper(AsyncValidationError);
	function AsyncValidationError(errors, fields) {
		var _this;
		_classCallCheck$1(this, AsyncValidationError);
		_this = _super.call(this, "Async Validation Error");
		_defineProperty$s(_assertThisInitialized(_this), "errors", void 0);
		_defineProperty$s(_assertThisInitialized(_this), "fields", void 0);
		_this.errors = errors;
		_this.fields = fields;
		return _this;
	}
	return _createClass$1(AsyncValidationError);
}(_wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
	if (option.first) {
		var _pending = new Promise(function(resolve, reject) {
			var next = function(errors) {
				callback(errors);
				return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
			};
			var flattenArr = flattenObjArr(objArr);
			asyncSerialArray(flattenArr, func, next);
		});
		_pending.catch(function(e) {
			return e;
		});
		return _pending;
	}
	var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
	var objArrKeys = Object.keys(objArr);
	var objArrLength = objArrKeys.length;
	var total = 0;
	var results = [];
	var pending = new Promise(function(resolve, reject) {
		var next = function(errors) {
			// eslint-disable-next-line prefer-spread
			results.push.apply(results, errors);
			total++;
			if (total === objArrLength) {
				callback(results);
				return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
			}
		};
		if (!objArrKeys.length) {
			callback(results);
			resolve(source);
		}
		objArrKeys.forEach(function(key) {
			var arr = objArr[key];
			if (firstFields.indexOf(key) !== -1) {
				asyncSerialArray(arr, func, next);
			} else {
				asyncParallelArray(arr, func, next);
			}
		});
	});
	pending.catch(function(e) {
		return e;
	});
	return pending;
}
function isErrorObj(obj) {
	return !!(obj && obj.message !== void 0);
}
function getValue(value, path) {
	var v = value;
	for (var i = 0; i < path.length; i++) {
		if (v == void 0) {
			return v;
		}
		v = v[path[i]];
	}
	return v;
}
function complementError(rule, source) {
	return function(oe) {
		var fieldValue;
		if (rule.fullFields) {
			fieldValue = getValue(source, rule.fullFields);
		} else {
			fieldValue = source[oe.field || rule.fullField];
		}
		if (isErrorObj(oe)) {
			oe.field = oe.field || rule.fullField;
			oe.fieldValue = fieldValue;
			return oe;
		}
		return {
			message: typeof oe === "function" ? oe() : oe,
			fieldValue,
			field: oe.field || rule.fullField
		};
	};
}
function deepMerge(target, source) {
	if (source) {
		for (var s in source) {
			if (source.hasOwnProperty(s)) {
				var value = source[s];
				if (_typeof$u(value) === "object" && _typeof$u(target[s]) === "object") {
					target[s] = _objectSpread2(_objectSpread2({}, target[s]), value);
				} else {
					target[s] = value;
				}
			}
		}
	}
	return target;
}
var enumerable$1 = function(rule, value, __unused_CA1B, errors, options) {
	rule["enum"] = Array.isArray(rule["enum"]) ? rule["enum"] : [];
	if (rule["enum"].indexOf(value) === -1) {
		errors.push(format(options.messages["enum"], rule.fullField, rule["enum"].join(", ")));
	}
};
var enumRule = enumerable$1;
var pattern$3 = function(rule, value, __unused_CA1B_0, errors, options) {
	if (rule.pattern) {
		if (rule.pattern instanceof RegExp) {
			// if a RegExp instance is passed, reset `lastIndex` in case its `global`
			// flag is accidentally set to `true`, which in a validation scenario
			// is not necessary and the result might be misleading
			rule.pattern.lastIndex = 0;
			if (!rule.pattern.test(value)) {
				errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
			}
		} else if (typeof rule.pattern === "string") {
			var _pattern = new RegExp(rule.pattern);
			if (!_pattern.test(value)) {
				errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
			}
		}
	}
};
var pattern$4 = pattern$3;
var range = function(rule, value, __unused_CA1B_1, errors, options) {
	var len = typeof rule.len === "number";
	var min = typeof rule.min === "number";
	var max = typeof rule.max === "number";
	// U+010000U+10FFFFSupplementary Plane
	var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	var val = value;
	var key = null;
	var num = typeof value === "number";
	var str = typeof value === "string";
	var arr = Array.isArray(value);
	if (num) {
		key = "number";
	} else if (str) {
		key = "string";
	} else if (arr) {
		key = "array";
	}
	// if the value is not of a supported type for range validation
	// the validation rule rule should use the
	// type property to also test for a particular type
	if (!key) {
		return;
	}
	if (arr) {
		val = value.length;
	}
	if (str) {
		// U+010000lengthbug"".length !== 3
		val = value.replace(spRegexp, "_").length;
	}
	if (len) {
		if (val !== rule.len) {
			errors.push(format(options.messages[key].len, rule.fullField, rule.len));
		}
	} else if (min && !max && val < rule.min) {
		errors.push(format(options.messages[key].min, rule.fullField, rule.min));
	} else if (max && !min && val > rule.max) {
		errors.push(format(options.messages[key].max, rule.fullField, rule.max));
	} else if (min && max && (val < rule.min || val > rule.max)) {
		errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
	}
};
var range$1 = range;
var required$2 = function(rule, value, source, errors, options, type) {
	if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
		errors.push(format(options.messages.required, rule.fullField));
	}
};
var required$3 = required$2;
// https://github.com/kevva/url-regex/blob/master/index.js
var urlReg;
var getUrlRegex = function() {
	if (urlReg) {
		return urlReg;
	}
	var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
	var v6seg = "[a-fA-F\\d]{1,4}";
	var v6List = [
		"(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"),
		"(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"),
		"(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"),
		"(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"),
		"(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"),
		"(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"),
		"(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"),
		"(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))")
	];
	var v6Eth0 = "(?:%[0-9a-zA-Z]{1,})?";
	var v6 = "(?:".concat(v6List.join("|"), ")").concat(v6Eth0);
	// Pre-compile only the exact regexes because adding a global flag make regexes stateful
	var __unused_472F = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
	var __unused_08E8 = new RegExp("^".concat(v4, "$"));
	var __unused_593A = new RegExp("^".concat(v6, "$"));
	var ip = function() {};
	ip.a = function() {
		return new RegExp("".concat("").concat(v4).concat(""), "g");
	};
	ip.b = function() {
		return new RegExp("".concat("").concat(v6).concat(""), "g");
	};
	var protocol = "(?:(?:[a-z]+:)?//)";
	var auth = "(?:\\S+(?::\\S*)?@)?";
	var ipv4 = ip.a().source;
	var ipv6 = ip.b().source;
	var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
	var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
	var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
	var port = "(?::\\d{2,5})?";
	var path = "(?:[/?#][^\\s\"]*)?";
	var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat(host).concat(domain).concat(tld, ")").concat(port).concat(path);
	urlReg = new RegExp("(?:^".concat(regex, "$)"), "i");
	return urlReg;
};
/* eslint max-len:0 */
var pattern$2 = {
	a: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
	b: /^(\+[0-9]{1,3}[-\s\u2011]?)?(\([0-9]{1,4}\)[-\s\u2011]?)?([0-9]+[-\s\u2011]?)*[0-9]+$/,
	c: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
	integer: function(value) {
		return types.number(value) && parseInt(value, 10) === value;
	},
	float: function(value) {
		return types.number(value) && !types.integer(value);
	},
	array: function(value) {
		return Array.isArray(value);
	},
	regexp: function(value) {
		if (value instanceof RegExp) {
			return true;
		}
		try {
			return !!new RegExp(value);
		} catch {
			return false;
		}
	},
	date: function(value) {
		return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
	},
	number: function(value) {
		if (isNaN(value)) {
			return false;
		}
		return typeof value === "number";
	},
	object: function(value) {
		return _typeof$u(value) === "object" && !types.array(value);
	},
	method: function(value) {
		return typeof value === "function";
	},
	email: function(value) {
		return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.a);
	},
	tel: function(value) {
		return typeof value === "string" && value.length <= 32 && !!value.match(pattern$2.b);
	},
	url: function(value) {
		return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
	},
	hex: function(value) {
		return typeof value === "string" && !!value.match(pattern$2.c);
	}
};
var type$2 = function(rule, value, source, errors, options) {
	if (rule.required && value === void 0) {
		required$3(rule, value, source, errors, options);
		return;
	}
	var custom = [
		"integer",
		"float",
		"array",
		"regexp",
		"object",
		"method",
		"email",
		"tel",
		"number",
		"date",
		"url",
		"hex"
	];
	var ruleType = rule.type;
	if (custom.indexOf(ruleType) > -1) {
		if (!types[ruleType](value)) {
			errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
		}
	} else if (ruleType && _typeof$u(value) !== rule.type) {
		errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
	}
};
var type$3 = type$2;
/**
*  Rule for validating whitespace.
*
*  @param rule The validation rule.
*  @param value The value of the field on the source object.
*  @param source The source object being validated.
*  @param errors An array of errors that this rule may add
*  validation errors to.
*  @param options The validation options.
*  @param options.messages The validation messages.
*/
var whitespace = function(rule, value, __unused_CA1B_2, errors, options) {
	if (/^\s+$/.test(value) || value === "") {
		errors.push(format(options.messages.whitespace, rule.fullField));
	}
};
var whitespace$1 = whitespace;
var rules = {
	a: required$3,
	b: whitespace$1,
	c: type$3,
	d: range$1,
	e: enumRule,
	f: pattern$4
};
var any = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
	}
	callback(errors);
};
var any$1 = any;
var array = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if ((value === void 0 || value === null) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options, "array");
		if (value !== void 0 && value !== null) {
			rules.c(rule, value, source, errors, options);
			rules.d(rule, value, 0, errors, options);
		}
	}
	callback(errors);
};
var array$1 = array;
var boolean = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (value !== void 0) {
			rules.c(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var boolean$1 = boolean;
var date = function(rule, value, callback, source, options) {
	// console.log('integer rule called %j', rule);
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	// console.log('validate on %s value', value);
	if (validate) {
		if (isEmptyValue(value, "date") && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (!isEmptyValue(value, "date")) {
			var dateObject;
			if (value instanceof Date) {
				dateObject = value;
			} else {
				dateObject = new Date(value);
			}
			rules.c(rule, dateObject, source, errors, options);
			if (dateObject) {
				rules.d(rule, dateObject.getTime(), 0, errors, options);
			}
		}
	}
	callback(errors);
};
var date$1 = date;
var enumerable = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (value !== void 0) {
			rules["e"](rule, value, 0, errors, options);
		}
	}
	callback(errors);
};
var enumValidator = enumerable;
var floatFn = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (value !== void 0) {
			rules.c(rule, value, source, errors, options);
			rules.d(rule, value, 0, errors, options);
		}
	}
	callback(errors);
};
var float = floatFn;
var integer = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (value !== void 0) {
			rules.c(rule, value, source, errors, options);
			rules.d(rule, value, 0, errors, options);
		}
	}
	callback(errors);
};
var integer$1 = integer;
var method = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (value !== void 0) {
			rules.c(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var method$1 = method;
var number = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (value === "") {
			// eslint-disable-next-line no-param-reassign
			value = void 0;
		}
		if (isEmptyValue(value) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (value !== void 0) {
			rules.c(rule, value, source, errors, options);
			rules.d(rule, value, 0, errors, options);
		}
	}
	callback(errors);
};
var number$1 = number;
var object = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (value !== void 0) {
			rules.c(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var object$1 = object;
var pattern = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value, "string") && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (!isEmptyValue(value, "string")) {
			rules.f(rule, value, 0, errors, options);
		}
	}
	callback(errors);
};
var pattern$1 = pattern;
var regexp = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options);
		if (!isEmptyValue(value)) {
			rules.c(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var regexp$1 = regexp;
var required = function(rule, value, callback, source, options) {
	var errors = [];
	var type = Array.isArray(value) ? "array" : _typeof$u(value);
	rules.a(rule, value, source, errors, options, type);
	callback(errors);
};
var required$1 = required;
var string = function(rule, value, callback, source, options) {
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value, "string") && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options, "string");
		if (!isEmptyValue(value, "string")) {
			rules.c(rule, value, source, errors, options);
			rules.d(rule, value, 0, errors, options);
			rules.f(rule, value, 0, errors, options);
			if (rule.whitespace === true) {
				rules.b(rule, value, 0, errors, options);
			}
		}
	}
	callback(errors);
};
var string$1 = string;
var type = function(rule, value, callback, source, options) {
	var ruleType = rule.type;
	var errors = [];
	var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
	if (validate) {
		if (isEmptyValue(value, ruleType) && !rule.required) {
			return callback();
		}
		rules.a(rule, value, source, errors, options, ruleType);
		if (!isEmptyValue(value, ruleType)) {
			rules.c(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var type$1 = type;
var validators = {
	string: string$1,
	method: method$1,
	number: number$1,
	boolean: boolean$1,
	regexp: regexp$1,
	integer: integer$1,
	float,
	array: array$1,
	object: object$1,
	enum: enumValidator,
	pattern: pattern$1,
	date: date$1,
	url: type$1,
	hex: type$1,
	email: type$1,
	tel: type$1,
	required: required$1,
	any: any$1
};
/**
*  Encapsulates a validation schema.
*
*  @param descriptor An object declaring validation rules
*  for this schema.
*/
var Schema = function() {
	function Schema(descriptor) {
		_classCallCheck$1(this, Schema);
		// ======================== Instance ========================
		_defineProperty$s(this, "rules", null);
		_defineProperty$s(this, "_messages", messages);
		this.define(descriptor);
	}
	_createClass$1(Schema, [
		{
			key: "define",
			value: function(rules) {
				var _this = this;
				if (!rules) {
					throw new Error("Cannot configure a schema with no rules");
				}
				if (_typeof$u(rules) !== "object" || Array.isArray(rules)) {
					throw new Error("Rules must be an object");
				}
				this.rules = {};
				Object.keys(rules).forEach(function(name) {
					var item = rules[name];
					_this.rules[name] = Array.isArray(item) ? item : [item];
				});
			}
		},
		{
			key: "messages",
			value: function(_messages) {
				if (_messages) {
					this._messages = deepMerge(newMessages(), _messages);
				}
				return this._messages;
			}
		},
		{
			key: "validate",
			value: function(source_) {
				var _this2 = this;
				var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
				var oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {};
				var source = source_;
				var options = o;
				var callback = oc;
				if (typeof options === "function") {
					callback = options;
					options = {};
				}
				if (!this.rules || Object.keys(this.rules).length === 0) {
					if (callback) {
						callback(null, source);
					}
					return Promise.resolve(source);
				}
				function complete(results) {
					var errors = [];
					var fields = {};
					function add(e) {
						if (Array.isArray(e)) {
							var _errors;
							errors = (_errors = errors).concat.apply(_errors, _toConsumableArray$8(e));
						} else {
							errors.push(e);
						}
					}
					for (var i = 0; i < results.length; i++) {
						add(results[i]);
					}
					if (!errors.length) {
						callback(null, source);
					} else {
						fields = convertFieldsError(errors);
						callback(errors, fields);
					}
				}
				if (options.messages) {
					var messages$1 = this.messages();
					if (messages$1 === messages) {
						messages$1 = newMessages();
					}
					deepMerge(messages$1, options.messages);
					options.messages = messages$1;
				} else {
					options.messages = this.messages();
				}
				var series = {};
				var keys = options.keys || Object.keys(this.rules);
				keys.forEach(function(z) {
					var arr = _this2.rules[z];
					var value = source[z];
					arr.forEach(function(r) {
						var rule = r;
						if (typeof rule.transform === "function") {
							if (source === source_) {
								source = _objectSpread2({}, source);
							}
							value = source[z] = rule.transform(value);
							if (value !== void 0 && value !== null) {
								rule.type = rule.type || (Array.isArray(value) ? "array" : _typeof$u(value));
							}
						}
						if (typeof rule === "function") {
							rule = { validator: rule };
						} else {
							rule = _objectSpread2({}, rule);
						}
						// Fill validator. Skip if nothing need to validate
						rule.validator = _this2.getValidationMethod(rule);
						if (!rule.validator) {
							return;
						}
						rule.field = z;
						rule.fullField = rule.fullField || z;
						rule.type = _this2.getType(rule);
						series[z] = series[z] || [];
						series[z].push({
							rule,
							value,
							source,
							field: z
						});
					});
				});
				var errorFields = {};
				return asyncMap(series, options, function(data, doIt) {
					var rule = data.rule;
					var deep = (rule.type === "object" || rule.type === "array") && (_typeof$u(rule.fields) === "object" || _typeof$u(rule.defaultField) === "object");
					deep = deep && (rule.required || !rule.required && data.value);
					rule.field = data.field;
					function addFullField(key, schema) {
						return _objectSpread2(_objectSpread2({}, schema), {}, {
							fullField: "".concat(rule.fullField, ".").concat(key),
							fullFields: rule.fullFields ? [].concat(_toConsumableArray$8(rule.fullFields), [key]) : [key]
						});
					}
					function cb() {
						var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
						var errorList = Array.isArray(e) ? e : [e];
						if (!options.suppressWarning && errorList.length) {
							Schema.warning("async-validator:", errorList);
						}
						if (errorList.length && rule.message !== void 0 && rule.message !== null) {
							errorList = [].concat(rule.message);
						}
						// Fill error info
						var filledErrors = errorList.map(complementError(rule, source));
						if (options.first && filledErrors.length) {
							errorFields[rule.field] = 1;
							return doIt(filledErrors);
						}
						if (!deep) {
							doIt(filledErrors);
						} else {
							// if rule is required but the target object
							// does not exist fail at the rule level and don't
							// go deeper
							if (rule.required && !data.value) {
								if (rule.message !== void 0) {
									filledErrors = [].concat(rule.message).map(complementError(rule, source));
								} else if (options.error) {
									filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
								}
								return doIt(filledErrors);
							}
							var fieldsSchema = {};
							if (rule.defaultField) {
								Object.keys(data.value).map(function(key) {
									fieldsSchema[key] = rule.defaultField;
								});
							}
							fieldsSchema = _objectSpread2(_objectSpread2({}, fieldsSchema), data.rule.fields);
							var paredFieldsSchema = {};
							Object.keys(fieldsSchema).forEach(function(field) {
								var fieldSchema = fieldsSchema[field];
								var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
								paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(0, field));
							});
							var schema = new Schema(paredFieldsSchema);
							schema.messages(options.messages);
							if (data.rule.options) {
								data.rule.options.messages = options.messages;
								data.rule.options.error = options.error;
							}
							schema.validate(data.value, data.rule.options || options, function(errs) {
								var finalErrors = [];
								if (filledErrors && filledErrors.length) {
									finalErrors.push.apply(finalErrors, _toConsumableArray$8(filledErrors));
								}
								if (errs && errs.length) {
									finalErrors.push.apply(finalErrors, _toConsumableArray$8(errs));
								}
								doIt(finalErrors.length ? finalErrors : null);
							});
						}
					}
					var res;
					if (rule.asyncValidator) {
						res = rule.asyncValidator(rule, data.value, cb, data.source, options);
					} else if (rule.validator) {
						try {
							res = rule.validator(rule, data.value, cb, data.source, options);
						} catch (error) {
							var _console$error, _console;
							(_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
							// rethrow to report error
							if (!options.suppressValidatorError) {
								setTimeout(function() {
									throw error;
								}, 0);
							}
							cb(error.message);
						}
						if (res === true) {
							cb();
						} else if (res === false) {
							cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
						} else if (res instanceof Array) {
							cb(res);
						} else if (res instanceof Error) {
							cb(res.message);
						}
					}
					if (res && res.then) {
						res.then(function() {
							return cb();
						}, function(e) {
							return cb(e);
						});
					}
				}, function(results) {
					complete(results);
				}, source);
			}
		},
		{
			key: "getType",
			value: function(rule) {
				if (rule.type === void 0 && rule.pattern instanceof RegExp) {
					rule.type = "pattern";
				}
				if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
					throw new Error(format("Unknown rule type %s", rule.type));
				}
				return rule.type || "string";
			}
		},
		{
			key: "getValidationMethod",
			value: function(rule) {
				if (typeof rule.validator === "function") {
					return rule.validator;
				}
				var keys = Object.keys(rule);
				var messageIndex = keys.indexOf("message");
				if (messageIndex !== -1) {
					keys.splice(messageIndex, 1);
				}
				if (keys.length === 1 && keys[0] === "required") {
					return validators.required;
				}
				return validators[this.getType(rule)] || void 0;
			}
		}
	]);
	return Schema;
}();
// ========================= Static =========================
_defineProperty$s(Schema, "register", function(type, validator) {
	if (typeof validator !== "function") {
		throw new Error("Cannot register a validator by type, validator is not a function");
	}
	validators[type] = validator;
});
_defineProperty$s(Schema, "warning", warning);
_defineProperty$s(Schema, "messages", messages);
_defineProperty$s(Schema, "validators", validators);
var RawAsyncValidator = Schema;
const typeTemplate = "'${name}' is not a valid ${type}";
const defaultValidateMessages = {
	default: "Validation error on field '${name}'",
	required: "'${name}' is required",
	enum: "'${name}' must be one of [${enum}]",
	whitespace: "'${name}' cannot be empty",
	date: {
		format: "'${name}' is invalid for format date",
		parse: "'${name}' could not be parsed as date",
		invalid: "'${name}' is invalid date"
	},
	types: {
		string: typeTemplate,
		method: typeTemplate,
		array: typeTemplate,
		object: typeTemplate,
		number: typeTemplate,
		date: typeTemplate,
		boolean: typeTemplate,
		integer: typeTemplate,
		float: typeTemplate,
		regexp: typeTemplate,
		email: typeTemplate,
		tel: typeTemplate,
		url: typeTemplate,
		hex: typeTemplate
	},
	string: {
		len: "'${name}' must be exactly ${len} characters",
		min: "'${name}' must be at least ${min} characters",
		max: "'${name}' cannot be longer than ${max} characters",
		range: "'${name}' must be between ${min} and ${max} characters"
	},
	number: {
		len: "'${name}' must equal ${len}",
		min: "'${name}' cannot be less than ${min}",
		max: "'${name}' cannot be greater than ${max}",
		range: "'${name}' must be between ${min} and ${max}"
	},
	array: {
		len: "'${name}' must be exactly ${len} in length",
		min: "'${name}' cannot be less than ${min} in length",
		max: "'${name}' cannot be greater than ${max} in length",
		range: "'${name}' must be between ${min} and ${max} in length"
	},
	pattern: { mismatch: "'${name}' does not match pattern ${pattern}" }
};
// Remove incorrect original ts define
const AsyncValidator = RawAsyncValidator;
/**
* Replace with template.
*   `I'm ${name}` + { name: 'bamboo' } = I'm bamboo
*/
function replaceMessage(template, kv) {
	return template.replace(/\\?\$\{\w+\}/g, (str) => {
		if (str.startsWith("\\")) {
			return str.slice(1);
		}
		const key = str.slice(2, -1);
		return kv[key];
	});
}
const CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
async function validateRule(name, value, rule, options, messageVariables) {
	const cloneRule = { ...rule };
	// Bug of `async-validator`
	// https://github.com/react-component/field-form/issues/316
	// https://github.com/react-component/field-form/issues/313
	delete cloneRule.ruleIndex;
	// https://github.com/ant-design/ant-design/issues/40497#issuecomment-1422282378
	AsyncValidator.warning = () => void 0;
	if (cloneRule.validator) {
		const originValidator = cloneRule.validator;
		cloneRule.validator = (...args) => {
			try {
				return originValidator(...args);
			} catch (error) {
				console.error(error);
				return Promise.reject(CODE_LOGIC_ERROR);
			}
		};
	}
	// We should special handle array validate
	let subRuleField = null;
	if (cloneRule.type === "array" && cloneRule.defaultField) {
		subRuleField = cloneRule.defaultField;
		delete cloneRule.defaultField;
	}
	const validator = new AsyncValidator({ [name]: [cloneRule] });
	const messages = merge$1(defaultValidateMessages, options.validateMessages);
	validator.messages(messages);
	let result = [];
	try {
		await Promise.resolve(validator.validate({ [name]: value }, { ...options }));
	} catch (errObj) {
		if (errObj.errors) {
			result = errObj.errors.map(({ message }, index) => {
				const mergedMessage = message === CODE_LOGIC_ERROR ? messages.default : message;
				return reactExports.isValidElement(mergedMessage) ? reactExports.cloneElement(mergedMessage, { key: `error_${index}` }) : mergedMessage;
			});
		}
	}
	if (!result.length && subRuleField && Array.isArray(value) && value.length > 0) {
		const subResults = await Promise.all(value.map((subValue, i) => validateRule(`${name}.${i}`, subValue, subRuleField, options, messageVariables)));
		return subResults.reduce((prev, errors) => [...prev, ...errors], []);
	}
	// Replace message with variables
	const kv = {
		...rule,
		name,
		enum: (rule.enum || []).join(", "),
		...messageVariables
	};
	const fillVariableResult = result.map((error) => {
		if (typeof error === "string") {
			return replaceMessage(error, kv);
		}
		return error;
	});
	return fillVariableResult;
}
/**
* We use `async-validator` to validate the value.
* But only check one value in a time to avoid namePath validate issue.
*/
function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
	const name = namePath.join(".");
	// Fill rule with context
	const filledRules = rules.map((currentRule, ruleIndex) => {
		const originValidatorFunc = currentRule.validator;
		const cloneRule = {
			...currentRule,
			ruleIndex
		};
		// Replace validator if needed
		if (originValidatorFunc) {
			cloneRule.validator = (rule, val, callback) => {
				let hasPromise = false;
				// Wrap callback only accept when promise not provided
				const wrappedCallback = (...args) => {
					// Wait a tick to make sure return type is a promise
					Promise.resolve().then(() => {
						warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
						if (!hasPromise) {
							callback(...args);
						}
					});
				};
				// Get promise
				const promise = originValidatorFunc(rule, val, wrappedCallback);
				hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
				/**
				* 1. Use promise as the first priority.
				* 2. If promise not exist, use callback with warning instead
				*/
				warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
				if (hasPromise) {
					promise.then(() => {
						callback();
					}).catch((err) => {
						callback(err || " ");
					});
				}
			};
		}
		return cloneRule;
	}).sort(({ warningOnly: w1, ruleIndex: i1 }, { warningOnly: w2, ruleIndex: i2 }) => {
		if (!!w1 === !!w2) {
			// Let keep origin order
			return i1 - i2;
		}
		if (w1) {
			return 1;
		}
		return -1;
	});
	// Do validate rules
	let summaryPromise;
	if (validateFirst === true) {
		// >>>>> Validate by serialization
		summaryPromise = new Promise(async (resolve, reject) => {
			/* eslint-disable no-await-in-loop */
			for (let i = 0; i < filledRules.length; i += 1) {
				const rule = filledRules[i];
				const errors = await validateRule(name, value, rule, options, messageVariables);
				if (errors.length) {
					reject([{
						errors,
						rule
					}]);
					return;
				}
			}
			/* eslint-enable */
			resolve([]);
		});
	} else {
		// >>>>> Validate by parallel
		const rulePromises = filledRules.map((rule) => validateRule(name, value, rule, options, messageVariables).then((errors) => ({
			errors,
			rule
		})));
		summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors) => {
			// Always change to rejection for Field to catch
			return Promise.reject(errors);
		});
	}
	// Internal catch error to avoid console error log.
	summaryPromise.catch((e) => e);
	return summaryPromise;
}
async function finishOnAllFailed(rulePromises) {
	return Promise.all(rulePromises).then((errorsList) => {
		const errors = [].concat(...errorsList);
		return errors;
	});
}
async function finishOnFirstFailed(rulePromises) {
	let count = 0;
	return new Promise((resolve) => {
		rulePromises.forEach((promise) => {
			promise.then((ruleError) => {
				if (ruleError.errors.length) {
					resolve([ruleError]);
				}
				count += 1;
				if (count === rulePromises.length) {
					resolve([]);
				}
			});
		});
	});
}
/**
* Convert name to internal supported format.
* This function should keep since we still thinking if need support like `a.b.c` format.
* 'a' => ['a']
* 123 => [123]
* ['a', 123] => ['a', 123]
*/
function getNamePath(path) {
	return toArray$1(path);
}
/**
* Create a new store object that contains only the values referenced by
* the provided list of name paths.
*/
function cloneByNamePathList(store, namePathList) {
	let newStore = {};
	namePathList.forEach((namePath) => {
		const value = get(store, namePath);
		newStore = set(newStore, namePath, value);
	});
	return newStore;
}
/**
* Check if `namePathList` includes `namePath`.
* @param namePathList A list of `InternalNamePath[]`
* @param namePath Compare `InternalNamePath`
* @param partialMatch True will make `[a, b]` match `[a, b, c]`
*/
function containsNamePath(namePathList, namePath, partialMatch = false) {
	return namePathList && namePathList.some((path) => matchNamePath(namePath, path, partialMatch));
}
/**
* Check if `namePath` is super set or equal of `subNamePath`.
* @param namePath A list of `InternalNamePath[]`
* @param subNamePath Compare `InternalNamePath`
* @param partialMatch Default false. True will make `[a, b]` match `[a, b, c]`
*/
function matchNamePath(namePath, subNamePath, partialMatch = false) {
	if (!namePath || !subNamePath) {
		return false;
	}
	if (!partialMatch && namePath.length !== subNamePath.length) {
		return false;
	}
	return subNamePath.every((nameUnit, i) => namePath[i] === nameUnit);
}
// Like `shallowEqual`, but we not check the data which may cause re-render
function isSimilar(source, target) {
	if (source === target) {
		return true;
	}
	if (typeof source !== "object" || typeof target !== "object") {
		return false;
	}
	const sourceKeys = Object.keys(source);
	const targetKeys = Object.keys(target);
	const keys = new Set([...sourceKeys, ...targetKeys]);
	return [...keys].every((key) => {
		const sourceValue = source[key];
		const targetValue = target[key];
		if (typeof sourceValue === "function" && typeof targetValue === "function") {
			return true;
		}
		return sourceValue === targetValue;
	});
}
function defaultGetValueFromEvent(valuePropName, ...args) {
	const event = args[0];
	if (event && event.target && typeof event.target === "object" && valuePropName in event.target) {
		return event.target[valuePropName];
	}
	return event;
}
/**
* Moves an array item from one position in an array to another.
*
* Note: This is a pure function so a new array will be returned, instead
* of altering the array argument.
*
* @param array         Array in which to move an item.         (required)
* @param moveIndex     The index of the item to move.          (required)
* @param toIndex       The index to move item at moveIndex to. (required)
*/
function move(array, moveIndex, toIndex) {
	const { length } = array;
	if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {
		return array;
	}
	const item = array[moveIndex];
	const diff = moveIndex - toIndex;
	if (diff > 0) {
		// move left
		return [
			...array.slice(0, toIndex),
			item,
			...array.slice(toIndex, moveIndex),
			...array.slice(moveIndex + 1, length)
		];
	}
	if (diff < 0) {
		// move right
		return [
			...array.slice(0, moveIndex),
			...array.slice(moveIndex + 1, toIndex + 1),
			item,
			...array.slice(toIndex + 1, length)
		];
	}
	return array;
}
function _extends$o() {
	_extends$o = Object.assign.bind();
	return _extends$o.apply(this, arguments);
}
const EMPTY_ERRORS = [];
const EMPTY_WARNINGS = [];
function requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {
	if (typeof shouldUpdate === "function") {
		return shouldUpdate(prev, next, "source" in info ? { source: info.source } : {});
	}
	return prevValue !== nextValue;
}
// eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style
// We use Class instead of Hooks here since it will cost much code by using Hooks.
class Field extends reactExports.Component {
	static contextType = Context;
	state = { resetCount: 0 };
	cancelRegisterFunc = null;
	mounted = false;
	/**
	* Follow state should not management in State since it will async update by React.
	* This makes first render of form can not get correct state value.
	*/
	touched = false;
	/**
	* Mark when touched & validated. Currently only used for `dependencies`.
	* Note that we do not think field with `initialValue` is dirty
	* but this will be by `isFieldDirty` func.
	*/
	dirty = false;
	validatePromise;
	prevValidating;
	errors = EMPTY_ERRORS;
	warnings = EMPTY_WARNINGS;
	// ============================== Subscriptions ==============================
	constructor(props) {
		super(props);
		// Register on init
		if (props.fieldContext) {
			const { getInternalHooks } = props.fieldContext;
			const { initEntityValue } = getInternalHooks(HOOK_MARK);
			initEntityValue(this);
		}
	}
	componentDidMount() {
		const { shouldUpdate, fieldContext } = this.props;
		this.mounted = true;
		// Register on init
		if (fieldContext) {
			const { getInternalHooks } = fieldContext;
			const { registerField } = getInternalHooks(HOOK_MARK);
			this.cancelRegisterFunc = registerField(this);
		}
		// One more render for component in case fields not ready
		if (shouldUpdate === true) {
			this.reRender();
		}
	}
	componentWillUnmount() {
		this.cancelRegister();
		this.triggerMetaEvent(true);
		this.mounted = false;
	}
	cancelRegister = () => {
		const { preserve, isListField, name } = this.props;
		if (this.cancelRegisterFunc) {
			this.cancelRegisterFunc(isListField, preserve, getNamePath(name));
		}
		this.cancelRegisterFunc = null;
	};
	// ================================== Utils ==================================
	getNamePath = () => {
		const { name, fieldContext } = this.props;
		const { prefixName = [] } = fieldContext;
		return name !== void 0 ? [...prefixName, ...name] : [];
	};
	getRules = () => {
		const { rules = [], fieldContext } = this.props;
		return rules.map((rule) => {
			if (typeof rule === "function") {
				return rule(fieldContext);
			}
			return rule;
		});
	};
	reRender() {
		if (!this.mounted) return;
		this.forceUpdate();
	}
	refresh = () => {
		if (!this.mounted) return;
		/**
		* Clean up current node.
		*/
		this.setState(({ resetCount }) => ({ resetCount: resetCount + 1 }));
	};
	// Event should only trigger when meta changed
	metaCache = null;
	triggerMetaEvent = (destroy) => {
		const { onMetaChange } = this.props;
		if (onMetaChange) {
			const meta = {
				...this.getMeta(),
				destroy
			};
			if (!isEqual(this.metaCache, meta)) {
				onMetaChange(meta);
			}
			this.metaCache = meta;
		} else {
			this.metaCache = null;
		}
	};
	// ========================= Field Entity Interfaces =========================
	// Trigger by store update. Check if need update the component
	onStoreChange = (prevStore, namePathList, info) => {
		const { shouldUpdate, dependencies = [], onReset } = this.props;
		const { store } = info;
		const namePath = this.getNamePath();
		const prevValue = this.getValue(prevStore);
		const curValue = this.getValue(store);
		const namePathMatch = namePathList && containsNamePath(namePathList, namePath);
		// `setFieldsValue` is a quick access to update related status
		if (info.type === "valueUpdate" && info.source === "external" && !isEqual(prevValue, curValue)) {
			this.touched = true;
			this.dirty = true;
			this.validatePromise = null;
			this.errors = EMPTY_ERRORS;
			this.warnings = EMPTY_WARNINGS;
			this.triggerMetaEvent();
		}
		switch (info.type) {
			case "reset":
				if (!namePathList || namePathMatch) {
					// Clean up state
					this.touched = false;
					this.dirty = false;
					this.validatePromise = void 0;
					this.errors = EMPTY_ERRORS;
					this.warnings = EMPTY_WARNINGS;
					this.triggerMetaEvent();
					onReset?.();
					this.refresh();
					return;
				}
				break;
			case "remove": {
				if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
					this.reRender();
					return;
				}
				break;
			}
			case "setField": {
				const { data } = info;
				if (namePathMatch) {
					if ("touched" in data) {
						this.touched = data.touched;
					}
					if ("validating" in data && !("originRCField" in data)) {
						this.validatePromise = data.validating ? Promise.resolve([]) : null;
					}
					if ("errors" in data) {
						this.errors = data.errors || EMPTY_ERRORS;
					}
					if ("warnings" in data) {
						this.warnings = data.warnings || EMPTY_WARNINGS;
					}
					this.dirty = true;
					this.triggerMetaEvent();
					this.reRender();
					return;
				} else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
					// Contains path with value should also check
					this.reRender();
					return;
				}
				// Handle update by `setField` with `shouldUpdate`
				if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
					this.reRender();
					return;
				}
				break;
			}
			case "dependenciesUpdate": {
				/**
				* Trigger when marked `dependencies` updated. Related fields will all update
				*/
				const dependencyList = dependencies.map(getNamePath);
				// No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be
				// emitted earlier and they will work there
				// If set it may cause unnecessary twice rerendering
				if (dependencyList.some((dependency) => containsNamePath(info.relatedFields, dependency))) {
					this.reRender();
					return;
				}
				break;
			}
			default:
				// 1. If `namePath` exists in `namePathList`, means it's related value and should update
				//      For example <List name="list"><Field name={['list', 0]}></List>
				//      If `namePathList` is [['list']] (List value update), Field should be updated
				//      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated
				// 2.
				//   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,
				//       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`
				//       is not provided
				//   2.2 If `shouldUpdate` provided, use customize logic to update the field
				//       else to check if value changed
				if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
					this.reRender();
					return;
				}
				break;
		}
		if (shouldUpdate === true) {
			this.reRender();
		}
	};
	validateRules = (options) => {
		// We should fixed namePath & value to avoid developer change then by form function
		const namePath = this.getNamePath();
		const currentValue = this.getValue();
		const { triggerName, validateOnly = false } = options || {};
		// Force change to async to avoid rule OOD under renderProps field
		const rootPromise = Promise.resolve().then(async () => {
			if (!this.mounted) {
				return [];
			}
			const { validateFirst = false, messageVariables, validateDebounce } = this.props;
			// Start validate
			let filteredRules = this.getRules();
			if (triggerName) {
				filteredRules = filteredRules.filter((rule) => rule).filter((rule) => {
					const { validateTrigger } = rule;
					if (!validateTrigger) {
						return true;
					}
					const triggerList = toArray$1(validateTrigger);
					return triggerList.includes(triggerName);
				});
			}
			// Wait for debounce. Skip if no `triggerName` since its from `validateFields / submit`
			if (validateDebounce && triggerName) {
				await new Promise((resolve) => {
					setTimeout(resolve, validateDebounce);
				});
				// Skip since out of date
				if (this.validatePromise !== rootPromise) {
					return [];
				}
			}
			const promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
			promise.catch((e) => e).then((ruleErrors = EMPTY_ERRORS) => {
				if (this.validatePromise === rootPromise) {
					this.validatePromise = null;
					// Get errors & warnings
					const nextErrors = [];
					const nextWarnings = [];
					ruleErrors.forEach?.(({ rule: { warningOnly }, errors = EMPTY_ERRORS }) => {
						if (warningOnly) {
							nextWarnings.push(...errors);
						} else {
							nextErrors.push(...errors);
						}
					});
					this.errors = nextErrors;
					this.warnings = nextWarnings;
					this.triggerMetaEvent();
					this.reRender();
				}
			});
			return promise;
		});
		if (validateOnly) {
			return rootPromise;
		}
		this.validatePromise = rootPromise;
		this.dirty = true;
		this.errors = EMPTY_ERRORS;
		this.warnings = EMPTY_WARNINGS;
		this.triggerMetaEvent();
		// Force trigger re-render since we need sync renderProps with new meta
		this.reRender();
		return rootPromise;
	};
	isFieldValidating = () => !!this.validatePromise;
	isFieldTouched = () => this.touched;
	isFieldDirty = () => {
		// Touched or validate or has initialValue
		if (this.dirty || this.props.initialValue !== void 0) {
			return true;
		}
		// Form set initialValue
		const { fieldContext } = this.props;
		const { getInitialValue } = fieldContext.getInternalHooks(HOOK_MARK);
		if (getInitialValue(this.getNamePath()) !== void 0) {
			return true;
		}
		return false;
	};
	getErrors = () => this.errors;
	getWarnings = () => this.warnings;
	isListField = () => this.props.isListField;
	isList = () => this.props.isList;
	isPreserve = () => this.props.preserve;
	// ============================= Child Component =============================
	getMeta = () => {
		// Make error & validating in cache to save perf
		this.prevValidating = this.isFieldValidating();
		const meta = {
			touched: this.isFieldTouched(),
			validating: this.prevValidating,
			errors: this.errors,
			warnings: this.warnings,
			name: this.getNamePath(),
			validated: this.validatePromise === null
		};
		return meta;
	};
	// Only return validate child node. If invalidate, will do nothing about field.
	getOnlyChild = (children) => {
		// Support render props
		if (typeof children === "function") {
			const meta = this.getMeta();
			return {
				...this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext)),
				isFunction: true
			};
		}
		// Filed element only
		const childList = toArray$3(children);
		if (childList.length !== 1 || !reactExports.isValidElement(childList[0])) {
			return {
				child: childList,
				isFunction: false
			};
		}
		return {
			child: childList[0],
			isFunction: false
		};
	};
	// ============================== Field Control ==============================
	getValue = (store) => {
		const { getFieldsValue } = this.props.fieldContext;
		const namePath = this.getNamePath();
		return get(store || getFieldsValue(true), namePath);
	};
	getControlled = (childProps = {}) => {
		const { name, trigger = "onChange", validateTrigger, getValueFromEvent, normalize, valuePropName = "value", getValueProps, fieldContext } = this.props;
		const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
		const namePath = this.getNamePath();
		const { getInternalHooks, getFieldsValue } = fieldContext;
		const { dispatch } = getInternalHooks(HOOK_MARK);
		const value = this.getValue();
		const mergedGetValueProps = getValueProps || ((val) => ({ [valuePropName]: val }));
		const originTriggerFunc = childProps[trigger];
		const valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
		const control = {
			...childProps,
			...valueProps
		};
		// Add trigger
		control[trigger] = (...args) => {
			// Mark as touched
			this.touched = true;
			this.dirty = true;
			this.triggerMetaEvent();
			let newValue;
			if (getValueFromEvent) {
				newValue = getValueFromEvent(...args);
			} else {
				newValue = defaultGetValueFromEvent(valuePropName, ...args);
			}
			if (normalize) {
				newValue = normalize(newValue, value, getFieldsValue(true));
			}
			if (newValue !== value) {
				dispatch({
					type: "updateValue",
					namePath,
					value: newValue
				});
			}
			if (originTriggerFunc) {
				originTriggerFunc(...args);
			}
		};
		// Add validateTrigger
		const validateTriggerList = toArray$1(mergedValidateTrigger || []);
		validateTriggerList.forEach((triggerName) => {
			// Wrap additional function of component, so that we can get latest value from store
			const originTrigger = control[triggerName];
			control[triggerName] = (...args) => {
				if (originTrigger) {
					originTrigger(...args);
				}
				// Always use latest rules
				const { rules } = this.props;
				if (rules && rules.length) {
					// We dispatch validate to root,
					// since it will update related data with other field with same name
					dispatch({
						type: "validateField",
						namePath,
						triggerName
					});
				}
			};
		});
		return control;
	};
	render() {
		const { resetCount } = this.state;
		const { children } = this.props;
		const { child, isFunction } = this.getOnlyChild(children);
		// Not need to `cloneElement` since user can handle this in render function self
		let returnChildNode;
		if (isFunction) {
			returnChildNode = child;
		} else if (reactExports.isValidElement(child)) {
			returnChildNode = reactExports.cloneElement(child, this.getControlled(child.props));
		} else {
			warningOnce(!child, "`children` of Field is not validate ReactElement.");
			returnChildNode = child;
		}
		return reactExports.createElement(reactExports.Fragment, { key: resetCount }, returnChildNode);
	}
}
function WrapperField({ name, ...restProps }) {
	const fieldContext = reactExports.useContext(Context);
	const listContext = reactExports.useContext(ListContext);
	const namePath = name !== void 0 ? getNamePath(name) : void 0;
	const isMergedListField = restProps.isListField ?? !!listContext;
	let key = "keep";
	if (!isMergedListField) {
		key = `_${(namePath || []).join("_")}`;
	}
	return reactExports.createElement(Field, _extends$o({
		key,
		name: namePath,
		isListField: isMergedListField
	}, restProps, { fieldContext }));
}
function List({ name, initialValue, children, rules, validateTrigger, isListField }) {
	const context = reactExports.useContext(Context);
	const wrapperListContext = reactExports.useContext(ListContext);
	const keyRef = reactExports.useRef({
		keys: [],
		id: 0
	});
	const keyManager = keyRef.current;
	const prefixName = reactExports.useMemo(() => {
		const parentPrefixName = getNamePath(context.prefixName) || [];
		return [...parentPrefixName, ...getNamePath(name)];
	}, [context.prefixName, name]);
	const fieldContext = reactExports.useMemo(() => ({
		...context,
		prefixName
	}), [context, prefixName]);
	// List context
	const listContext = reactExports.useMemo(() => ({ getKey: (namePath) => {
		const len = prefixName.length;
		const pathName = namePath[len];
		return [keyManager.keys[pathName], namePath.slice(len + 1)];
	} }), [keyManager, prefixName]);
	// User should not pass `children` as other type.
	if (typeof children !== "function") {
		warningOnce(false, "Form.List only accepts function as children.");
		return null;
	}
	const shouldUpdate = (prevValue, nextValue, { source }) => {
		if (source === "internal") {
			return false;
		}
		return prevValue !== nextValue;
	};
	return reactExports.createElement(ListContext.Provider, { value: listContext }, reactExports.createElement(Context.Provider, { value: fieldContext }, reactExports.createElement(WrapperField, {
		name: [],
		shouldUpdate,
		rules,
		validateTrigger,
		initialValue,
		isList: true,
		isListField: isListField ?? !!wrapperListContext
	}, ({ value = [], onChange }, meta) => {
		const { getFieldValue } = context;
		const getNewValue = () => {
			const values = getFieldValue(prefixName || []);
			return values || [];
		};
		/**
		* Always get latest value in case user update fields by `form` api.
		*/
		const operations = {
			add: (defaultValue, index) => {
				// Mapping keys
				const newValue = getNewValue();
				if (index >= 0 && index <= newValue.length) {
					keyManager.keys = [
						...keyManager.keys.slice(0, index),
						keyManager.id,
						...keyManager.keys.slice(index)
					];
					onChange([
						...newValue.slice(0, index),
						defaultValue,
						...newValue.slice(index)
					]);
				} else {
					keyManager.keys = [...keyManager.keys, keyManager.id];
					onChange([...newValue, defaultValue]);
				}
				keyManager.id += 1;
			},
			remove: (index) => {
				const newValue = getNewValue();
				const indexSet = new Set(Array.isArray(index) ? index : [index]);
				if (indexSet.size <= 0) {
					return;
				}
				keyManager.keys = keyManager.keys.filter((__unused_EF54, keysIndex) => !indexSet.has(keysIndex));
				// Trigger store change
				onChange(newValue.filter((__unused_17FF, valueIndex) => !indexSet.has(valueIndex)));
			},
			move(from, to) {
				if (from === to) {
					return;
				}
				const newValue = getNewValue();
				// Do not handle out of range
				if (from < 0 || from >= newValue.length || to < 0 || to >= newValue.length) {
					return;
				}
				keyManager.keys = move(keyManager.keys, from, to);
				// Trigger store change
				onChange(move(newValue, from, to));
			}
		};
		let listValue = value || [];
		if (!Array.isArray(listValue)) {
			listValue = [];
		}
		return children(listValue.map((__unused_38A6, index) => {
			let key = keyManager.keys[index];
			if (key === void 0) {
				keyManager.keys[index] = keyManager.id;
				key = keyManager.keys[index];
				keyManager.id += 1;
			}
			return {
				name: index,
				key,
				isListField: true
			};
		}), operations, meta);
	})));
}
function allPromiseFinish(promiseList) {
	let hasError = false;
	let count = promiseList.length;
	const results = [];
	if (!promiseList.length) {
		return Promise.resolve([]);
	}
	return new Promise((resolve, reject) => {
		promiseList.forEach((promise, index) => {
			promise.catch((e) => {
				hasError = true;
				return e;
			}).then((result) => {
				count -= 1;
				results[index] = result;
				if (count > 0) {
					return;
				}
				if (hasError) {
					reject(results);
				}
				resolve(results);
			});
		});
	});
}
const SPLIT = "__@field_split__";
/**
* Convert name path into string to fast the fetch speed of Map.
*/
function normalize(namePath) {
	return namePath.map((cell) => `${typeof cell}:${cell}`).join(SPLIT);
}
/**
* NameMap like a `Map` but accepts `string[]` as key.
*/
class NameMap {
	kvs = new Map();
	set(key, value) {
		this.kvs.set(normalize(key), value);
	}
	get(key) {
		return this.kvs.get(normalize(key));
	}
	getAsPrefix(key) {
		const normalizedKey = normalize(key);
		const normalizedPrefix = normalizedKey + SPLIT;
		const results = [];
		const current = this.kvs.get(normalizedKey);
		if (current !== void 0) {
			results.push(current);
		}
		this.kvs.forEach((value, itemNormalizedKey) => {
			if (itemNormalizedKey.startsWith(normalizedPrefix)) {
				results.push(value);
			}
		});
		return results;
	}
	update(key, updater) {
		const origin = this.get(key);
		const next = updater(origin);
		if (!next) {
			this.delete(key);
		} else {
			this.set(key, next);
		}
	}
	delete(key) {
		this.kvs.delete(normalize(key));
	}
	// Since we only use this in test, let simply realize this
	map(callback) {
		return [...this.kvs.entries()].map(([key, value]) => {
			const cells = key.split(SPLIT);
			return callback({
				key: cells.map((cell) => {
					const [, type, unit] = cell.match(/^([^:]*):(.*)$/);
					return type === "number" ? Number(unit) : unit;
				}),
				value
			});
		});
	}
	toJSON() {
		const json = {};
		this.map(({ key, value }) => {
			json[key.join(".")] = value;
			return null;
		});
		return json;
	}
}
/**
* Call action with delay in macro task.
*/
const macroTask = (fn) => {
	const channel = new MessageChannel();
	channel.port1.onmessage = fn;
	channel.port2.postMessage(null);
};
class WatcherCenter {
	a = [];
	b = 0;
	c = new Set();
	constructor(form) {
		this.d = form;
	}
	e(callback) {
		this.c.add(callback);
		return () => {
			this.c.delete(callback);
		};
	}
	g(namePath) {
		// Insert with deduplication
		namePath.forEach((path) => {
			if (this.a.every((exist) => !matchNamePath(exist, path))) {
				this.a.push(path);
			}
		});
		this.f();
	}
	f() {
		this.b += 1;
		const currentId = this.b;
		macroTask(() => {
			if (currentId === this.b && this.c.size) {
				const formInst = this.d.a();
				const values = formInst.getFieldsValue();
				const allValues = formInst.getFieldsValue(true);
				this.c.forEach((callback) => {
					callback(values, allValues, this.a);
				});
				this.a = [];
			}
		});
	}
}
class FormStore {
	b = true;
	c = {};
	d = [];
	e = {};
	f = {};
	g = null;
	h = null;
	i = null;
	j = new WatcherCenter(this);
	constructor(forceRootUpdate) {
		this.k = forceRootUpdate;
	}
	a = () => ({
		getFieldValue: this.l,
		getFieldsValue: this.m,
		getFieldError: this.n,
		getFieldWarning: this.o,
		getFieldsError: this.p,
		isFieldsTouched: this.q,
		isFieldTouched: this.r,
		isFieldValidating: this.s,
		isFieldsValidating: this.t,
		resetFields: this.u,
		setFields: this.v,
		setFieldValue: this.w,
		setFieldsValue: this.x,
		validateFields: this.y,
		submit: this.z,
		_init: true,
		getInternalHooks: this.A
	});
	// ======================== Internal Hooks ========================
	A = (key) => {
		if (key === HOOK_MARK) {
			return {
				dispatch: this.B,
				initEntityValue: this.C,
				registerField: this.D,
				useSubscribe: this.E,
				setInitialValues: this.F,
				destroyForm: this.G,
				setCallbacks: this.H,
				setValidateMessages: this.I,
				getFields: this.J,
				setPreserve: this.K,
				getInitialValue: this.L,
				registerWatch: this.M
			};
		}
		warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
		return null;
	};
	E = (subscribable) => {
		this.b = subscribable;
	};
	/**
	* Record prev Form unmount fieldEntities which config preserve false.
	* This need to be refill with initialValues instead of store value.
	*/
	N = null;
	/**
	* First time `setInitialValues` should update store with initial value
	*/
	F = (initialValues, init) => {
		this.e = initialValues || {};
		if (init) {
			let nextStore = merge$1(initialValues, this.c);
			// We will take consider prev form unmount fields.
			// When the field is not `preserve`, we need fill this with initialValues instead of store.
			// eslint-disable-next-line array-callback-return
			this.N?.map(({ key: namePath }) => {
				nextStore = set(nextStore, namePath, get(initialValues, namePath));
			});
			this.N = null;
			this.O(nextStore);
		}
	};
	G = (clearOnDestroy) => {
		if (clearOnDestroy) {
			// destroy form reset store
			this.O({});
		} else {
			// Fill preserve fields
			const prevWithoutPreserves = new NameMap();
			this.P(true).forEach((entity) => {
				if (!this.Q(entity.isPreserve())) {
					prevWithoutPreserves.set(entity.getNamePath(), true);
				}
			});
			this.N = prevWithoutPreserves;
		}
	};
	L = (namePath) => {
		const initValue = get(this.e, namePath);
		// Not cloneDeep when without `namePath`
		return namePath.length ? merge$1(initValue) : initValue;
	};
	H = (callbacks) => {
		this.f = callbacks;
	};
	I = (validateMessages) => {
		this.g = validateMessages;
	};
	K = (preserve) => {
		this.h = preserve;
	};
	// ============================= Watch ============================
	M = (callback) => {
		return this.j.e(callback);
	};
	R = (namePath = []) => {
		this.j.g(namePath);
	};
	// ============================ Store =============================
	O = (nextStore) => {
		this.c = nextStore;
	};
	// ============================ Fields ============================
	/**
	* Get registered field entities.
	* @param pure Only return field which has a `name`. Default: false
	*/
	P = (pure = false) => {
		if (!pure) {
			return this.d;
		}
		return this.d.filter((field) => field.getNamePath().length);
	};
	/**
	* Get a map of registered field entities with their name path as the key.
	* @param pure Only include fields which have a `name`. Default: false
	* @returns A NameMap containing field entities indexed by their name paths
	*/
	S = () => {
		const cache = new NameMap();
		this.P(true).forEach((field) => {
			const namePath = field.getNamePath();
			cache.set(namePath, field);
		});
		return cache;
	};
	/**
	* Get field entities based on a list of name paths.
	* @param nameList - Array of name paths to search for. If not provided, returns all field entities with names.
	* @param includesSubNamePath - Whether to include fields that have the given name path as a prefix.
	*/
	T = (nameList, includesSubNamePath = false) => {
		if (!nameList) {
			return this.P(true);
		}
		const cache = this.S();
		if (!includesSubNamePath) {
			return nameList.map((name) => {
				const namePath = getNamePath(name);
				return cache.get(namePath) || { INVALIDATE_NAME_PATH: getNamePath(name) };
			});
		}
		return nameList.flatMap((name) => {
			const namePath = getNamePath(name);
			const fields = cache.getAsPrefix(namePath);
			if (fields.length) {
				return fields;
			}
			return [{ INVALIDATE_NAME_PATH: namePath }];
		});
	};
	m = (nameList, filterFunc) => {
		// Fill args
		let mergedNameList;
		let mergedFilterFunc;
		if (nameList === true || Array.isArray(nameList)) {
			mergedNameList = nameList;
			mergedFilterFunc = filterFunc;
		} else if (nameList && typeof nameList === "object") {
			mergedFilterFunc = nameList.filter;
		}
		if (mergedNameList === true && !mergedFilterFunc) {
			return this.c;
		}
		const fieldEntities = this.T(Array.isArray(mergedNameList) ? mergedNameList : null, true);
		const filteredNameList = [];
		const listNamePaths = [];
		fieldEntities.forEach((entity) => {
			const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();
			// Ignore when it's a list item and not specific the namePath,
			// since parent field is already take in count
			if (entity.isList?.()) {
				listNamePaths.push(namePath);
				return;
			}
			if (!mergedFilterFunc) {
				filteredNameList.push(namePath);
			} else {
				const meta = "getMeta" in entity ? entity.getMeta() : null;
				if (mergedFilterFunc(meta)) {
					filteredNameList.push(namePath);
				}
			}
		});
		let mergedValues = cloneByNamePathList(this.c, filteredNameList.map(getNamePath));
		// We need fill the list as [] if Form.List is empty
		listNamePaths.forEach((namePath) => {
			if (!get(mergedValues, namePath)) {
				mergedValues = set(mergedValues, namePath, []);
			}
		});
		return mergedValues;
	};
	l = (name) => {
		const namePath = getNamePath(name);
		return get(this.c, namePath);
	};
	p = (nameList) => {
		const fieldEntities = this.T(nameList);
		return fieldEntities.map((entity, index) => {
			if (entity && !entity.INVALIDATE_NAME_PATH) {
				return {
					name: entity.getNamePath(),
					errors: entity.getErrors(),
					warnings: entity.getWarnings()
				};
			}
			return {
				name: getNamePath(nameList[index]),
				errors: [],
				warnings: []
			};
		});
	};
	n = (name) => {
		const namePath = getNamePath(name);
		const fieldError = this.p([namePath])[0];
		return fieldError.errors;
	};
	o = (name) => {
		const namePath = getNamePath(name);
		const fieldError = this.p([namePath])[0];
		return fieldError.warnings;
	};
	q = (...args) => {
		const [arg0, arg1] = args;
		let namePathList;
		let isAllFieldsTouched = false;
		if (args.length === 0) {
			namePathList = null;
		} else if (args.length === 1) {
			if (Array.isArray(arg0)) {
				namePathList = arg0.map(getNamePath);
				isAllFieldsTouched = false;
			} else {
				namePathList = null;
				isAllFieldsTouched = arg0;
			}
		} else {
			namePathList = arg0.map(getNamePath);
			isAllFieldsTouched = arg1;
		}
		const fieldEntities = this.P(true);
		const isFieldTouched = (field) => field.isFieldTouched();
		// ===== Will get fully compare when not config namePathList =====
		if (!namePathList) {
			return isAllFieldsTouched ? fieldEntities.every((entity) => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);
		}
		// Generate a nest tree for validate
		const map = new NameMap();
		namePathList.forEach((shortNamePath) => {
			map.set(shortNamePath, []);
		});
		fieldEntities.forEach((field) => {
			const fieldNamePath = field.getNamePath();
			// Find matched entity and put into list
			namePathList.forEach((shortNamePath) => {
				if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {
					map.update(shortNamePath, (list) => [...list, field]);
				}
			});
		});
		// Check if NameMap value is touched
		const isNamePathListTouched = (entities) => entities.some(isFieldTouched);
		const namePathListEntities = map.map(({ value }) => value);
		return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
	};
	r = (name) => {
		return this.q([name]);
	};
	t = (nameList) => {
		const fieldEntities = this.P();
		if (!nameList) {
			return fieldEntities.some((testField) => testField.isFieldValidating());
		}
		const namePathList = nameList.map(getNamePath);
		return fieldEntities.some((testField) => {
			const fieldNamePath = testField.getNamePath();
			return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
		});
	};
	s = (name) => {
		return this.t([name]);
	};
	/**
	* Reset Field with field `initialValue` prop.
	* Can pass `entities` or `namePathList` or just nothing.
	*/
	U = (info = {}) => {
		// Create cache
		const cache = new NameMap();
		const fieldEntities = this.P(true);
		fieldEntities.forEach((field) => {
			const { initialValue } = field.props;
			const namePath = field.getNamePath();
			// Record only if has `initialValue`
			if (initialValue !== void 0) {
				const records = cache.get(namePath) || new Set();
				records.add({
					entity: field,
					value: initialValue
				});
				cache.set(namePath, records);
			}
		});
		// Reset
		const resetWithFields = (entities) => {
			entities.forEach((field) => {
				const { initialValue } = field.props;
				if (initialValue !== void 0) {
					const namePath = field.getNamePath();
					const formInitialValue = this.L(namePath);
					if (formInitialValue !== void 0) {
						// Warning if conflict with form initialValues and do not modify value
						warningOnce(false, `Form already set 'initialValues' with path '${namePath.join(".")}'. Field can not overwrite it.`);
					} else {
						const records = cache.get(namePath);
						if (records && records.size > 1) {
							// Warning if multiple field set `initialValue`and do not modify value
							warningOnce(false, `Multiple Field with path '${namePath.join(".")}' set 'initialValue'. Can not decide which one to pick.`);
						} else if (records) {
							const originValue = this.l(namePath);
							const isListField = field.isListField();
							// Set `initialValue`
							if (!isListField && (!info.skipExist || originValue === void 0)) {
								this.O(set(this.c, namePath, [...records][0].value));
							}
						}
					}
				}
			});
		};
		let requiredFieldEntities;
		if (info.entities) {
			requiredFieldEntities = info.entities;
		} else if (info.namePathList) {
			requiredFieldEntities = [];
			info.namePathList.forEach((namePath) => {
				const records = cache.get(namePath);
				if (records) {
					requiredFieldEntities.push(...[...records].map((r) => r.entity));
				}
			});
		} else {
			requiredFieldEntities = fieldEntities;
		}
		resetWithFields(requiredFieldEntities);
	};
	u = (nameList) => {
		const prevStore = this.c;
		if (!nameList) {
			this.O(merge$1(this.e));
			this.U();
			this.V(prevStore, null, { type: "reset" });
			this.R();
			return;
		}
		// Reset by `nameList`
		const namePathList = nameList.map(getNamePath);
		namePathList.forEach((namePath) => {
			const initialValue = this.L(namePath);
			this.O(set(this.c, namePath, initialValue));
		});
		this.U({ namePathList });
		this.V(prevStore, namePathList, { type: "reset" });
		this.R(namePathList);
	};
	v = (fields) => {
		const prevStore = this.c;
		const namePathList = [];
		fields.forEach((fieldData) => {
			const { name, ...data } = fieldData;
			const namePath = getNamePath(name);
			namePathList.push(namePath);
			// Value
			if ("value" in data) {
				this.O(set(this.c, namePath, data.value));
			}
			this.V(prevStore, [namePath], {
				type: "setField",
				data: fieldData
			});
		});
		this.R(namePathList);
	};
	J = () => {
		const entities = this.P(true);
		const fields = entities.map((field) => {
			const namePath = field.getNamePath();
			const meta = field.getMeta();
			const fieldData = {
				...meta,
				name: namePath,
				value: this.l(namePath)
			};
			Object.defineProperty(fieldData, "originRCField", { value: true });
			return fieldData;
		});
		return fields;
	};
	// =========================== Observer ===========================
	/**
	* This only trigger when a field is on constructor to avoid we get initialValue too late
	*/
	C = (entity) => {
		const { initialValue } = entity.props;
		if (initialValue !== void 0) {
			const namePath = entity.getNamePath();
			const prevValue = get(this.c, namePath);
			if (prevValue === void 0) {
				this.O(set(this.c, namePath, initialValue));
			}
		}
	};
	Q = (fieldPreserve) => {
		const mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : this.h;
		return mergedPreserve ?? true;
	};
	D = (entity) => {
		this.d.push(entity);
		const namePath = entity.getNamePath();
		this.R([namePath]);
		// Set initial values
		if (entity.props.initialValue !== void 0) {
			const prevStore = this.c;
			this.U({
				entities: [entity],
				skipExist: true
			});
			this.V(prevStore, [entity.getNamePath()], {
				type: "valueUpdate",
				source: "internal"
			});
		}
		// un-register field callback
		return (isListField, preserve, subNamePath = []) => {
			this.d = this.d.filter((item) => item !== entity);
			// Clean up store value if not preserve
			if (!this.Q(preserve) && (!isListField || subNamePath.length > 1)) {
				const defaultValue = isListField ? void 0 : this.L(namePath);
				if (namePath.length && this.l(namePath) !== defaultValue && this.d.every((field) => !matchNamePath(field.getNamePath(), namePath))) {
					const prevStore = this.c;
					this.O(set(prevStore, namePath, defaultValue, true));
					// Notify that field is unmount
					this.V(prevStore, [namePath], { type: "remove" });
					// Dependencies update
					this.W(prevStore, namePath);
				}
			}
			this.R([namePath]);
		};
	};
	B = (action) => {
		switch (action.type) {
			case "updateValue": {
				const { namePath, value } = action;
				this.X(namePath, value);
				break;
			}
			case "validateField": {
				const { namePath, triggerName } = action;
				this.y([namePath], { triggerName });
				break;
			}
		}
	};
	V = (prevStore, namePathList, info) => {
		if (this.b) {
			const mergedInfo = {
				...info,
				store: this.m(true)
			};
			this.P().forEach(({ onStoreChange }) => {
				onStoreChange(prevStore, namePathList, mergedInfo);
			});
		} else {
			this.k();
		}
	};
	/**
	* Notify dependencies children with parent update
	* We need delay to trigger validate in case Field is under render props
	*/
	W = (prevStore, namePath) => {
		const childrenFields = this.Y(namePath);
		if (childrenFields.length) {
			this.y(childrenFields);
		}
		this.V(prevStore, childrenFields, {
			type: "dependenciesUpdate",
			relatedFields: [namePath, ...childrenFields]
		});
		return childrenFields;
	};
	X = (name, value) => {
		const namePath = getNamePath(name);
		const prevStore = this.c;
		this.O(set(this.c, namePath, value));
		this.V(prevStore, [namePath], {
			type: "valueUpdate",
			source: "internal"
		});
		this.R([namePath]);
		// Dependencies update
		const childrenFields = this.W(prevStore, namePath);
		// trigger callback function
		const { onValuesChange } = this.f;
		if (onValuesChange) {
			const fieldEntity = this.S().get(namePath);
			const changedValues = cloneByNamePathList(this.c, [namePath]);
			const allValues = this.m();
			// Merge changedValues into allValues to ensure allValues contains the latest changes
			const mergedAllValues = mergeWith([allValues, changedValues], { prepareArray: (current) => fieldEntity?.isList() ? [] : [...current || []] });
			onValuesChange(changedValues, mergedAllValues);
		}
		this.Z([namePath, ...childrenFields]);
	};
	// Let all child Field get update.
	x = (store) => {
		const prevStore = this.c;
		if (store) {
			const nextStore = merge$1(this.c, store);
			this.O(nextStore);
		}
		this.V(prevStore, null, {
			type: "valueUpdate",
			source: "external"
		});
		this.R();
	};
	w = (name, value) => {
		this.v([{
			name,
			value,
			errors: [],
			warnings: [],
			touched: true
		}]);
	};
	Y = (rootNamePath) => {
		const children = new Set();
		const childrenFields = [];
		const dependencies2fields = new NameMap();
		/**
		* Generate maps
		* Can use cache to save perf if user report performance issue with this
		*/
		this.P().forEach((field) => {
			const { dependencies } = field.props;
			(dependencies || []).forEach((dependency) => {
				const dependencyNamePath = getNamePath(dependency);
				dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {
					fields.add(field);
					return fields;
				});
			});
		});
		const fillChildren = (namePath) => {
			const fields = dependencies2fields.get(namePath) || new Set();
			fields.forEach((field) => {
				if (!children.has(field)) {
					children.add(field);
					const fieldNamePath = field.getNamePath();
					if (field.isFieldDirty() && fieldNamePath.length) {
						childrenFields.push(fieldNamePath);
						fillChildren(fieldNamePath);
					}
				}
			});
		};
		fillChildren(rootNamePath);
		return childrenFields;
	};
	Z = (namePathList, filedErrors) => {
		const { onFieldsChange } = this.f;
		if (onFieldsChange) {
			const fields = this.J();
			/**
			* Fill errors since `fields` may be replaced by controlled fields
			*/
			if (filedErrors) {
				const cache = new NameMap();
				filedErrors.forEach(({ name, errors }) => {
					cache.set(name, errors);
				});
				fields.forEach((field) => {
					// eslint-disable-next-line no-param-reassign
					field.errors = cache.get(field.name) || field.errors;
				});
			}
			const changedFields = fields.filter(({ name: fieldName }) => containsNamePath(namePathList, fieldName));
			if (changedFields.length) {
				onFieldsChange(changedFields, fields);
			}
		}
	};
	// =========================== Validate ===========================
	y = (arg1, arg2) => {
		let nameList;
		let options;
		if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
			nameList = arg1;
			options = arg2;
		} else {
			options = arg1;
		}
		const provideNameList = !!nameList;
		const namePathList = provideNameList ? nameList.map(getNamePath) : [];
		// Same namePathList, but does not include Form.List name
		const finalValueNamePathList = [...namePathList];
		// Collect result in promise list
		const promiseList = [];
		// We temp save the path which need trigger for `onFieldsChange`
		const TMP_SPLIT = String(Date.now());
		const validateNamePathList = new Set();
		const { recursive, dirty } = options || {};
		this.P(true).forEach((field) => {
			const fieldNamePath = field.getNamePath();
			// Add field if not provide `nameList`
			if (!provideNameList) {
				if (!field.isList() || !namePathList.some((name) => matchNamePath(name, fieldNamePath, true))) {
					finalValueNamePathList.push(fieldNamePath);
				}
				namePathList.push(fieldNamePath);
			}
			// Skip if without rule
			if (!field.props.rules || !field.props.rules.length) {
				return;
			}
			// Skip if only validate dirty field
			if (dirty && !field.isFieldDirty()) {
				return;
			}
			validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
			// Add field validate rule in to promise list
			if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
				const promise = field.validateRules({
					validateMessages: {
						...defaultValidateMessages,
						...this.g
					},
					...options
				});
				// Wrap promise with field
				promiseList.push(promise.then(() => ({
					name: fieldNamePath,
					errors: [],
					warnings: []
				})).catch((ruleErrors) => {
					const mergedErrors = [];
					const mergedWarnings = [];
					ruleErrors.forEach?.(({ rule: { warningOnly }, errors }) => {
						if (warningOnly) {
							mergedWarnings.push(...errors);
						} else {
							mergedErrors.push(...errors);
						}
					});
					if (mergedErrors.length) {
						return Promise.reject({
							name: fieldNamePath,
							errors: mergedErrors,
							warnings: mergedWarnings
						});
					}
					return {
						name: fieldNamePath,
						errors: mergedErrors,
						warnings: mergedWarnings
					};
				}));
			}
		});
		const summaryPromise = allPromiseFinish(promiseList);
		this.i = summaryPromise;
		// Notify fields with rule that validate has finished and need update
		summaryPromise.catch((results) => results).then((results) => {
			const resultNamePathList = results.map(({ name }) => name);
			this.V(this.c, resultNamePathList, { type: "validateFinish" });
			this.Z(resultNamePathList, results);
		});
		const returnPromise = summaryPromise.then(() => {
			if (this.i === summaryPromise) {
				return Promise.resolve(this.m(finalValueNamePathList));
			}
			return Promise.reject([]);
		}).catch((results) => {
			const errorList = results.filter((result) => result && result.errors.length);
			const errorMessage = errorList[0]?.errors?.[0];
			return Promise.reject({
				message: errorMessage,
				values: this.m(namePathList),
				errorFields: errorList,
				outOfDate: this.i !== summaryPromise
			});
		});
		// Do not throw in console
		returnPromise.catch((e) => e);
		// `validating` changed. Trigger `onFieldsChange`
		const triggerNamePathList = namePathList.filter((namePath) => validateNamePathList.has(namePath.join(TMP_SPLIT)));
		this.Z(triggerNamePathList);
		return returnPromise;
	};
	// ============================ Submit ============================
	z = () => {
		this.y().then((values) => {
			const { onFinish } = this.f;
			if (onFinish) {
				try {
					onFinish(values);
				} catch (err) {
					// Should print error if user `onFinish` callback failed
					console.error(err);
				}
			}
		}).catch((e) => {
			const { onFinishFailed } = this.f;
			if (onFinishFailed) {
				onFinishFailed(e);
			}
		});
	};
}
function useForm(form) {
	const formRef = reactExports.useRef(null);
	const [, forceUpdate] = reactExports.useState({});
	// Create singleton FormStore
	if (!formRef.current) {
		if (form) {
			formRef.current = form;
		} else {
			// Create a new FormStore if not provided
			const forceReRender = () => {
				forceUpdate({});
			};
			const formStore = new FormStore(forceReRender);
			formRef.current = formStore.a();
		}
	}
	return [formRef.current];
}
const FormContext = reactExports.createContext({
	triggerFormChange: () => {},
	triggerFormFinish: () => {},
	registerForm: () => {},
	unregisterForm: () => {}
});
const FormProvider = ({ validateMessages, onFormChange, onFormFinish, children }) => {
	const formContext = reactExports.useContext(FormContext);
	const formsRef = reactExports.useRef({});
	return reactExports.createElement(FormContext.Provider, { value: {
		...formContext,
		validateMessages: {
			...formContext.validateMessages,
			...validateMessages
		},
		triggerFormChange: (name, changedFields) => {
			if (onFormChange) {
				onFormChange(name, {
					changedFields,
					forms: formsRef.current
				});
			}
			formContext.triggerFormChange(name, changedFields);
		},
		triggerFormFinish: (name, values) => {
			if (onFormFinish) {
				onFormFinish(name, {
					values,
					forms: formsRef.current
				});
			}
			formContext.triggerFormFinish(name, values);
		},
		registerForm: (name, form) => {
			if (name) {
				formsRef.current = {
					...formsRef.current,
					[name]: form
				};
			}
			formContext.registerForm(name, form);
		},
		unregisterForm: (name) => {
			const newForms = { ...formsRef.current };
			delete newForms[name];
			formsRef.current = newForms;
			formContext.unregisterForm(name);
		}
	} }, children);
};
function _extends$n() {
	_extends$n = Object.assign.bind();
	return _extends$n.apply(this, arguments);
}
const Form = ({ name, initialValues, fields, form, preserve, children, component: Component = "form", validateMessages, validateTrigger = "onChange", onValuesChange, onFieldsChange, onFinish, onFinishFailed, clearOnDestroy, ...restProps }, ref) => {
	const nativeElementRef = reactExports.useRef(null);
	const formContext = reactExports.useContext(FormContext);
	// We customize handle event since Context will makes all the consumer re-render:
	// https://reactjs.org/docs/context.html#contextprovider
	const [formInstance] = useForm(form);
	const { useSubscribe, setInitialValues, setCallbacks, setValidateMessages, setPreserve, destroyForm } = formInstance.getInternalHooks(HOOK_MARK);
	// Pass ref with form instance
	reactExports.useImperativeHandle(ref, () => ({
		...formInstance,
		nativeElement: nativeElementRef.current
	}));
	// Register form into Context
	reactExports.useEffect(() => {
		formContext.registerForm(name, formInstance);
		return () => {
			formContext.unregisterForm(name);
		};
	}, [
		formContext,
		formInstance,
		name
	]);
	// Pass props to store
	setValidateMessages({
		...formContext.validateMessages,
		...validateMessages
	});
	setCallbacks({
		onValuesChange,
		onFieldsChange: (changedFields, ...rest) => {
			formContext.triggerFormChange(name, changedFields);
			if (onFieldsChange) {
				onFieldsChange(changedFields, ...rest);
			}
		},
		onFinish: (values) => {
			formContext.triggerFormFinish(name, values);
			if (onFinish) {
				onFinish(values);
			}
		},
		onFinishFailed
	});
	setPreserve(preserve);
	// Set initial value, init store value when first mount
	const mountRef = reactExports.useRef(null);
	setInitialValues(initialValues, !mountRef.current);
	if (!mountRef.current) {
		mountRef.current = true;
	}
	// ========================== Unmount ===========================
	reactExports.useEffect(
		() => () => destroyForm(clearOnDestroy),
		// eslint-disable-next-line react-hooks/exhaustive-deps
		[]
	);
	// Prepare children by `children` type
	let childrenNode;
	const childrenRenderProps = typeof children === "function";
	if (childrenRenderProps) {
		const values = formInstance.getFieldsValue(true);
		childrenNode = children(values, formInstance);
	} else {
		childrenNode = children;
	}
	// Not use subscribe when using render props
	useSubscribe(!childrenRenderProps);
	// Listen if fields provided. We use ref to save prev data here to avoid additional render
	const prevFieldsRef = reactExports.useRef(null);
	reactExports.useEffect(() => {
		if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
			formInstance.setFields(fields || []);
		}
		prevFieldsRef.current = fields;
	}, [fields, formInstance]);
	// =========================== Render ===========================
	const formContextValue = reactExports.useMemo(() => ({
		...formInstance,
		validateTrigger
	}), [formInstance, validateTrigger]);
	const wrapperNode = reactExports.createElement(ListContext.Provider, { value: null }, reactExports.createElement(Context.Provider, { value: formContextValue }, childrenNode));
	if (Component === false) {
		return wrapperNode;
	}
	return reactExports.createElement(Component, _extends$n({}, restProps, {
		ref: nativeElementRef,
		onSubmit: (event) => {
			event.preventDefault();
			event.stopPropagation();
			formInstance.submit();
		},
		onReset: (event) => {
			event.preventDefault();
			formInstance.resetFields();
			restProps.onReset?.(event);
		}
	}), wrapperNode);
};
function stringify(value) {
	try {
		return JSON.stringify(value);
	} catch {
		return Math.random();
	}
}
// ------- selector type -------
// ------- selector type end -------
function useWatch(...args) {
	const [dependencies, _form = {}] = args;
	const options = isFormInstance(_form) ? { form: _form } : _form;
	const form = options.form;
	const [value, ,] = reactExports.useState(() => typeof dependencies === "function" ? dependencies({}) : void 0);
	const valueStr = reactExports.useMemo(() => stringify(value), [value]);
	const valueStrRef = reactExports.useRef(valueStr);
	valueStrRef.current = valueStr;
	const fieldContext = reactExports.useContext(Context);
	const formInstance = form || fieldContext;
	const isValidForm = formInstance && formInstance._init;
	// ============================== Form ==============================
	const { getFieldsValue, getInternalHooks } = formInstance;
	const { registerWatch } = getInternalHooks(HOOK_MARK);
	// ============================= Update =============================
	const triggerUpdate = useEvent((values, allValues) => {
		const watchValue = options.preserve ? allValues ?? getFieldsValue(true) : values ?? getFieldsValue();
		const nextValue = typeof dependencies === "function" ? dependencies(watchValue) : get(watchValue, getNamePath(dependencies));
		{
			stringify(value), stringify(nextValue);
		}
	});
	// ============================= Effect =============================
	const flattenDeps = typeof dependencies === "function" ? dependencies : JSON.stringify(dependencies);
	// Deps changed
	reactExports.useEffect(() => {
		// Skip if not exist form instance
		if (!isValidForm) {
			return;
		}
		triggerUpdate();
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [isValidForm, flattenDeps]);
	// Value changed
	reactExports.useEffect(() => {
		// Skip if not exist form instance
		if (!isValidForm) {
			return;
		}
		const cancelRegister = registerWatch((values, allValues) => {
			triggerUpdate(values, allValues);
		});
		return cancelRegister;
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [isValidForm]);
	return value;
}
const InternalForm = reactExports.forwardRef(Form);
const RefForm = InternalForm;
RefForm.FormProvider = FormProvider;
RefForm.Field = WrapperField;
RefForm.List = List;
RefForm.useForm = useForm;
RefForm.useWatch = useWatch;
const FormItemInputContext = reactExports.createContext({});
const NoFormStyle = ({ children, status, override }) => {
	const formItemInputContext = reactExports.useContext(FormItemInputContext);
	const newFormItemInputContext = reactExports.useMemo(() => {
		const newContext = { ...formItemInputContext };
		if (override) {
			delete newContext.isFormItemInput;
		}
		if (status) {
			delete newContext.status;
			delete newContext.hasFeedback;
			delete newContext.feedbackIcon;
		}
		return newContext;
	}, [
		status,
		override,
		formItemInputContext
	]);
	return reactExports.createElement(FormItemInputContext.Provider, { value: newFormItemInputContext }, children);
};
const VariantContext = reactExports.createContext(void 0);
const ContextIsolator = (props) => {
	const { space, form, children } = props;
	if (!isNonNullable(children)) {
		return null;
	}
	let result = children;
	if (form) {
		result = React.createElement(NoFormStyle, {
			override: true,
			status: true
		}, result);
	}
	if (space) {
		result = React.createElement(NoCompactStyle, null, result);
	}
	return result;
};
function withPureRenderTheme(Component) {
	return (props) => reactExports.createElement(ConfigProvider, { theme: { token: {
		motion: false,
		zIndexPopupBase: 0
	} } }, reactExports.createElement(Component, { ...props }));
}
/* istanbul ignore next */
const genPurePanel = (Component) => {
	const PurePanel = (props) => {
		const { prefixCls: customizePrefixCls, style } = props;
		const holderRef = reactExports.useRef(null);
		const [popupHeight, setPopupHeight] = reactExports.useState(0);
		const [popupWidth, setPopupWidth] = reactExports.useState(0);
		const [open, setOpen] = useControlledState(false, props.open);
		const { getPrefixCls } = reactExports.useContext(ConfigContext);
		const prefixCls = getPrefixCls("picker", customizePrefixCls);
		reactExports.useEffect(() => {
			// We do not care about ssr
			setOpen(true);
			if (typeof ResizeObserver !== "undefined") {
				const resizeObserver = new ResizeObserver((entries) => {
					const element = entries[0].target;
					setPopupHeight(element.offsetHeight + 8);
					setPopupWidth(element.offsetWidth);
				});
				const interval = setInterval(() => {
					const dropdownCls = `.${prefixCls}-dropdown`;
					const popup = holderRef.current?.querySelector(dropdownCls);
					if (popup) {
						clearInterval(interval);
						resizeObserver.observe(popup);
					}
				}, 10);
				return () => {
					clearInterval(interval);
					resizeObserver.disconnect();
				};
			}
		}, [prefixCls]);
		let mergedProps = {
			...props,
			style: {
				...style,
				margin: 0
			},
			open,
			getPopupContainer: () => holderRef.current
		};
		{
			Object.assign(mergedProps, { ["popupAlign"]: { overflow: {
				adjustX: false,
				adjustY: false
			} } });
		}
		const mergedStyle = {
			paddingBottom: popupHeight,
			position: "relative",
			minWidth: popupWidth
		};
		return reactExports.createElement("div", {
			ref: holderRef,
			style: mergedStyle
		}, reactExports.createElement(Component, { ...mergedProps }));
	};
	return withPureRenderTheme(PurePanel);
};
function InternalItem(props, ref) {
	const { prefixCls, invalidate, item, renderItem, responsive, responsiveDisabled, registerSize, itemKey, className, style, children, display, order, component: Component = "div", ...restProps } = props;
	const mergedHidden = responsive && !display;
	// ================================ Effect ================================
	function internalRegisterSize(width) {
		registerSize(itemKey, width);
	}
	reactExports.useEffect(() => () => {
		internalRegisterSize(null);
	}, []);
	// ================================ Render ================================
	const childNode = renderItem && item !== void 0 ? renderItem(item, { index: order }) : children;
	let overflowStyle;
	if (!invalidate) {
		overflowStyle = {
			opacity: mergedHidden ? 0 : 1,
			height: mergedHidden ? 0 : void 0,
			overflowY: mergedHidden ? "hidden" : void 0,
			order: responsive ? order : void 0,
			pointerEvents: mergedHidden ? "none" : void 0,
			position: mergedHidden ? "absolute" : void 0
		};
	}
	const overflowProps = {};
	if (mergedHidden) {
		overflowProps["aria-hidden"] = true;
	}
	let itemNode = reactExports.createElement(Component, _extends$p({
		className: clsx(!invalidate && prefixCls, className),
		style: {
			...overflowStyle,
			...style
		}
	}, overflowProps, restProps, { ref }), childNode);
	if (responsive) {
		itemNode = reactExports.createElement(RefResizeObserver, {
			onResize: ({ offsetWidth }) => {
				internalRegisterSize(offsetWidth);
			},
			disabled: responsiveDisabled
		}, itemNode);
	}
	return itemNode;
}
const Item = reactExports.forwardRef(InternalItem);
function channelUpdate(callback) {
	if (typeof MessageChannel === "undefined") {
		wrapperRaf(callback);
	} else {
		const channel = new MessageChannel();
		channel.port1.onmessage = () => (callback(), void 0);
		channel.port2.postMessage(void 0);
	}
}
/**
* Batcher for record any `useEffectState` need update.
*/
function useBatcher() {
	// Updater Trigger
	const updateFuncRef = reactExports.useRef(null);
	// Notify update
	const notifyEffectUpdate = (callback) => {
		if (!updateFuncRef.current) {
			updateFuncRef.current = [];
			channelUpdate(() => {
				reactDomExports.k(() => {
					updateFuncRef.current.forEach((fn) => {
						fn();
					});
					updateFuncRef.current = null;
				});
			});
		}
		updateFuncRef.current.push(callback);
	};
	return notifyEffectUpdate;
}
/**
* Trigger state update by `useLayoutEffect` to save perf.
*/
function useEffectState(notifyEffectUpdate, defaultValue) {
	// Value
	const [stateValue, setStateValue] = reactExports.useState(defaultValue);
	// Set State
	const setEffectVal = useEvent((nextValue) => {
		notifyEffectUpdate(() => {
			setStateValue(nextValue);
		});
	});
	return [stateValue, setEffectVal];
}
const OverflowContext = React.createContext(null);
const InternalRawItem = (props, ref) => {
	const context = reactExports.useContext(OverflowContext);
	// Render directly when context not provided
	if (!context) {
		const { component: Component = "div", ...restProps } = props;
		return reactExports.createElement(Component, _extends$p({}, restProps, { ref }));
	}
	const { className: contextClassName, ...restContext } = context;
	const { className, ...restProps } = props;
	// Do not pass context to sub item to avoid multiple measure
	return reactExports.createElement(OverflowContext.Provider, { value: null }, reactExports.createElement(Item, _extends$p({
		ref,
		className: clsx(contextClassName, className)
	}, restContext, restProps)));
};
const RawItem = reactExports.forwardRef(InternalRawItem);
function defaultRenderRest(omittedItems) {
	return `+ ${omittedItems.length} ...`;
}
function Overflow(props, ref) {
	const { prefixCls = "rc-overflow", data = [], renderItem, renderRawItem, itemKey, itemWidth = 10, ssr, style, className, maxCount, renderRest, renderRawRest, prefix, suffix, component: Component = "div", itemComponent, onVisibleChange, ...restProps } = props;
	const fullySSR = ssr === "full";
	const notifyEffectUpdate = useBatcher();
	const [containerWidth, setContainerWidth] = useEffectState(notifyEffectUpdate, null);
	const mergedContainerWidth = containerWidth || 0;
	const [itemWidths, setItemWidths] = useEffectState(notifyEffectUpdate, new Map());
	const [prevRestWidth, setPrevRestWidth] = useEffectState(notifyEffectUpdate, 0);
	const [restWidth, setRestWidth] = useEffectState(notifyEffectUpdate, 0);
	const [prefixWidth, setPrefixWidth] = useEffectState(notifyEffectUpdate, 0);
	const [suffixWidth, setSuffixWidth] = useEffectState(notifyEffectUpdate, 0);
	const [suffixFixedStart, setSuffixFixedStart] = reactExports.useState(null);
	const [displayCount, setDisplayCount] = reactExports.useState(null);
	const mergedDisplayCount = reactExports.useMemo(() => {
		if (displayCount === null && fullySSR) {
			return Number.MAX_SAFE_INTEGER;
		}
		return displayCount || 0;
	}, [displayCount, containerWidth]);
	const [restReady, setRestReady] = reactExports.useState(false);
	const itemPrefixCls = `${prefixCls}-item`;
	// Always use the max width to avoid blink
	const mergedRestWidth = Math.max(prevRestWidth, restWidth);
	// ================================= Data =================================
	const isResponsive = maxCount === "responsive";
	const shouldResponsive = data.length && isResponsive;
	const invalidate = maxCount === "invalidate";
	/**
	* When is `responsive`, we will always render rest node to get the real width of it for calculation
	*/
	const showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
	const mergedData = reactExports.useMemo(() => {
		let items = data;
		if (shouldResponsive) {
			if (containerWidth === null && fullySSR) {
				items = data;
			} else {
				items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
			}
		} else if (typeof maxCount === "number") {
			items = data.slice(0, maxCount);
		}
		return items;
	}, [
		data,
		itemWidth,
		containerWidth,
		maxCount,
		shouldResponsive
	]);
	const omittedItems = reactExports.useMemo(() => {
		if (shouldResponsive) {
			return data.slice(mergedDisplayCount + 1);
		}
		return data.slice(mergedData.length);
	}, [
		data,
		mergedData,
		shouldResponsive,
		mergedDisplayCount
	]);
	// ================================= Item =================================
	const getKey = reactExports.useCallback((item, index) => {
		if (typeof itemKey === "function") {
			return itemKey(item);
		}
		return (itemKey && item?.[itemKey]) ?? index;
	}, [itemKey]);
	const mergedRenderItem = reactExports.useCallback(renderItem || ((item) => item), [renderItem]);
	function updateDisplayCount(count, suffixFixedStartVal, notReady) {
		// React 18 will sync render even when the value is same in some case.
		// We take `mergedData` as deps which may cause dead loop if it's dynamic generate.
		// ref: https://github.com/ant-design/ant-design/issues/36559
		if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
			return;
		}
		setDisplayCount(count);
		if (!notReady) {
			setRestReady(count < data.length - 1);
			onVisibleChange?.(count);
		}
		if (suffixFixedStartVal !== void 0) {
			setSuffixFixedStart(suffixFixedStartVal);
		}
	}
	// ================================= Size =================================
	function onOverflowResize(__unused_73F8, element) {
		setContainerWidth(element.clientWidth);
	}
	function registerSize(key, width) {
		setItemWidths((origin) => {
			const clone = new Map(origin);
			if (width === null) {
				clone.delete(key);
			} else {
				clone.set(key, width);
			}
			return clone;
		});
	}
	function registerOverflowSize(__unused_FB48, width) {
		setRestWidth(width);
		setPrevRestWidth(restWidth);
	}
	function registerPrefixSize(__unused_FB48_0, width) {
		setPrefixWidth(width);
	}
	function registerSuffixSize(__unused_FB48_1, width) {
		setSuffixWidth(width);
	}
	// ================================ Effect ================================
	function getItemWidth(index) {
		return itemWidths.get(getKey(mergedData[index], index));
	}
	useLayoutEffect(() => {
		if (mergedContainerWidth && true && mergedData) {
			let totalWidth = prefixWidth + suffixWidth;
			const len = mergedData.length;
			const lastIndex = len - 1;
			// When data count change to 0, reset this since not loop will reach
			if (!len) {
				updateDisplayCount(0, null);
				return;
			}
			for (let i = 0; i < len; i += 1) {
				let currentItemWidth = getItemWidth(i);
				// Fully will always render
				if (fullySSR) {
					currentItemWidth = currentItemWidth || 0;
				}
				// Break since data not ready
				if (currentItemWidth === void 0) {
					updateDisplayCount(i - 1, void 0, true);
					break;
				}
				// Find best match
				totalWidth += currentItemWidth;
				if (lastIndex === 0 && totalWidth <= mergedContainerWidth || i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
					// Additional check if match the end
					updateDisplayCount(lastIndex, null);
					break;
				} else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
					// Can not hold all the content to show rest
					updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
					break;
				}
			}
			if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
				setSuffixFixedStart(null);
			}
		}
	}, [
		mergedContainerWidth,
		itemWidths,
		restWidth,
		prefixWidth,
		suffixWidth,
		getKey,
		mergedData
	]);
	// ================================ Render ================================
	const displayRest = restReady && !!omittedItems.length;
	let suffixStyle = {};
	if (suffixFixedStart !== null && shouldResponsive) {
		suffixStyle = {
			position: "absolute",
			left: suffixFixedStart,
			top: 0
		};
	}
	const itemSharedProps = {
		prefixCls: itemPrefixCls,
		responsive: shouldResponsive,
		component: itemComponent,
		invalidate
	};
	// >>>>> Choice render fun by `renderRawItem`
	const internalRenderItemNode = renderRawItem ? (item, index) => {
		const key = getKey(item, index);
		return reactExports.createElement(OverflowContext.Provider, {
			key,
			value: {
				...itemSharedProps,
				order: index,
				item,
				itemKey: key,
				registerSize,
				display: index <= mergedDisplayCount
			}
		}, renderRawItem(item, index));
	} : (item, index) => {
		const key = getKey(item, index);
		return reactExports.createElement(Item, _extends$p({}, itemSharedProps, {
			order: index,
			key,
			item,
			renderItem: mergedRenderItem,
			itemKey: key,
			registerSize,
			display: index <= mergedDisplayCount
		}));
	};
	// >>>>> Rest node
	const restContextProps = {
		order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
		className: `${itemPrefixCls}-rest`,
		registerSize: registerOverflowSize,
		display: displayRest
	};
	const mergedRenderRest = renderRest || defaultRenderRest;
	const restNode = renderRawRest ? reactExports.createElement(OverflowContext.Provider, { value: {
		...itemSharedProps,
		...restContextProps
	} }, renderRawRest(omittedItems)) : reactExports.createElement(Item, _extends$p({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
	const overflowNode = reactExports.createElement(Component, _extends$p({
		className: clsx(!invalidate && prefixCls, className),
		style,
		ref
	}, restProps), prefix && reactExports.createElement(Item, _extends$p({}, itemSharedProps, {
		responsive: isResponsive,
		responsiveDisabled: !shouldResponsive,
		order: -1,
		className: `${itemPrefixCls}-prefix`,
		registerSize: registerPrefixSize,
		display: true
	}), prefix), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && reactExports.createElement(Item, _extends$p({}, itemSharedProps, {
		responsive: isResponsive,
		responsiveDisabled: !shouldResponsive,
		order: mergedDisplayCount,
		className: `${itemPrefixCls}-suffix`,
		registerSize: registerSuffixSize,
		display: true,
		style: suffixStyle
	}), suffix));
	return isResponsive ? reactExports.createElement(RefResizeObserver, {
		onResize: onOverflowResize,
		disabled: !shouldResponsive
	}, overflowNode) : overflowNode;
}
const ForwardOverflow = reactExports.forwardRef(Overflow);
ForwardOverflow.Item = RawItem;
ForwardOverflow.RESPONSIVE = "responsive";
ForwardOverflow.INVALIDATE = "invalidate";
const getStatusClassNames = (prefixCls, status, hasFeedback) => {
	return clsx({
		[`${prefixCls}-status-success`]: status === "success",
		[`${prefixCls}-status-warning`]: status === "warning",
		[`${prefixCls}-status-error`]: status === "error",
		[`${prefixCls}-status-validating`]: status === "validating",
		[`${prefixCls}-has-feedback`]: hasFeedback
	});
};
const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
/**
* Compatible for legacy `bordered` prop.
*/
const useVariant = (component, variant, legacyBordered) => {
	const { variant: configVariant, [component]: componentConfig } = reactExports.useContext(ConfigContext);
	const ctxVariant = reactExports.useContext(VariantContext);
	const configComponentVariant = componentConfig?.variant;
	let mergedVariant;
	if (typeof variant !== "undefined") {
		mergedVariant = variant;
	} else if (legacyBordered === false) {
		mergedVariant = "borderless";
	} else {
		// form variant > component global variant > global variant
		mergedVariant = ctxVariant ?? configComponentVariant ?? configVariant ?? "outlined";
	}
	const enableVariantCls = Variants.includes(mergedVariant);
	return [mergedVariant, enableVariantCls];
};
// This icon file is generated automatically.
var CheckOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" }
		}]
	},
	"name": "check",
	"theme": "outlined"
};
var CheckOutlinedSvg = CheckOutlined$1;
function _extends$m() {
	_extends$m = Object.assign.bind();
	return _extends$m.apply(this, arguments);
}
const CheckOutlined = (props, ref) => reactExports.createElement(Icon$1, _extends$m({}, props, {
	ref,
	icon: CheckOutlinedSvg
}));
/**![check](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkxMiAxOTBoLTY5LjljLTkuOCAwLTE5LjEgNC41LTI1LjEgMTIuMkw0MDQuNyA3MjQuNSAyMDcgNDc0YTMyIDMyIDAgMDAtMjUuMS0xMi4ySDExMmMtNi43IDAtMTAuNCA3LjctNi4zIDEyLjlsMjczLjkgMzQ3YzEyLjggMTYuMiAzNy40IDE2LjIgNTAuMyAwbDQ4OC40LTYxOC45YzQuMS01LjEuNC0xMi44LTYuMy0xMi44eiIgLz48L3N2Zz4=) */
const RefIcon$5 = reactExports.forwardRef(CheckOutlined);
// This icon file is generated automatically.
var DownOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" }
		}]
	},
	"name": "down",
	"theme": "outlined"
};
var DownOutlinedSvg = DownOutlined$1;
function _extends$l() {
	_extends$l = Object.assign.bind();
	return _extends$l.apply(this, arguments);
}
const DownOutlined = (props, ref) => reactExports.createElement(Icon$1, _extends$l({}, props, {
	ref,
	icon: DownOutlinedSvg
}));
/**![down](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg4NCAyNTZoLTc1Yy01LjEgMC05LjkgMi41LTEyLjkgNi42TDUxMiA2NTQuMiAyMjcuOSAyNjIuNmMtMy00LjEtNy44LTYuNi0xMi45LTYuNmgtNzVjLTYuNSAwLTEwLjMgNy40LTYuNSAxMi43bDM1Mi42IDQ4Ni4xYzEyLjggMTcuNiAzOSAxNy42IDUxLjcgMGwzNTIuNi00ODYuMWMzLjktNS4zLjEtMTIuNy02LjQtMTIuN3oiIC8+PC9zdmc+) */
const __unused_7EDC = reactExports.forwardRef(DownOutlined);
// This icon file is generated automatically.
var SearchOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" }
		}]
	},
	"name": "search",
	"theme": "outlined"
};
var SearchOutlinedSvg = SearchOutlined$1;
function _extends$k() {
	_extends$k = Object.assign.bind();
	return _extends$k.apply(this, arguments);
}
const SearchOutlined = (props, ref) => reactExports.createElement(Icon$1, _extends$k({}, props, {
	ref,
	icon: SearchOutlinedSvg
}));
/**![search](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkwOS42IDg1NC41TDY0OS45IDU5NC44QzY5MC4yIDU0Mi43IDcxMiA0NzkgNzEyIDQxMmMwLTgwLjItMzEuMy0xNTUuNC04Ny45LTIxMi4xLTU2LjYtNTYuNy0xMzItODcuOS0yMTIuMS04Ny45cy0xNTUuNSAzMS4zLTIxMi4xIDg3LjlDMTQzLjIgMjU2LjUgMTEyIDMzMS44IDExMiA0MTJjMCA4MC4xIDMxLjMgMTU1LjUgODcuOSAyMTIuMUMyNTYuNSA2ODAuOCAzMzEuOCA3MTIgNDEyIDcxMmM2NyAwIDEzMC42LTIxLjggMTgyLjctNjJsMjU5LjcgMjU5LjZhOC4yIDguMiAwIDAwMTEuNiAwbDQzLjYtNDMuNWE4LjIgOC4yIDAgMDAwLTExLjZ6TTU3MC40IDU3MC40QzUyOCA2MTIuNyA0NzEuOCA2MzYgNDEyIDYzNnMtMTE2LTIzLjMtMTU4LjQtNjUuNkMyMTEuMyA1MjggMTg4IDQ3MS44IDE4OCA0MTJzMjMuMy0xMTYuMSA2NS42LTE1OC40QzI5NiAyMTEuMyAzNTIuMiAxODggNDEyIDE4OHMxMTYuMSAyMy4yIDE1OC40IDY1LjZTNjM2IDM1Mi4yIDYzNiA0MTJzLTIzLjMgMTE2LjEtNjUuNiAxNTguNHoiIC8+PC9zdmc+) */
const __unused_E73C = reactExports.forwardRef(SearchOutlined);
function useIcons$1({ suffixIcon, clearIcon, menuItemSelectedIcon, removeIcon, loading, multiple, hasFeedback, showSuffixIcon, feedbackIcon, showArrow }) {
	// Clear Icon
	const mergedClearIcon = clearIcon ?? reactExports.createElement(RefIcon$8, null);
	// Validation Feedback Icon
	const getSuffixIconNode = (arrowIcon) => {
		if (suffixIcon === null && !hasFeedback && !showArrow) {
			return;
		}
		return reactExports.createElement(reactExports.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
	};
	if (suffixIcon !== void 0) {
		getSuffixIconNode(suffixIcon);
	} else if (loading) {
		getSuffixIconNode(reactExports.createElement(RefIcon$6, { spin: true }));
	}
	if (!(menuItemSelectedIcon !== void 0)) {
		if (multiple) {
			reactExports.createElement(RefIcon$5, null);
		}
	}
	let mergedRemoveIcon = null;
	if (removeIcon !== void 0) {
		mergedRemoveIcon = removeIcon;
	} else {
		mergedRemoveIcon = reactExports.createElement(RefIcon$7, null);
	}
	return {
		a: mergedClearIcon,
		b: mergedRemoveIcon
	};
}
function getArrowToken(token) {
	const { sizePopupArrow, borderRadiusXS, borderRadiusOuter } = token;
	const unitWidth = sizePopupArrow / 2;
	const ay = unitWidth;
	const bx = borderRadiusOuter * 1 / Math.sqrt(2);
	const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
	const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
	const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
	const dx = 2 * unitWidth - cx;
	const dy = cy;
	const ex = 2 * unitWidth - bx;
	const ey = by;
	const fx = 2 * unitWidth - 0;
	const fy = ay;
	const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
	const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
	const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
	const arrowPath = `path('M ${0} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
	return {
		arrowShadowWidth: shadowWidth,
		arrowPath,
		arrowPolygon
	};
}
const genRoundedArrow = (token, bgColor, boxShadow) => {
	const { sizePopupArrow, arrowPolygon, arrowPath, arrowShadowWidth, borderRadiusXS, calc } = token;
	return {
		pointerEvents: "none",
		width: sizePopupArrow,
		height: sizePopupArrow,
		overflow: "hidden",
		"&::before": {
			position: "absolute",
			bottom: 0,
			insetInlineStart: 0,
			width: sizePopupArrow,
			height: calc(sizePopupArrow).div(2).equal(),
			background: bgColor,
			clipPath: {
				_multi_value_: true,
				value: [arrowPolygon, arrowPath]
			},
			content: "\"\""
		},
		"&::after": {
			content: "\"\"",
			position: "absolute",
			width: arrowShadowWidth,
			height: arrowShadowWidth,
			bottom: 0,
			insetInline: 0,
			margin: "auto",
			borderRadius: {
				_skip_check_: true,
				value: `0 0 ${unit$1(borderRadiusXS)} 0`
			},
			transform: "translateY(50%) rotate(-135deg)",
			boxShadow,
			zIndex: 0,
			background: "transparent"
		}
	};
};
var dayjs_min$1 = {};
function requireDayjs_min() {
	(function(module) {
		(function(__unused_F8B0, e) {
			module.a = e();
		})(0, function() {
			var n = 36e5, $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
				name: "en",
				weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
				months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
				ordinal: function(t) {
					var e = [
						"th",
						"st",
						"nd",
						"rd"
					], n = t % 100;
					return "[" + t + (e[(n - 20) % 10] || e[n] || "th") + "]";
				}
			}, m = function(t, e, n) {
				var r = String(t);
				return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
			}, v = {
				s: m,
				z: function(t) {
					var e = -t.utcOffset(), n = Math.abs(e), r = Math.floor(n / 60), i = n % 60;
					return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
				},
				m: function t(e, n) {
					if (e.date() < n.date()) return -t(n, e);
					var r = 12 * (n.year() - e.year()) + (n.month() - e.month()), i = e.clone().add(r, "month"), s = n - i < 0, u = e.clone().add(r + (s ? -1 : 1), "month");
					return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
				},
				a: function(t) {
					return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
				},
				p: function(t) {
					return {
						M: "month",
						y: "year",
						w: "week",
						d: "day",
						D: "date",
						h: "hour",
						m: "minute",
						s: "second",
						ms: "millisecond",
						Q: "quarter"
					}[t] || String(t || "").toLowerCase().replace(/s$/, "");
				},
				u: function(t) {
					return void 0 === t;
				}
			}, g = "en", D = {};
			D["en"] = M;
			var p = "$isDayjsObject", S = function(t) {
				return t instanceof _ || !(!t || !t[p]);
			}, w = function t(e, n, r) {
				var i;
				if (!e) return g;
				if ("string" == typeof e) {
					var s = e.toLowerCase();
					D[s] && (i = s), n && (D[s] = n, i = s);
					var u = e.split("-");
					if (!i && u.length > 1) return t(u[0]);
				} else {
					var a = e.name;
					D[a] = e, i = a;
				}
				return !r && i && (g = i), i || !r && g;
			}, O = function(t, e) {
				if (S(t)) return t.clone();
				var n = "object" == typeof e ? e : {};
				return n.date = t, n.args = arguments, new _(n);
			}, b = v;
			b.l = w, b.i = S, b.w = function(t, e) {
				return O(t, {
					locale: e.$L,
					utc: e.$u,
					x: e.$x,
					$offset: e.$offset
				});
			};
			var _ = function() {
				function M(t) {
					this.$L = w(t.locale, null, true), this.parse(t), this.$x = this.$x || t.x || {}, this[p] = true;
				}
				var m = M.prototype;
				return m.parse = function(t) {
					this.$d = function(t) {
						var e = t.date, n = t.utc;
						if (null === e) return new Date(NaN);
						if (b.u(e)) return new Date();
						if (e instanceof Date) return new Date(e);
						if ("string" == typeof e && !/Z$/i.test(e)) {
							var r = e.match($);
							if (r) {
								var i = r[2] - 1 || 0, s = (r[7] || "0").substring(0, 3);
								return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
							}
						}
						return new Date(e);
					}(t), this.init();
				}, m.init = function() {
					var t = this.$d;
					this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
				}, m.$utils = function() {
					return b;
				}, m.isValid = function() {
					return !(this.$d.toString() === "Invalid Date");
				}, m.isSame = function(t, e) {
					var n = O(t);
					return this.startOf(e) <= n && n <= this.endOf(e);
				}, m.isAfter = function(t, e) {
					return O(t) < this.startOf(e);
				}, m.isBefore = function(t, e) {
					return this.endOf(e) < O(t);
				}, m.$g = function(t, e, n) {
					return b.u(t) ? this[e] : this.set(n, t);
				}, m.unix = function() {
					return Math.floor(this.valueOf() / 1e3);
				}, m.valueOf = function() {
					return this.$d.getTime();
				}, m.startOf = function(t, e) {
					var n = this, r = !!b.u(e) || e, f = b.p(t), l = function(t, e) {
						var i = b.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
						return r ? i : i.endOf("day");
					}, $ = function(t, e) {
						return b.w(n.toDate()[t].apply(n.toDate("s"), (r ? [
							0,
							0,
							0,
							0
						] : [
							23,
							59,
							59,
							999
						]).slice(e)), n);
					}, y = this.$W, M = this.$M, m = this.$D, v = "set" + (this.$u ? "UTC" : "");
					switch (f) {
						case "year": return r ? l(1, 0) : l(31, 11);
						case "month": return r ? l(1, M) : l(0, M + 1);
						case "week":
							var g = this.$locale().weekStart || 0, D = (y < g ? y + 7 : y) - g;
							return l(r ? m - D : m + (6 - D), M);
						case "day":
						case "date": return $(v + "Hours", 0);
						case "hour": return $(v + "Minutes", 1);
						case "minute": return $(v + "Seconds", 2);
						case "second": return $(v + "Milliseconds", 3);
						default: return this.clone();
					}
				}, m.endOf = function(t) {
					return this.startOf(t, false);
				}, m.$set = function(t, e) {
					var n, o = b.p(t), f = "set" + (this.$u ? "UTC" : ""), l = (n = {}, n["day"] = f + "Date", n["date"] = f + "Date", n["month"] = f + "Month", n["year"] = f + "FullYear", n["hour"] = f + "Hours", n["minute"] = f + "Minutes", n["second"] = f + "Seconds", n["millisecond"] = f + "Milliseconds", n)[o], $ = o === "day" ? this.$D + (e - this.$W) : e;
					if (o === "month" || o === "year") {
						var y = this.clone().set("date", 1);
						y.$d[l]($), y.init(), this.$d = y.set("date", Math.min(this.$D, y.daysInMonth())).$d;
					} else l && this.$d[l]($);
					return this.init(), this;
				}, m.set = function(t, e) {
					return this.clone().$set(t, e);
				}, m.get = function(t) {
					return this[b.p(t)]();
				}, m.add = function(r, f) {
					var d, l = this;
					r = Number(r);
					var $ = b.p(f), y = function(t) {
						var e = O(l);
						return b.w(e.date(e.date() + Math.round(t * r)), l);
					};
					if ($ === "month") return this.set("month", this.$M + r);
					if ($ === "year") return this.set("year", this.$y + r);
					if ($ === "day") return y(1);
					if ($ === "week") return y(7);
					var M = (d = {}, d["minute"] = 6e4, d["hour"] = n, d["second"] = 1e3, d)[$] || 1, m = this.$d.getTime() + r * M;
					return b.w(m, this);
				}, m.subtract = function(t, e) {
					return this.add(-1 * t, e);
				}, m.format = function(t) {
					var e = this, n = this.$locale();
					if (!this.isValid()) return n.invalidDate || "Invalid Date";
					var r = t || "YYYY-MM-DDTHH:mm:ssZ", i = b.z(this), s = this.$H, u = this.$m, a = this.$M, o = n.weekdays, c = n.months, f = n.meridiem, h = function(t, n, i, s) {
						return t && (t[n] || t(e, r)) || i[n].slice(0, s);
					}, d = function(t) {
						return b.s(s % 12 || 12, t, "0");
					}, $ = f || function(t, __unused_9722, n) {
						var r = t < 12 ? "AM" : "PM";
						return n ? r.toLowerCase() : r;
					};
					return r.replace(y, function(t, r) {
						return r || function(t) {
							switch (t) {
								case "YY": return String(e.$y).slice(-2);
								case "YYYY": return b.s(e.$y, 4, "0");
								case "M": return a + 1;
								case "MM": return b.s(a + 1, 2, "0");
								case "MMM": return h(n.monthsShort, a, c, 3);
								case "MMMM": return h(c, a);
								case "D": return e.$D;
								case "DD": return b.s(e.$D, 2, "0");
								case "d": return String(e.$W);
								case "dd": return h(n.weekdaysMin, e.$W, o, 2);
								case "ddd": return h(n.weekdaysShort, e.$W, o, 3);
								case "dddd": return o[e.$W];
								case "H": return String(s);
								case "HH": return b.s(s, 2, "0");
								case "h": return d(1);
								case "hh": return d(2);
								case "a": return $(s, u, true);
								case "A": return $(s, u, false);
								case "m": return String(u);
								case "mm": return b.s(u, 2, "0");
								case "s": return String(e.$s);
								case "ss": return b.s(e.$s, 2, "0");
								case "SSS": return b.s(e.$ms, 3, "0");
								case "Z": return i;
							}
							return null;
						}(t) || i.replace(":", "");
					});
				}, m.utcOffset = function() {
					return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
				}, m.diff = function(r, d, l) {
					var $, y = this, M = b.p(d), m = O(r), v = (m.utcOffset() - this.utcOffset()) * 6e4, g = this - m, D = function() {
						return b.m(y, m);
					};
					switch (M) {
						case "year":
							$ = D() / 12;
							break;
						case "month":
							$ = D();
							break;
						case "quarter":
							$ = D() / 3;
							break;
						case "week":
							$ = (g - v) / 6048e5;
							break;
						case "day":
							$ = (g - v) / 864e5;
							break;
						case "hour":
							$ = g / n;
							break;
						case "minute":
							$ = g / 6e4;
							break;
						case "second":
							$ = g / 1e3;
							break;
						default: $ = g;
					}
					return l ? $ : b.a($);
				}, m.daysInMonth = function() {
					return this.endOf("month").$D;
				}, m.$locale = function() {
					return D[this.$L];
				}, m.locale = function(t, e) {
					if (!t) return this.$L;
					var n = this.clone(), r = w(t, e, true);
					return r && (n.$L = r), n;
				}, m.clone = function() {
					return b.w(this.$d, this);
				}, m.toDate = function() {
					return new Date(this.valueOf());
				}, m.toJSON = function() {
					return this.isValid() ? this.toISOString() : null;
				}, m.toISOString = function() {
					return this.$d.toISOString();
				}, m.toString = function() {
					return this.$d.toUTCString();
				}, M;
			}(), k = _.prototype;
			return [
				["$ms", "millisecond"],
				["$s", "second"],
				["$m", "minute"],
				["$H", "hour"],
				["$W", "day"],
				["$M", "month"],
				["$y", "year"],
				["$D", "date"]
			].forEach(function(t) {
				k[t[1]] = function(e) {
					return this.$g(e, t[0], t[1]);
				};
			}), O.extend = function(t) {
				return t(0, _, O);
			}, O.Ls = D, O;
		});
	})(dayjs_min$1);
	return dayjs_min$1.a;
}
var dayjs_minExports = requireDayjs_min();
var dayjs = getDefaultExportFromCjs(dayjs_minExports);
var weekday$2 = {};
function requireWeekday() {
	(function(module) {
		(function(__unused_1D3C, t) {
			module.a = t();
		})(0, function() {
			return function(__unused_B5F1, t) {
				t.prototype.weekday = function(e) {
					var t = this.$locale().weekStart || 0, i = this.$W, n = (i < t ? i + 7 : i) - t;
					return this.$utils().u(e) ? n : this.subtract(n, "day").add(e, "day");
				};
			};
		});
	})(weekday$2);
	return weekday$2.a;
}
var weekdayExports = requireWeekday();
var weekday = getDefaultExportFromCjs(weekdayExports);
var localeData$2 = {};
function requireLocaleData() {
	(function(module) {
		(function(__unused_DF76, e) {
			module.a = e();
		})(0, function() {
			return function(__unused_C219, e) {
				var r = e.prototype, o = function(n) {
					return n && (n.indexOf ? n : n.s);
				}, u = function(n, e, t, r) {
					var i = n.name ? n : n.$locale(), a = o(i[e]), s = o(i[t]), f = a || s.map(function(n) {
						return n.slice(0, r);
					});
					{
						return f;
					}
				}, a = function(n, e) {
					return n.formats[e] || function(n) {
						return n.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(__unused_C219_0, e, t) {
							return e || t.slice(1);
						});
					}(n.formats[e.toUpperCase()]);
				}, s = function() {
					var n = this;
					return {
						months: function(e) {
							return e ? e.format("MMMM") : u(n, "months");
						},
						monthsShort: function(e) {
							return e ? e.format("MMM") : u(n, "monthsShort", "months", 3);
						},
						firstDayOfWeek: function() {
							return n.$locale().weekStart || 0;
						},
						weekdays: function(e) {
							return e ? e.format("dddd") : u(n, "weekdays");
						},
						weekdaysMin: function(e) {
							return e ? e.format("dd") : u(n, "weekdaysMin", "weekdays", 2);
						},
						weekdaysShort: function(e) {
							return e ? e.format("ddd") : u(n, "weekdaysShort", "weekdays", 3);
						},
						longDateFormat: function(e) {
							return a(n.$locale(), e);
						},
						meridiem: this.$locale().meridiem,
						ordinal: this.$locale().ordinal
					};
				};
				r.localeData = function() {
					return s.bind(this)();
				};
			};
		});
	})(localeData$2);
	return localeData$2.a;
}
var localeDataExports = requireLocaleData();
var localeData = getDefaultExportFromCjs(localeDataExports);
var weekOfYear$2 = {};
function requireWeekOfYear() {
	(function(module) {
		(function(__unused_1D3C_0, t) {
			module.a = t();
		})(0, function() {
			return function(__unused_CC67, n, r) {
				var f = n.prototype;
				f.week = function(i) {
					if (void 0 === i && (i = null), null !== i) return this.add(7 * (i - this.week()), "day");
					var n = this.$locale().yearStart || 1;
					if (11 === this.month() && this.date() > 25) {
						var f = r(this).startOf("year").add(1, "year").date(n), s = r(this).endOf("week");
						if (f.isBefore(s)) return 1;
					}
					var a = r(this).startOf("year").date(n).startOf("week").subtract(1, "millisecond"), o = this.diff(a, "week", true);
					return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
				}, f.weeks = function(e) {
					return void 0 === e && (e = null), this.week(e);
				};
			};
		});
	})(weekOfYear$2);
	return weekOfYear$2.a;
}
var weekOfYearExports = requireWeekOfYear();
var weekOfYear = getDefaultExportFromCjs(weekOfYearExports);
var weekYear$2 = {};
function requireWeekYear() {
	(function(module) {
		(function(__unused_1D3C_1, t) {
			module.a = t();
		})(0, function() {
			return function(__unused_B5F1_0, t) {
				t.prototype.weekYear = function() {
					var e = this.month(), t = this.week(), n = this.year();
					return 1 === t && 11 === e ? n + 1 : 0 === e && t >= 52 ? n - 1 : n;
				};
			};
		});
	})(weekYear$2);
	return weekYear$2.a;
}
var weekYearExports = requireWeekYear();
var weekYear = getDefaultExportFromCjs(weekYearExports);
var advancedFormat$2 = {};
function requireAdvancedFormat() {
	(function(module) {
		(function(__unused_1D3C_2, t) {
			module.a = t();
		})(0, function() {
			return function(__unused_03F7, t) {
				var r = t.prototype, n = r.format;
				r.format = function(e) {
					var t = this, r = this.$locale();
					if (!this.isValid()) return n.bind(this)(e);
					var s = this.$utils(), a = (e || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e) {
						switch (e) {
							case "Q": return Math.ceil((t.$M + 1) / 3);
							case "Do": return r.ordinal(t.$D);
							case "gggg": return t.weekYear();
							case "GGGG": return t.isoWeekYear();
							case "wo": return r.ordinal(t.week(), "W");
							case "w":
							case "ww": return s.s(t.week(), "w" === e ? 1 : 2, "0");
							case "W":
							case "WW": return s.s(t.isoWeek(), "W" === e ? 1 : 2, "0");
							case "k":
							case "kk": return s.s(String(0 === t.$H ? 24 : t.$H), "k" === e ? 1 : 2, "0");
							case "X": return Math.floor(t.$d.getTime() / 1e3);
							case "x": return t.$d.getTime();
							case "z": return "[" + t.offsetName() + "]";
							case "zzz": return "[" + t.offsetName("long") + "]";
							default: return e;
						}
					});
					return n.bind(this)(a);
				};
			};
		});
	})(advancedFormat$2);
	return advancedFormat$2.a;
}
var advancedFormatExports = requireAdvancedFormat();
var advancedFormat = getDefaultExportFromCjs(advancedFormatExports);
var customParseFormat$2 = {};
function requireCustomParseFormat() {
	(function(module) {
		(function(__unused_1D3C_3, t) {
			module.a = t();
		})(0, function() {
			var e = {
				LTS: "h:mm:ss A",
				LT: "h:mm A",
				L: "MM/DD/YYYY",
				LL: "MMMM D, YYYY",
				LLL: "MMMM D, YYYY h:mm A",
				LLLL: "dddd, MMMM D, YYYY h:mm A"
			}, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e) {
				return (e = +e) + (e > 68 ? 1900 : 2e3);
			};
			var f = function(e) {
				return function(t) {
					this[e] = +t;
				};
			}, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e) {
				(this.zone || (this.zone = {})).offset = function(e) {
					if (!e) return 0;
					if ("Z" === e) return 0;
					var t = e.match(/([+-]|\d\d)/g), n = 60 * t[1] + (+t[2] || 0);
					return 0 === n ? 0 : "+" === t[0] ? -n : n;
				}(e);
			}], u = function(e) {
				var t = s[e];
				return t && (t.indexOf ? t : t.s.concat(t.f));
			}, d = function(e, t) {
				var n, r = s.meridiem;
				if (r) {
					for (var i = 1; i <= 24; i += 1) if (e.indexOf(r(i, 0, t)) > -1) {
						n = i > 12;
						break;
					}
				} else n = e === (t ? "pm" : "PM");
				return n;
			}, c = {
				A: [o, function(e) {
					this.afternoon = d(e, false);
				}],
				a: [o, function(e) {
					this.afternoon = d(e, true);
				}],
				Q: [n, function(e) {
					this.month = 3 * (e - 1) + 1;
				}],
				S: [n, function(e) {
					this.milliseconds = 100 * +e;
				}],
				SS: [r, function(e) {
					this.milliseconds = 10 * +e;
				}],
				SSS: [/\d{3}/, function(e) {
					this.milliseconds = +e;
				}],
				s: [i, f("seconds")],
				ss: [i, f("seconds")],
				m: [i, f("minutes")],
				mm: [i, f("minutes")],
				H: [i, f("hours")],
				h: [i, f("hours")],
				HH: [i, f("hours")],
				hh: [i, f("hours")],
				D: [i, f("day")],
				DD: [r, f("day")],
				Do: [o, function(e) {
					var t = s.ordinal, n = e.match(/\d+/);
					if (this.day = n[0], t) for (var r = 1; r <= 31; r += 1) t(r).replace(/\[|\]/g, "") === e && (this.day = r);
				}],
				w: [i, f("week")],
				ww: [r, f("week")],
				M: [i, f("month")],
				MM: [r, f("month")],
				MMM: [o, function(e) {
					var t = u("months"), n = (u("monthsShort") || t.map(function(e) {
						return e.slice(0, 3);
					})).indexOf(e) + 1;
					if (n < 1) throw new Error();
					this.month = n % 12 || n;
				}],
				MMMM: [o, function(e) {
					var t = u("months").indexOf(e) + 1;
					if (t < 1) throw new Error();
					this.month = t % 12 || t;
				}],
				Y: [/[+-]?\d+/, f("year")],
				YY: [r, function(e) {
					this.year = a(e);
				}],
				YYYY: [/\d{4}/, f("year")],
				Z: h,
				ZZ: h
			};
			function l(n) {
				var r, i;
				r = n, i = s && s.formats;
				for (var o = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(__unused_4BE4, n, r) {
					var o = r && r.toUpperCase();
					return n || i[r] || e[r] || i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(__unused_17A1, t, n) {
						return t || n.slice(1);
					});
				}).match(t), a = o.length, f = 0; f < a; f += 1) {
					var h = o[f], u = c[h], d = u && u[0], l = u && u[1];
					o[f] = l ? {
						regex: d,
						parser: l
					} : h.replace(/^\[|\]$/g, "");
				}
				return function(e) {
					for (var t = {}, n = 0, r = 0; n < a; n += 1) {
						var i = o[n];
						if ("string" == typeof i) r += i.length;
						else {
							var s = i.regex, f = i.parser, h = e.slice(r), u = s.exec(h)[0];
							f.call(t, u), e = e.replace(u, "");
						}
					}
					return function(e) {
						var t = e.afternoon;
						if (void 0 !== t) {
							var n = e.hours;
							t ? n < 12 && (e.hours += 12) : 12 === n && (e.hours = 0), delete e.afternoon;
						}
					}(t), t;
				};
			}
			return function(__unused_17A1_0, t, n) {
				var r = t.prototype, i = r.parse;
				r.parse = function(e) {
					var t = e.date, r = e.utc, o = e.args;
					this.$u = r;
					var a = o[1];
					if ("string" == typeof a) {
						var f = true === o[2], h = true === o[3], u = f || h, d = o[2];
						h && (d = o[2]), s = this.$locale(), !f && d && (s = n.Ls[d]), this.$d = function(e, t, n, r) {
							try {
								if (["x", "X"].indexOf(t) > -1) return new Date(("X" === t ? 1e3 : 1) * e);
								var i = l(t)(e), o = i.year, s = i.month, a = i.day, f = i.hours, h = i.minutes, u = i.seconds, d = i.milliseconds, c = i.zone, m = i.week, M = new Date(), Y = a || (o || s ? 1 : M.getDate()), p = o || M.getFullYear(), v = 0;
								o && !s || (v = s > 0 ? s - 1 : M.getMonth());
								var D, w = f || 0, g = h || 0, y = u || 0, L = d || 0;
								return c ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c.offset * 1e3)) : n ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m && (D = r(D).week(m).toDate()), D);
							} catch {
								return new Date("");
							}
						}(t, a, r, n), this.init(), d && true !== d && (this.$L = this.locale(d).$L), u && t != this.format(a) && (this.$d = new Date("")), s = {};
					} else if (a instanceof Array) for (var c = a.length, m = 1; m <= c; m += 1) {
						o[1] = a[m - 1];
						var M = n.apply(0, o);
						if (M.isValid()) {
							this.$d = M.$d, this.$L = M.$L, this.init();
							break;
						}
						m === c && (this.$d = new Date(""));
					}
					else i.call(this, e);
				};
			};
		});
	})(customParseFormat$2);
	return customParseFormat$2.a;
}
var customParseFormatExports = requireCustomParseFormat();
var customParseFormat = getDefaultExportFromCjs(customParseFormatExports);
dayjs.extend(customParseFormat);
dayjs.extend(advancedFormat);
dayjs.extend(weekday);
dayjs.extend(localeData);
dayjs.extend(weekOfYear);
dayjs.extend(weekYear);
dayjs.extend(function(__unused_325D, c) {
	// todo support Wo (ISO week)
	var proto = c.prototype;
	var oldFormat = proto.format;
	proto.format = function(formatStr) {
		var str = (formatStr || "").replace("Wo", "wo");
		return oldFormat.bind(this)(str);
	};
});
var localeMap = {
	bn_BD: "bn-bd",
	by_BY: "be",
	en_GB: "en-gb",
	en_US: "en",
	fr_BE: "fr",
	fr_CA: "fr-ca",
	hy_AM: "hy-am",
	kmr_IQ: "ku",
	nl_BE: "nl-be",
	pt_BR: "pt-br",
	zh_CN: "zh-cn",
	zh_HK: "zh-hk",
	zh_TW: "zh-tw"
};
var parseLocale = function(locale) {
	var mapLocale = localeMap[locale];
	return mapLocale || locale.split("_")[0];
};
var generateConfig = {
	getNow: function() {
		var now = dayjs();
		// https://github.com/ant-design/ant-design/discussions/50934
		if (typeof now.tz === "function") {
			return now.tz();
		}
		return now;
	},
	getFixedDate: function(string) {
		return dayjs(string, ["YYYY-M-DD", "YYYY-MM-DD"]);
	},
	getEndDate: function(date) {
		return date.endOf("month");
	},
	getWeekDay: function(date) {
		var clone = date.locale("en");
		return clone.weekday() + clone.localeData().firstDayOfWeek();
	},
	getYear: function(date) {
		return date.year();
	},
	getMonth: function(date) {
		return date.month();
	},
	getDate: function(date) {
		return date.date();
	},
	getHour: function(date) {
		return date.hour();
	},
	getMinute: function(date) {
		return date.minute();
	},
	getSecond: function(date) {
		return date.second();
	},
	getMillisecond: function(date) {
		return date.millisecond();
	},
	addYear: function(date, diff) {
		return date.add(diff, "year");
	},
	addMonth: function(date, diff) {
		return date.add(diff, "month");
	},
	addDate: function(date, diff) {
		return date.add(diff, "day");
	},
	setYear: function(date, year) {
		return date.year(year);
	},
	setMonth: function(date, month) {
		return date.month(month);
	},
	setDate: function(date, num) {
		return date.date(num);
	},
	setHour: function(date, hour) {
		return date.hour(hour);
	},
	setMinute: function(date, minute) {
		return date.minute(minute);
	},
	setSecond: function(date, second) {
		return date.second(second);
	},
	setMillisecond: function(date, milliseconds) {
		return date.millisecond(milliseconds);
	},
	isAfter: function(date1, date2) {
		return date1.isAfter(date2);
	},
	isValidate: function(date) {
		return date.isValid();
	},
	locale: {
		getWeekFirstDay: function(locale) {
			return dayjs().locale(parseLocale(locale)).localeData().firstDayOfWeek();
		},
		getWeekFirstDate: function(locale, date) {
			return date.locale(parseLocale(locale)).weekday(0);
		},
		getWeek: function(locale, date) {
			return date.locale(parseLocale(locale)).week();
		},
		getShortWeekDays: function(locale) {
			return dayjs().locale(parseLocale(locale)).localeData().weekdaysMin();
		},
		getShortMonths: function(locale) {
			return dayjs().locale(parseLocale(locale)).localeData().monthsShort();
		},
		format: function(locale, date, _format) {
			return date.locale(parseLocale(locale)).format(_format);
		},
		parse: function(locale, text, formats) {
			var localeStr = parseLocale(locale);
			for (var i = 0; i < formats.length; i += 1) {
				var format = formats[i];
				var formatText = text;
				if (format.includes("wo") || format.includes("Wo")) {
					// parse Wo
					var year = formatText.split("-")[0];
					var weekStr = formatText.split("-")[1];
					var firstWeek = dayjs(year, "YYYY").startOf("year").locale(localeStr);
					for (var j = 0; j <= 52; j += 1) {
						var nextWeek = firstWeek.add(j, "week");
						if (nextWeek.format("Wo") === weekStr) {
							return nextWeek;
						}
					}
					return null;
				}
				var date = dayjs(formatText, format, true).locale(localeStr);
				if (date.isValid()) {
					return date;
				}
			}
			return null;
		}
	}
};
var dayjsGenerateConfig = generateConfig;
// ====================== Mode ======================
function getRealPlacement(placement, rtl) {
	if (placement !== void 0) {
		return placement;
	}
	return rtl ? "bottomRight" : "bottomLeft";
}
var PickerContext = reactExports.createContext(null);
var PickerContext$1 = PickerContext;
function _typeof$s(o) {
	"@babel/helpers - typeof";
	return _typeof$s = function(o) {
		return typeof o;
	}, _typeof$s(o);
}
function _defineProperty$q(obj, key, value) {
	key = _toPropertyKey$q(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$q(t) {
	var i = _toPrimitive$q(t);
	return "symbol" == _typeof$s(i) ? i : String(i);
}
function _toPrimitive$q(t) {
	if ("object" != _typeof$s(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$s(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
var BUILT_IN_PLACEMENTS = {
	bottomLeft: {
		points: ["tl", "bl"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	bottomRight: {
		points: ["tr", "br"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	topLeft: {
		points: ["bl", "tl"],
		offset: [0, -4],
		overflow: {
			adjustX: 0,
			adjustY: 1
		}
	},
	topRight: {
		points: ["br", "tr"],
		offset: [0, -4],
		overflow: {
			adjustX: 0,
			adjustY: 1
		}
	}
};
function PickerTrigger(_ref) {
	var popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupAlign = _ref.popupAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range = _ref.range, placement = _ref.placement, _ref$builtinPlacement = _ref.builtinPlacements, builtinPlacements = _ref$builtinPlacement === void 0 ? BUILT_IN_PLACEMENTS : _ref$builtinPlacement, direction = _ref.direction, visible = _ref.visible, onClose = _ref.onClose;
	var _React$useContext = reactExports.useContext(PickerContext$1), prefixCls = _React$useContext.prefixCls;
	var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
	var realPlacement = getRealPlacement(placement, direction === "rtl");
	return reactExports.createElement(Trigger, {
		showAction: [],
		hideAction: ["click"],
		popupPlacement: realPlacement,
		builtinPlacements,
		prefixCls: dropdownPrefixCls,
		popupMotion: { motionName: transitionName },
		popup: popupElement,
		popupAlign,
		popupVisible: visible,
		popupClassName: clsx(popupClassName, _defineProperty$q(_defineProperty$q({}, "".concat(dropdownPrefixCls, "-range"), range), "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl")),
		popupStyle,
		stretch: "minWidth",
		getPopupContainer,
		onPopupVisibleChange: function(nextVisible) {
			if (!nextVisible) {
				onClose();
			}
		}
	}, children);
}
function _toConsumableArray$7(arr) {
	return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$x(arr) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$x(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$x(o);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$x(o);
}
function _iterableToArray$7(iter) {
	if (iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$7(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$x(arr);
}
function _arrayLikeToArray$x(arr, len) {
	{
		len = arr.length;
	}
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function leftPad(str, length) {
	var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
	var current = String(str);
	while (current.length < length) {
		current = "".concat(fill).concat(current);
	}
	return current;
}
/**
* Convert `value` to array. Will provide `[]` if is null or undefined.
*/
function toArray(val) {
	if (val === null || val === void 0) {
		return [];
	}
	return Array.isArray(val) ? val : [val];
}
function fillIndex(ori, index, value) {
	var clone = _toConsumableArray$7(ori);
	clone[index] = value;
	return clone;
}
/** Pick props from the key list. Will filter empty value */
function pickProps(props, keys) {
	var clone = {};
	var mergedKeys = keys;
	mergedKeys.forEach(function(key) {
		if (props[key] !== void 0) {
			clone[key] = props[key];
		}
	});
	return clone;
}
function getRowFormat(picker, locale, format) {
	if (format) {
		return format;
	}
	switch (picker) {
		case "time": return locale.fieldTimeFormat;
		case "datetime": return locale.fieldDateTimeFormat;
		case "month": return locale.fieldMonthFormat;
		case "year": return locale.fieldYearFormat;
		case "quarter": return locale.fieldQuarterFormat;
		case "week": return locale.fieldWeekFormat;
		default: return locale.fieldDateFormat;
	}
}
function getFromDate(calendarValues, activeIndexList, activeIndex) {
	var mergedActiveIndex = activeIndex !== void 0 ? activeIndex : activeIndexList[activeIndexList.length - 1];
	var firstValuedIndex = activeIndexList.find(function(index) {
		return calendarValues[index];
	});
	return mergedActiveIndex !== firstValuedIndex ? calendarValues[firstValuedIndex] : void 0;
}
function pickTriggerProps(props) {
	return pickProps(props, [
		"placement",
		"builtinPlacements",
		"popupAlign",
		"getPopupContainer",
		"transitionName",
		"direction"
	]);
}
function _typeof$r(o) {
	"@babel/helpers - typeof";
	return _typeof$r = function(o) {
		return typeof o;
	}, _typeof$r(o);
}
function ownKeys$g(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$g(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$g(Object(t), true).forEach(function(r) {
			_defineProperty$p(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$p(obj, key, value) {
	key = _toPropertyKey$p(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$p(t) {
	var i = _toPrimitive$p(t);
	return "symbol" == _typeof$r(i) ? i : String(i);
}
function _toPrimitive$p(t) {
	if ("object" != _typeof$r(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$r(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function useCellRender(cellRender, dateRender, monthCellRender, range) {
	// ======================== Render ========================
	// Merged render
	var mergedCellRender = reactExports.useMemo(function() {
		if (cellRender) {
			return cellRender;
		}
		return function(current, info) {
			var date = current;
			if (dateRender && info.type === "date") {
				return dateRender(date, info.today);
			}
			if (monthCellRender && info.type === "month") {
				return monthCellRender(date, info.locale);
			}
			return info.originNode;
		};
	}, [
		cellRender,
		monthCellRender,
		dateRender
	]);
	// Cell render
	var onInternalCellRender = reactExports.useCallback(function(date, info) {
		return mergedCellRender(date, _objectSpread$g(_objectSpread$g({}, info), {}, { range }));
	}, [mergedCellRender, range]);
	return onInternalCellRender;
}
function _slicedToArray$u(arr) {
	return _arrayWithHoles$u(arr) || _iterableToArrayLimit$u(arr) || _unsupportedIterableToArray$w(arr) || _nonIterableRest$u();
}
function _nonIterableRest$u() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$w(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$w(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$w(o, 2);
}
function _arrayLikeToArray$w(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$u(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$u(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* Used to control each fields invalidate status
*/
function useFieldsInvalidate(calendarValue, isInvalidateDate) {
	var allowEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
	var _React$useState = reactExports.useState([false, false]), _React$useState2 = _slicedToArray$u(_React$useState), fieldsInvalidates = _React$useState2[0], setFieldsInvalidates = _React$useState2[1];
	var onSelectorInvalid = function(invalid, index) {
		setFieldsInvalidates(function(ori) {
			return fillIndex(ori, index, invalid);
		});
	};
	/**
	* For the Selector Input to mark as `aria-disabled`
	*/
	var submitInvalidates = reactExports.useMemo(function() {
		return fieldsInvalidates.map(function(invalid, index) {
			// If typing invalidate
			if (invalid) {
				return true;
			}
			var current = calendarValue[index];
			// Not check if all empty
			if (!current) {
				return false;
			}
			// Not allow empty
			if (!allowEmpty[index] && !current) {
				return true;
			}
			// Invalidate
			if (current && isInvalidateDate(current, { activeIndex: index })) {
				return true;
			}
			return false;
		});
	}, [
		calendarValue,
		fieldsInvalidates,
		isInvalidateDate,
		allowEmpty
	]);
	return [submitInvalidates, onSelectorInvalid];
}
function _typeof$q(o) {
	"@babel/helpers - typeof";
	return _typeof$q = function(o) {
		return typeof o;
	}, _typeof$q(o);
}
function ownKeys$f(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$f(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$f(Object(t), true).forEach(function(r) {
			_defineProperty$o(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$o(obj, key, value) {
	key = _toPropertyKey$o(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$o(t) {
	var i = _toPrimitive$o(t);
	return "symbol" == _typeof$q(i) ? i : String(i);
}
function _toPrimitive$o(t) {
	if ("object" != _typeof$q(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$q(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem) {
	var timeFormat;
	// Base HH:mm:ss
	var cells = [];
	if (showHour) {
		cells.push(showMeridiem ? "hh" : "HH");
	}
	if (showMinute) {
		cells.push("mm");
	}
	if (showSecond) {
		cells.push("ss");
	}
	timeFormat = cells.join(":");
	// Millisecond
	if (showMillisecond) {
		timeFormat += ".SSS";
	}
	// Meridiem
	if (showMeridiem) {
		timeFormat += " A";
	}
	return timeFormat;
}
/**
* Used for `useFilledProps` since it already in the React.useMemo
*/
function fillLocale(locale, showHour, showMinute, showSecond, showMillisecond, use12Hours) {
	// Not fill `monthFormat` since `locale.shortMonths` handle this
	// Not fill `cellMeridiemFormat` since AM & PM by default
	var fieldDateTimeFormat = locale.fieldDateTimeFormat, fieldDateFormat = locale.fieldDateFormat, fieldTimeFormat = locale.fieldTimeFormat, fieldMonthFormat = locale.fieldMonthFormat, fieldYearFormat = locale.fieldYearFormat, fieldWeekFormat = locale.fieldWeekFormat, fieldQuarterFormat = locale.fieldQuarterFormat, yearFormat = locale.yearFormat, cellYearFormat = locale.cellYearFormat, cellQuarterFormat = locale.cellQuarterFormat, dayFormat = locale.dayFormat, cellDateFormat = locale.cellDateFormat;
	var timeFormat = fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, use12Hours);
	return _objectSpread$f(_objectSpread$f({}, locale), {}, {
		fieldDateTimeFormat: fieldDateTimeFormat || "YYYY-MM-DD ".concat(timeFormat),
		fieldDateFormat: fieldDateFormat || "YYYY-MM-DD",
		fieldTimeFormat: fieldTimeFormat || timeFormat,
		fieldMonthFormat: fieldMonthFormat || "YYYY-MM",
		fieldYearFormat: fieldYearFormat || "YYYY",
		fieldWeekFormat: fieldWeekFormat || "gggg-wo",
		fieldQuarterFormat: fieldQuarterFormat || "YYYY-[Q]Q",
		yearFormat: yearFormat || "YYYY",
		cellYearFormat: cellYearFormat || "YYYY",
		cellQuarterFormat: cellQuarterFormat || "[Q]Q",
		cellDateFormat: cellDateFormat || dayFormat || "D"
	});
}
/**
* Fill locale format as start up
*/
function useLocale(locale, showProps) {
	var showHour = showProps.showHour, showMinute = showProps.showMinute, showSecond = showProps.showSecond, showMillisecond = showProps.showMillisecond, use12Hours = showProps.use12Hours;
	return React.useMemo(function() {
		return fillLocale(locale, showHour, showMinute, showSecond, showMillisecond, use12Hours);
	}, [
		locale,
		showHour,
		showMinute,
		showSecond,
		showMillisecond,
		use12Hours
	]);
}
function ownKeys$e(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$e(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$e(Object(t), true).forEach(function(r) {
			_defineProperty$n(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$n(obj, key, value) {
	key = _toPropertyKey$n(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$n(t) {
	var i = _toPrimitive$n(t);
	return "symbol" == _typeof$p(i) ? i : String(i);
}
function _toPrimitive$n(t) {
	if ("object" != _typeof$p(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$p(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$t(arr, i) {
	return _arrayWithHoles$t(arr) || _iterableToArrayLimit$t(arr, i) || _unsupportedIterableToArray$v(arr, i) || _nonIterableRest$t();
}
function _nonIterableRest$t() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$v(o, minLen) {
	if (!o) return;
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$v(o, minLen);
}
function _arrayLikeToArray$v(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$t(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$t(arr) {
	if (Array.isArray(arr)) return arr;
}
function _typeof$p(o) {
	"@babel/helpers - typeof";
	return _typeof$p = function(o) {
		return typeof o;
	}, _typeof$p(o);
}
function checkShow(format, keywords, show) {
	return show !== null && show !== void 0 ? show : keywords.some(function(keyword) {
		return format.includes(keyword);
	});
}
var showTimeKeys = [
	"showNow",
	"showHour",
	"showMinute",
	"showSecond",
	"showMillisecond",
	"use12Hours",
	"hourStep",
	"minuteStep",
	"secondStep",
	"millisecondStep",
	"hideDisabledOptions",
	"defaultValue",
	"disabledHours",
	"disabledMinutes",
	"disabledSeconds",
	"disabledMilliseconds",
	"disabledTime",
	"changeOnScroll",
	"defaultOpenValue"
];
/**
* Get SharedTimeProps from props.
*/
function pickTimeProps(props) {
	var timeProps = pickProps(props, showTimeKeys);
	var format = props.format, picker = props.picker;
	var propFormat = null;
	if (format) {
		propFormat = format;
		if (Array.isArray(propFormat)) {
			propFormat = propFormat[0];
		}
		propFormat = _typeof$p(propFormat) === "object" ? propFormat.format : propFormat;
	}
	if (picker === "time") {
		timeProps.format = propFormat;
	}
	return [timeProps, propFormat];
}
function isStringFormat(format) {
	return format && typeof format === "string";
}
/** Check if all the showXXX is `undefined` */
function existShowConfig(showHour, showMinute, showSecond, showMillisecond) {
	return [
		showHour,
		showMinute,
		showSecond,
		showMillisecond
	].some(function(show) {
		return show !== void 0;
	});
}
/** Fill the showXXX if needed */
function fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond) {
	var parsedShowHour = showHour;
	var parsedShowMinute = showMinute;
	var parsedShowSecond = showSecond;
	if (!hasShowConfig && !parsedShowHour && !parsedShowMinute && !parsedShowSecond && !showMillisecond) {
		parsedShowHour = true;
		parsedShowMinute = true;
		parsedShowSecond = true;
	} else if (hasShowConfig) {
		var _parsedShowHour, _parsedShowMinute, _parsedShowSecond;
		var existFalse = [
			parsedShowHour,
			parsedShowMinute,
			parsedShowSecond
		].some(function(show) {
			return show === false;
		});
		var existTrue = [
			parsedShowHour,
			parsedShowMinute,
			parsedShowSecond
		].some(function(show) {
			return show === true;
		});
		var defaultShow = existFalse ? true : !existTrue;
		parsedShowHour = (_parsedShowHour = parsedShowHour) !== null && _parsedShowHour !== void 0 ? _parsedShowHour : defaultShow;
		parsedShowMinute = (_parsedShowMinute = parsedShowMinute) !== null && _parsedShowMinute !== void 0 ? _parsedShowMinute : defaultShow;
		parsedShowSecond = (_parsedShowSecond = parsedShowSecond) !== null && _parsedShowSecond !== void 0 ? _parsedShowSecond : defaultShow;
	}
	return [
		parsedShowHour,
		parsedShowMinute,
		parsedShowSecond,
		showMillisecond
	];
}
/**
* Get `showHour`, `showMinute`, `showSecond` or other from the props.
* This is pure function, will not get `showXXX` from the `format` prop.
*/
function getTimeProps(componentProps) {
	var showTime = componentProps.showTime;
	var _pickTimeProps = pickTimeProps(componentProps), _pickTimeProps2 = _slicedToArray$t(_pickTimeProps, 2), pickedProps = _pickTimeProps2[0], propFormat = _pickTimeProps2[1];
	var showTimeConfig = showTime && _typeof$p(showTime) === "object" ? showTime : {};
	var timeConfig = _objectSpread$e(_objectSpread$e({ defaultOpenValue: showTimeConfig.defaultOpenValue || showTimeConfig.defaultValue }, pickedProps), showTimeConfig);
	var showMillisecond = timeConfig.showMillisecond;
	var showHour = timeConfig.showHour, showMinute = timeConfig.showMinute, showSecond = timeConfig.showSecond;
	var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
	var _fillShowConfig = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
	var _fillShowConfig2 = _slicedToArray$t(_fillShowConfig, 3);
	showHour = _fillShowConfig2[0];
	showMinute = _fillShowConfig2[1];
	showSecond = _fillShowConfig2[2];
	return [
		timeConfig,
		_objectSpread$e(_objectSpread$e({}, timeConfig), {}, {
			showHour,
			showMinute,
			showSecond,
			showMillisecond
		}),
		timeConfig.format,
		propFormat
	];
}
function fillShowTimeConfig(picker, showTimeFormat, propFormat, timeConfig, locale) {
	var isTimePicker = picker === "time";
	if (picker === "datetime" || isTimePicker) {
		var pickedProps = timeConfig;
		// ====================== BaseFormat ======================
		var defaultLocaleFormat = getRowFormat(picker, locale, null);
		var baselineFormat = defaultLocaleFormat;
		var formatList = [showTimeFormat, propFormat];
		for (var i = 0; i < 2; i += 1) {
			var format = toArray(formatList[i])[0];
			if (isStringFormat(format)) {
				baselineFormat = format;
				break;
			}
		}
		// ========================= Show =========================
		var showHour = pickedProps.showHour, showMinute = pickedProps.showMinute, showSecond = pickedProps.showSecond, showMillisecond = pickedProps.showMillisecond;
		var use12Hours = pickedProps.use12Hours;
		var showMeridiem = checkShow(baselineFormat, [
			"a",
			"A",
			"LT",
			"LLL",
			"LTS"
		], use12Hours);
		var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
		// Fill with format, if needed
		if (!hasShowConfig) {
			showHour = checkShow(baselineFormat, [
				"H",
				"h",
				"k",
				"LT",
				"LLL"
			]);
			showMinute = checkShow(baselineFormat, [
				"m",
				"LT",
				"LLL"
			]);
			showSecond = checkShow(baselineFormat, ["s", "LTS"]);
			showMillisecond = checkShow(baselineFormat, ["SSS"]);
		}
		// Fallback if all can not see
		// ======================== Format ========================
		var _fillShowConfig3 = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
		var _fillShowConfig4 = _slicedToArray$t(_fillShowConfig3, 3);
		showHour = _fillShowConfig4[0];
		showMinute = _fillShowConfig4[1];
		showSecond = _fillShowConfig4[2];
		var timeFormat = showTimeFormat || fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem);
		// ======================== Props =========================
		return _objectSpread$e(_objectSpread$e({}, pickedProps), {}, {
			format: timeFormat,
			showHour,
			showMinute,
			showSecond,
			showMillisecond,
			use12Hours: showMeridiem
		});
	}
	return null;
}
function _typeof$o(o) {
	"@babel/helpers - typeof";
	return _typeof$o = function(o) {
		return typeof o;
	}, _typeof$o(o);
}
/**
* Used for `useFilledProps` since it already in the React.useMemo
*/
function fillClearIcon(prefixCls, allowClear, clearIcon) {
	if (allowClear === false) {
		return null;
	}
	var config = allowClear && _typeof$o(allowClear) === "object" ? allowClear : {};
	return config.clearIcon || clearIcon || reactExports.createElement("span", { className: "".concat(prefixCls, "-clear-btn") });
}
/**
* Wrap the compare logic.
* This will compare the each of value is empty first.
* 1. All is empty, return true.
* 2. One is empty, return false.
* 3. return customize compare logic.
*/
function nullableCompare(value1, value2, oriCompareFn) {
	if (!value1 && !value2 || value1 === value2) {
		return true;
	}
	if (!value1 || !value2) {
		return false;
	}
	return oriCompareFn();
}
function isSameDecade(generateConfig, decade1, decade2) {
	return nullableCompare(decade1, decade2, function() {
		var num1 = Math.floor(generateConfig.getYear(decade1) / 10);
		var num2 = Math.floor(generateConfig.getYear(decade2) / 10);
		return num1 === num2;
	});
}
function isSameYear(generateConfig, year1, year2) {
	return nullableCompare(year1, year2, function() {
		return generateConfig.getYear(year1) === generateConfig.getYear(year2);
	});
}
function getQuarter(generateConfig, date) {
	var quota = Math.floor(generateConfig.getMonth(date) / 3);
	return quota + 1;
}
function isSameQuarter(generateConfig, quarter1, quarter2) {
	return nullableCompare(quarter1, quarter2, function() {
		return isSameYear(generateConfig, quarter1, quarter2) && getQuarter(generateConfig, quarter1) === getQuarter(generateConfig, quarter2);
	});
}
function isSameMonth(generateConfig, month1, month2) {
	return nullableCompare(month1, month2, function() {
		return isSameYear(generateConfig, month1, month2) && generateConfig.getMonth(month1) === generateConfig.getMonth(month2);
	});
}
function isSameDate(generateConfig, date1, date2) {
	return nullableCompare(date1, date2, function() {
		return isSameYear(generateConfig, date1, date2) && isSameMonth(generateConfig, date1, date2) && generateConfig.getDate(date1) === generateConfig.getDate(date2);
	});
}
function isSameTime(generateConfig, time1, time2) {
	return nullableCompare(time1, time2, function() {
		return generateConfig.getHour(time1) === generateConfig.getHour(time2) && generateConfig.getMinute(time1) === generateConfig.getMinute(time2) && generateConfig.getSecond(time1) === generateConfig.getSecond(time2);
	});
}
/**
* Check if the Date is all the same of timestamp
*/
function isSameTimestamp(generateConfig, time1, time2) {
	return nullableCompare(time1, time2, function() {
		return isSameDate(generateConfig, time1, time2) && isSameTime(generateConfig, time1, time2) && generateConfig.getMillisecond(time1) === generateConfig.getMillisecond(time2);
	});
}
function isSameWeek(generateConfig, locale, date1, date2) {
	return nullableCompare(date1, date2, function() {
		var weekStartDate1 = generateConfig.locale.getWeekFirstDate(locale, date1);
		var weekStartDate2 = generateConfig.locale.getWeekFirstDate(locale, date2);
		return isSameYear(generateConfig, weekStartDate1, weekStartDate2) && generateConfig.locale.getWeek(locale, date1) === generateConfig.locale.getWeek(locale, date2);
	});
}
function isSame(generateConfig, locale, source, target, type) {
	switch (type) {
		case "date": return isSameDate(generateConfig, source, target);
		case "week": return isSameWeek(generateConfig, locale.locale, source, target);
		case "month": return isSameMonth(generateConfig, source, target);
		case "quarter": return isSameQuarter(generateConfig, source, target);
		case "year": return isSameYear(generateConfig, source, target);
		case "decade": return isSameDecade(generateConfig, source, target);
		case "time": return isSameTime(generateConfig, source, target);
		default: return isSameTimestamp(generateConfig, source, target);
	}
}
/** Between in date but not equal of date */
function isInRange(generateConfig, startDate, endDate, current) {
	if (!startDate || !endDate || !current) {
		return false;
	}
	return generateConfig.isAfter(current, startDate) && generateConfig.isAfter(endDate, current);
}
function isSameOrAfter(generateConfig, locale, date1, date2, type) {
	if (isSame(generateConfig, locale, date1, date2, type)) {
		return true;
	}
	return generateConfig.isAfter(date1, date2);
}
function getWeekStartDate(locale, generateConfig, value) {
	var weekFirstDay = generateConfig.locale.getWeekFirstDay(locale);
	var monthStartDate = generateConfig.setDate(value, 1);
	var startDateWeekDay = generateConfig.getWeekDay(monthStartDate);
	var alignStartDate = generateConfig.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
	if (generateConfig.getMonth(alignStartDate) === generateConfig.getMonth(value) && generateConfig.getDate(alignStartDate) > 1) {
		alignStartDate = generateConfig.addDate(alignStartDate, -7);
	}
	return alignStartDate;
}
function formatValue(value, _ref) {
	var generateConfig = _ref.a, locale = _ref.b, format = _ref.c;
	if (!value) {
		return "";
	}
	return typeof format === "function" ? format(value) : generateConfig.locale.format(locale.locale, value, format);
}
/**
* Fill the time info into Date if provided.
*/
function fillTime(generateConfig, date, time) {
	var tmpDate = date;
	var getFn = [
		"getHour",
		"getMinute",
		"getSecond",
		"getMillisecond"
	];
	var setFn = [
		"setHour",
		"setMinute",
		"setSecond",
		"setMillisecond"
	];
	setFn.forEach(function(fn, index) {
		if (time) {
			tmpDate = generateConfig[fn](tmpDate, generateConfig[getFn[index]](time));
		} else {
			tmpDate = generateConfig[fn](tmpDate, 0);
		}
	});
	return tmpDate;
}
/**
* Merge `disabledDate` with `minDate` & `maxDate`.
*/
function useDisabledBoundary(generateConfig, locale, disabledDate, minDate, maxDate) {
	var mergedDisabledDate = useEvent(function(date, info) {
		if (disabledDate && disabledDate(date, info)) {
			return true;
		}
		if (minDate && generateConfig.isAfter(minDate, date) && !isSame(generateConfig, locale, minDate, date, info.type)) {
			return true;
		}
		if (maxDate && generateConfig.isAfter(date, maxDate) && !isSame(generateConfig, locale, maxDate, date, info.type)) {
			return true;
		}
		return false;
	});
	return mergedDisabledDate;
}
function _typeof$n(o) {
	"@babel/helpers - typeof";
	return _typeof$n = function(o) {
		return typeof o;
	}, _typeof$n(o);
}
function useFieldFormat(picker, locale, format) {
	return reactExports.useMemo(function() {
		var rawFormat = getRowFormat(picker, locale, format);
		var formatList = toArray(rawFormat);
		var firstFormat = formatList[0];
		var maskFormat = _typeof$n(firstFormat) === "object" && firstFormat.type === "mask" ? firstFormat.format : null;
		return [formatList.map(function(config) {
			return typeof config === "string" || typeof config === "function" ? config : config.format;
		}), maskFormat];
	}, [
		picker,
		locale,
		format
	]);
}
function useInputReadOnly(formatList, inputReadOnly, multiple) {
	if (typeof formatList[0] === "function" || multiple) {
		return true;
	}
	return inputReadOnly;
}
function _typeof$m(o) {
	"@babel/helpers - typeof";
	return _typeof$m = function(o) {
		return typeof o;
	}, _typeof$m(o);
}
function ownKeys$d(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$d(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$d(Object(t), true).forEach(function(r) {
			_defineProperty$m(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$m(obj, key, value) {
	key = _toPropertyKey$m(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$m(t) {
	var i = _toPrimitive$m(t);
	return "symbol" == _typeof$m(i) ? i : String(i);
}
function _toPrimitive$m(t) {
	if ("object" != _typeof$m(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$m(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
/**
* Check if provided date is valid for the `disabledDate` & `showTime.disabledTime`.
*/
function useInvalidate(generateConfig, picker, disabledDate, showTime) {
	// Check disabled date
	var isInvalidate = useEvent(function(date, info) {
		var outsideInfo = _objectSpread$d({ type: picker }, info);
		delete outsideInfo.activeIndex;
		if (!generateConfig.isValidate(date) || disabledDate && disabledDate(date, outsideInfo)) {
			return true;
		}
		if ((picker === "date" || picker === "time") && showTime) {
			var _showTime$disabledTim;
			var range = info && info.activeIndex === 1 ? "end" : "start";
			var _ref = ((_showTime$disabledTim = showTime.disabledTime) === null || _showTime$disabledTim === void 0 ? void 0 : _showTime$disabledTim.call(showTime, date, range, { from: outsideInfo.from })) || {}, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, disabledMilliseconds = _ref.disabledMilliseconds;
			var legacyDisabledHours = showTime.disabledHours, legacyDisabledMinutes = showTime.disabledMinutes, legacyDisabledSeconds = showTime.disabledSeconds;
			var mergedDisabledHours = disabledHours || legacyDisabledHours;
			var mergedDisabledMinutes = disabledMinutes || legacyDisabledMinutes;
			var mergedDisabledSeconds = disabledSeconds || legacyDisabledSeconds;
			var hour = generateConfig.getHour(date);
			var minute = generateConfig.getMinute(date);
			var second = generateConfig.getSecond(date);
			var millisecond = generateConfig.getMillisecond(date);
			if (mergedDisabledHours && mergedDisabledHours().includes(hour)) {
				return true;
			}
			if (mergedDisabledMinutes && mergedDisabledMinutes(hour).includes(minute)) {
				return true;
			}
			if (mergedDisabledSeconds && mergedDisabledSeconds(hour, minute).includes(second)) {
				return true;
			}
			if (disabledMilliseconds && disabledMilliseconds(hour, minute, second).includes(millisecond)) {
				return true;
			}
		}
		return false;
	});
	return isInvalidate;
}
function _typeof$l(o) {
	"@babel/helpers - typeof";
	return _typeof$l = function(o) {
		return typeof o;
	}, _typeof$l(o);
}
function ownKeys$c(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$c(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$c(Object(t), true).forEach(function(r) {
			_defineProperty$l(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$l(obj, key, value) {
	key = _toPropertyKey$l(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$l(t) {
	var i = _toPrimitive$l(t);
	return "symbol" == _typeof$l(i) ? i : String(i);
}
function _toPrimitive$l(t) {
	if ("object" != _typeof$l(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$l(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$s(arr, i) {
	return _arrayWithHoles$s(arr) || _iterableToArrayLimit$s(arr, i) || _unsupportedIterableToArray$u(arr, i) || _nonIterableRest$s();
}
function _nonIterableRest$s() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$u(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$u(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$u(o, minLen);
}
function _arrayLikeToArray$u(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$s(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$s(arr) {
	if (Array.isArray(arr)) return arr;
}
function useList(value) {
	var fillMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	var values = reactExports.useMemo(function() {
		var list = value ? toArray(value) : value;
		if (fillMode && list) {
			list[1] = list[1] || list[0];
		}
		return list;
	}, [value, fillMode]);
	return values;
}
/**
* Align the outer props with unique typed and fill undefined props.
* This is shared with both RangePicker and Picker. This will do:
* - Convert `value` & `defaultValue` to array
* - handle the legacy props fill like `clearIcon` + `allowClear` = `clearIcon`
*/
function useFilledProps(props, updater) {
	var generateConfig = props.generateConfig, locale = props.locale, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, _props$previewValue = props.previewValue, previewValue = _props$previewValue === void 0 ? "hover" : _props$previewValue, _props$styles = props.styles, styles = _props$styles === void 0 ? {} : _props$styles, _props$classNames = props.classNames, classNames = _props$classNames === void 0 ? {} : _props$classNames, _props$order = props.order, order = _props$order === void 0 ? true : _props$order, _props$components = props.components, components = _props$components === void 0 ? {} : _props$components, inputRender = props.inputRender, allowClear = props.allowClear, clearIcon = props.clearIcon, needConfirm = props.needConfirm, multiple = props.multiple, format = props.format, inputReadOnly = props.inputReadOnly, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, showTime = props.showTime, value = props.value, defaultValue = props.defaultValue, pickerValue = props.pickerValue, defaultPickerValue = props.defaultPickerValue;
	var values = useList(value);
	var defaultValues = useList(defaultValue);
	var pickerValues = useList(pickerValue);
	var defaultPickerValues = useList(defaultPickerValue);
	// ======================== Picker ========================
	/** Almost same as `picker`, but add `datetime` for `date` with `showTime` */
	var internalPicker = picker === "date" && showTime ? "datetime" : picker;
	/** The picker is `datetime` or `time` */
	var multipleInteractivePicker = internalPicker === "time" || internalPicker === "datetime";
	var complexPicker = multipleInteractivePicker || multiple;
	var mergedNeedConfirm = needConfirm !== null && needConfirm !== void 0 ? needConfirm : multipleInteractivePicker;
	// ========================== Time ==========================
	// Auto `format` need to check `showTime.showXXX` first.
	// And then merge the `locale` into `mergedShowTime`.
	var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray$s(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
	// ======================= Locales ========================
	var mergedLocale = useLocale(locale, localeTimeProps);
	var mergedShowTime = reactExports.useMemo(function() {
		return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale);
	}, [
		internalPicker,
		showTimeFormat,
		propFormat,
		timeProps,
		mergedLocale
	]);
	// ======================== Props =========================
	var filledProps = reactExports.useMemo(function() {
		return _objectSpread$c(_objectSpread$c({}, props), {}, {
			previewValue,
			prefixCls,
			locale: mergedLocale,
			picker,
			styles,
			classNames,
			order,
			components: _objectSpread$c({ input: inputRender }, components),
			clearIcon: fillClearIcon(prefixCls, allowClear, clearIcon),
			showTime: mergedShowTime,
			value: values,
			defaultValue: defaultValues,
			pickerValue: pickerValues,
			defaultPickerValue: defaultPickerValues
		}, updater === void 0 ? void 0 : updater());
	}, [props]);
	// ======================== Format ========================
	var _useFieldFormat = useFieldFormat(internalPicker, mergedLocale, format), _useFieldFormat2 = _slicedToArray$s(_useFieldFormat, 2), formatList = _useFieldFormat2[0], maskFormat = _useFieldFormat2[1];
	// ======================= ReadOnly =======================
	var mergedInputReadOnly = useInputReadOnly(formatList, inputReadOnly, multiple);
	// ======================= Boundary =======================
	var disabledBoundaryDate = useDisabledBoundary(generateConfig, locale, disabledDate, minDate, maxDate);
	// ====================== Invalidate ======================
	var isInvalidateDate = useInvalidate(generateConfig, picker, disabledBoundaryDate, mergedShowTime);
	// ======================== Merged ========================
	var mergedProps = reactExports.useMemo(function() {
		return _objectSpread$c(_objectSpread$c({}, filledProps), {}, {
			needConfirm: mergedNeedConfirm,
			inputReadOnly: mergedInputReadOnly,
			disabledDate: disabledBoundaryDate
		});
	}, [
		filledProps,
		mergedNeedConfirm,
		mergedInputReadOnly,
		disabledBoundaryDate
	]);
	return [
		mergedProps,
		internalPicker,
		complexPicker,
		formatList,
		maskFormat,
		isInvalidateDate
	];
}
function _slicedToArray$r(arr) {
	return _arrayWithHoles$r(arr) || _iterableToArrayLimit$r(arr) || _unsupportedIterableToArray$t(arr) || _nonIterableRest$r();
}
function _nonIterableRest$r() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$t(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$t(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$t(o, 2);
}
function _arrayLikeToArray$t(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$r(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$r(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* Will be `true` immediately for next effect.
* But will be `false` for a delay of effect.
*/
function useDelayState(value, defaultValue, onChange) {
	var _useControlledState = useControlledState(defaultValue, value), _useControlledState2 = _slicedToArray$r(_useControlledState), state = _useControlledState2[0], setState = _useControlledState2[1];
	// Need force update to ensure React re-render
	var _React$useState = React.useState({}), _React$useState2 = _slicedToArray$r(_React$useState), forceUpdate = _React$useState2[1];
	var triggerUpdate = useEvent(function(nextState) {
		setState(nextState);
		forceUpdate({});
	});
	var nextValueRef = React.useRef(value);
	// ============================= Update =============================
	var rafRef = React.useRef();
	var cancelRaf = function() {
		wrapperRaf.a(rafRef.current);
	};
	var doUpdate = useEvent(function() {
		triggerUpdate(nextValueRef.current);
		if (onChange && state !== nextValueRef.current) {
			onChange(nextValueRef.current);
		}
	});
	var updateValue = useEvent(function(next, immediately) {
		cancelRaf();
		nextValueRef.current = next;
		if (next || immediately) {
			doUpdate();
		} else {
			rafRef.current = wrapperRaf(doUpdate);
		}
	});
	React.useEffect(function() {
		return cancelRaf;
	}, []);
	return [state, updateValue];
}
function _slicedToArray$q(arr) {
	return _arrayWithHoles$q(arr) || _iterableToArrayLimit$q(arr) || _unsupportedIterableToArray$s(arr) || _nonIterableRest$q();
}
function _nonIterableRest$q() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$s(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$s(o, 2);
}
function _arrayLikeToArray$s(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$q(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$q(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* Control the open state.
* Will not close if activeElement is on the popup.
*/
function useOpen(open, defaultOpen) {
	var disabledList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
	var onOpenChange = arguments.length > 3 ? arguments[3] : void 0;
	var mergedOpen = disabledList.every(function(disabled) {
		return disabled;
	}) ? false : open;
	// Delay for handle the open state, in case fast shift from `open` -> `close` -> `open`
	// const [rafOpen, setRafOpen] = useLockState(open, defaultOpen || false, onOpenChange);
	var _useDelayState = useDelayState(mergedOpen, defaultOpen || false, onOpenChange), _useDelayState2 = _slicedToArray$q(_useDelayState), rafOpen = _useDelayState2[0], setRafOpen = _useDelayState2[1];
	function setOpen(next) {
		var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
		if (!config.inherit || rafOpen) {
			setRafOpen(next, config.force);
		}
	}
	return [rafOpen, setOpen];
}
function usePickerRef(ref) {
	var selectorRef = reactExports.useRef();
	reactExports.useImperativeHandle(ref, function() {
		var _selectorRef$current;
		return {
			nativeElement: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.nativeElement,
			focus: function(options) {
				var _selectorRef$current2;
				(_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 || _selectorRef$current2.focus(options);
			},
			blur: function() {
				var _selectorRef$current3;
				(_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.blur();
			}
		};
	});
	return selectorRef;
}
function _slicedToArray$p(arr) {
	return _arrayWithHoles$p(arr) || _iterableToArrayLimit$p(arr) || _unsupportedIterableToArray$r(arr) || _nonIterableRest$p();
}
function _nonIterableRest$p() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$r(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$r(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$r(o, 2);
}
function _arrayLikeToArray$r(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$p(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$p(arr) {
	if (Array.isArray(arr)) return arr;
}
function usePresets(presets, legacyRanges) {
	return reactExports.useMemo(function() {
		if (presets) {
			return presets;
		}
		if (legacyRanges) {
			warningOnce(false, "`ranges` is deprecated. Please use `presets` instead.");
			return Object.entries(legacyRanges).map(function(_ref) {
				var _ref2 = _slicedToArray$p(_ref), label = _ref2[0], value = _ref2[1];
				return {
					label,
					value
				};
			});
		}
		return [];
	}, [presets, legacyRanges]);
}
/**
* Trigger `callback` immediately when `condition` is `true`.
* But trigger `callback` in next frame when `condition` is `false`.
*/
function useLockEffect(condition, callback) {
	var delayFrames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
	var callbackRef = reactExports.useRef(callback);
	callbackRef.current = callback;
	useLayoutUpdateEffect(function() {
		if (condition) {
			callbackRef.current(condition);
		} else {
			var id = wrapperRaf(function() {
				callbackRef.current(condition);
			}, delayFrames);
			return function() {
				wrapperRaf.a(id);
			};
		}
	}, [condition]);
}
function _slicedToArray$o(arr) {
	return _arrayWithHoles$o(arr) || _iterableToArrayLimit$o(arr) || _unsupportedIterableToArray$q(arr) || _nonIterableRest$o();
}
function _nonIterableRest$o() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$q(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$q(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$q(o, 2);
}
function _arrayLikeToArray$q(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$o(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$o(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* When user first focus one input, any submit will trigger focus another one.
* When second time focus one input, submit will not trigger focus again.
* When click outside to close the panel, trigger event if it can trigger onChange.
*/
function useRangeActive(disabled) {
	var empty = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
	var mergedOpen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
	var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray$o(_React$useState), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
	var _React$useState3 = reactExports.useState(false), _React$useState4 = _slicedToArray$o(_React$useState3), focused = _React$useState4[0], setFocused = _React$useState4[1];
	var activeListRef = reactExports.useRef([]);
	var submitIndexRef = reactExports.useRef(null);
	var lastOperationRef = reactExports.useRef(null);
	var updateSubmitIndex = function(index) {
		submitIndexRef.current = index;
	};
	var hasActiveSubmitValue = function(index) {
		return submitIndexRef.current === index;
	};
	var triggerFocus = function(nextFocus) {
		setFocused(nextFocus);
	};
	// ============================= Record =============================
	var lastOperation = function(type) {
		if (type) {
			lastOperationRef.current = type;
		}
		return lastOperationRef.current;
	};
	// ============================ Strategy ============================
	// Trigger when input enter or input blur or panel close
	var nextActiveIndex = function(nextValue) {
		var list = activeListRef.current;
		var filledActiveSet = new Set(list.filter(function(index) {
			return nextValue[index] || empty[index];
		}));
		var nextIndex = list[list.length - 1] === 0 ? 1 : 0;
		if (filledActiveSet.size >= 2 || disabled[nextIndex]) {
			return null;
		}
		return nextIndex;
	};
	// ============================= Effect =============================
	// Wait in case it's from the click outside to blur
	useLockEffect(focused || mergedOpen, function() {
		if (!focused) {
			activeListRef.current = [];
			updateSubmitIndex(null);
		}
	});
	reactExports.useEffect(function() {
		if (focused) {
			activeListRef.current.push(activeIndex);
		}
	}, [focused, activeIndex]);
	return [
		focused,
		triggerFocus,
		lastOperation,
		activeIndex,
		setActiveIndex,
		nextActiveIndex,
		activeListRef.current,
		updateSubmitIndex,
		hasActiveSubmitValue
	];
}
function _typeof$k(o) {
	"@babel/helpers - typeof";
	return _typeof$k = function(o) {
		return typeof o;
	}, _typeof$k(o);
}
function ownKeys$b(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$b(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$b(Object(t), true).forEach(function(r) {
			_defineProperty$k(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$k(obj, key, value) {
	key = _toPropertyKey$k(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$k(t) {
	var i = _toPrimitive$k(t);
	return "symbol" == _typeof$k(i) ? i : String(i);
}
function _toPrimitive$k(t) {
	if ("object" != _typeof$k(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$k(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$n(arr) {
	return _arrayWithHoles$n(arr) || _iterableToArrayLimit$n(arr) || _unsupportedIterableToArray$p(arr) || _nonIterableRest$n();
}
function _nonIterableRest$n() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$p(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$p(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$p(o, 2);
}
function _arrayLikeToArray$p(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$n(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$n(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* RangePicker need additional logic to handle the `disabled` case. e.g.
* [disabled, enabled] should end date not before start date
*/
function useRangeDisabledDate(values, disabled, activeIndexList, generateConfig, locale, disabledDate) {
	var activeIndex = activeIndexList[activeIndexList.length - 1];
	var rangeDisabledDate = function(date, info) {
		var _values = _slicedToArray$n(values), start = _values[0], end = _values[1];
		var mergedInfo = _objectSpread$b(_objectSpread$b({}, info), {}, { from: getFromDate(values, activeIndexList) });
		// ============================ Disabled ============================
		// Should not select days before the start date
		if (activeIndex === 1 && disabled[0] && start && !isSame(generateConfig, locale, start, date, mergedInfo.type) && generateConfig.isAfter(start, date)) {
			return true;
		}
		// Should not select days after the end date
		if (activeIndex === 0 && disabled[1] && end && !isSame(generateConfig, locale, end, date, mergedInfo.type) && generateConfig.isAfter(date, end)) {
			return true;
		}
		// ============================= Origin =============================
		return disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date, mergedInfo);
	};
	return rangeDisabledDate;
}
function _slicedToArray$m(arr) {
	return _arrayWithHoles$m(arr) || _iterableToArrayLimit$m(arr) || _unsupportedIterableToArray$o(arr) || _nonIterableRest$m();
}
function _nonIterableRest$m() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$o(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$o(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$o(o, 2);
}
function _arrayLikeToArray$o(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$m(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$m(arr) {
	if (Array.isArray(arr)) return arr;
}
function offsetPanelDate(generateConfig, picker, date, offset) {
	switch (picker) {
		case "date":
		case "week": return generateConfig.addMonth(date, offset);
		case "month":
		case "quarter": return generateConfig.addYear(date, offset);
		case "year": return generateConfig.addYear(date, offset * 10);
		case "decade": return generateConfig.addYear(date, offset * 100);
		default: return date;
	}
}
var EMPTY_LIST = [];
function useRangePickerValue(generateConfig, locale, calendarValue, modes, open, activeIndex, pickerMode, multiplePanel) {
	var defaultPickerValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : EMPTY_LIST;
	var pickerValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : EMPTY_LIST;
	var timeDefaultValue = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : EMPTY_LIST;
	var onPickerValueChange = arguments.length > 11 ? arguments[11] : void 0;
	var minDate = arguments.length > 12 ? arguments[12] : void 0;
	var maxDate = arguments.length > 13 ? arguments[13] : void 0;
	var isTimePicker = pickerMode === "time";
	// ======================== Active ========================
	// `activeIndex` must be valid to avoid getting empty `pickerValue`
	var mergedActiveIndex = activeIndex || 0;
	// ===================== Picker Value =====================
	var getDefaultPickerValue = function(index) {
		var now = generateConfig.getNow();
		if (isTimePicker) {
			now = fillTime(generateConfig, now);
		}
		return defaultPickerValue[index] || calendarValue[index] || now;
	};
	// Align `pickerValue` with `showTime.defaultValue`
	var _pickerValue = _slicedToArray$m(pickerValue), startPickerValue = _pickerValue[0], endPickerValue = _pickerValue[1];
	// PickerValue state
	var _useControlledState = useControlledState(function() {
		return getDefaultPickerValue(0);
	}, startPickerValue), _useControlledState2 = _slicedToArray$m(_useControlledState), mergedStartPickerValue = _useControlledState2[0], setStartPickerValue = _useControlledState2[1];
	var _useControlledState3 = useControlledState(function() {
		return getDefaultPickerValue(1);
	}, endPickerValue), _useControlledState4 = _slicedToArray$m(_useControlledState3), mergedEndPickerValue = _useControlledState4[0], setEndPickerValue = _useControlledState4[1];
	// Current PickerValue
	var currentPickerValue = reactExports.useMemo(function() {
		var current = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex];
		// Merge the `showTime.defaultValue` into `pickerValue`
		return isTimePicker ? current : fillTime(generateConfig, current, timeDefaultValue[mergedActiveIndex]);
	}, [
		isTimePicker,
		mergedStartPickerValue,
		mergedEndPickerValue,
		mergedActiveIndex,
		generateConfig,
		timeDefaultValue
	]);
	var setCurrentPickerValue = function(nextPickerValue) {
		var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "panel";
		var updater = [setStartPickerValue, setEndPickerValue][mergedActiveIndex];
		updater(nextPickerValue);
		var clone = [mergedStartPickerValue, mergedEndPickerValue];
		clone[mergedActiveIndex] = nextPickerValue;
		if (onPickerValueChange && (!isSame(generateConfig, locale, mergedStartPickerValue, clone[0], pickerMode) || !isSame(generateConfig, locale, mergedEndPickerValue, clone[1], pickerMode))) {
			onPickerValueChange(clone, {
				source,
				range: mergedActiveIndex === 1 ? "end" : "start",
				mode: modes
			});
		}
	};
	// ======================== Effect ========================
	/**
	* EndDate pickerValue is little different. It should be:
	* - If date picker (without time), endDate is not same year & month as startDate
	*   - pickerValue minus one month
	* - Else pass directly
	*/
	var getEndDatePickerValue = function(startDate, endDate) {
		if (multiplePanel) {
			// Basic offset
			var SAME_CHECKER = {
				date: "month",
				week: "month",
				month: "year",
				quarter: "year"
			};
			var mode = SAME_CHECKER[pickerMode];
			if (mode && !isSame(generateConfig, 0, startDate, endDate, mode)) {
				return offsetPanelDate(generateConfig, pickerMode, endDate, -1);
			}
			// Year offset
			if (pickerMode === "year" && startDate) {
				var srcYear = Math.floor(generateConfig.getYear(startDate) / 10);
				var tgtYear = Math.floor(generateConfig.getYear(endDate) / 10);
				if (srcYear !== tgtYear) {
					return offsetPanelDate(generateConfig, pickerMode, endDate, -1);
				}
			}
		}
		return endDate;
	};
	// >>> When switch field, reset the picker value as prev field picker value
	var prevActiveIndexRef = reactExports.useRef(null);
	useLayoutEffect(function() {
		if (open) {
			if (!defaultPickerValue[mergedActiveIndex]) {
				var nextPickerValue = isTimePicker ? null : generateConfig.getNow();
				/**
				* 1. If has prevActiveIndex, use it to avoid panel jump
				* 2. If current field has value
				*    - If `activeIndex` is 1 and `calendarValue[0]` is not same panel as `calendarValue[1]`,
				*      offset `calendarValue[1]` and set it
				*    - Else use `calendarValue[activeIndex]`
				* 3. If current field has no value but another field has value, use another field value
				* 4. Else use now (not any `calendarValue` can ref)
				*/
				if (prevActiveIndexRef.current !== null && prevActiveIndexRef.current !== mergedActiveIndex) {
					// If from another field, not jump picker value
					nextPickerValue = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex ^ 1];
				} else if (calendarValue[mergedActiveIndex]) {
					// Current field has value
					nextPickerValue = mergedActiveIndex === 0 ? calendarValue[0] : getEndDatePickerValue(calendarValue[0], calendarValue[1]);
				} else if (calendarValue[mergedActiveIndex ^ 1]) {
					// Current field has no value but another field has value
					nextPickerValue = calendarValue[mergedActiveIndex ^ 1];
				}
				// Only sync when has value, this will sync in the `min-max` logic
				if (nextPickerValue) {
					// nextPickerValue < minDate
					if (minDate && generateConfig.isAfter(minDate, nextPickerValue)) {
						nextPickerValue = minDate;
					}
					// maxDate < nextPickerValue
					var offsetPickerValue = multiplePanel ? offsetPanelDate(generateConfig, pickerMode, nextPickerValue, 1) : nextPickerValue;
					if (maxDate && generateConfig.isAfter(offsetPickerValue, maxDate)) {
						nextPickerValue = multiplePanel ? offsetPanelDate(generateConfig, pickerMode, maxDate, -1) : maxDate;
					}
					setCurrentPickerValue(nextPickerValue, "reset");
				}
			}
		}
	}, [
		open,
		mergedActiveIndex,
		calendarValue[mergedActiveIndex]
	]);
	// >>> Reset prevActiveIndex when panel closed
	reactExports.useEffect(function() {
		if (open) {
			prevActiveIndexRef.current = mergedActiveIndex;
		} else {
			prevActiveIndexRef.current = null;
		}
	}, [open, mergedActiveIndex]);
	// >>> defaultPickerValue: Resync to `defaultPickerValue` for each panel focused
	useLayoutEffect(function() {
		if (open && defaultPickerValue) {
			if (defaultPickerValue[mergedActiveIndex]) {
				setCurrentPickerValue(defaultPickerValue[mergedActiveIndex], "reset");
			}
		}
	}, [open, mergedActiveIndex]);
	return [currentPickerValue, setCurrentPickerValue];
}
function _slicedToArray$l(arr) {
	return _arrayWithHoles$l(arr) || _iterableToArrayLimit$l(arr) || _unsupportedIterableToArray$n(arr) || _nonIterableRest$l();
}
function _nonIterableRest$l() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$n(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$n(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$n(o, 2);
}
function _arrayLikeToArray$n(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$l(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$l(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* Sync value with state.
* This should only used for internal which not affect outside calculation.
* Since it's not safe for suspense.
*/
function useSyncState(defaultValue) {
	var valueRef = reactExports.useRef(defaultValue);
	var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray$l(_React$useState), forceUpdate = _React$useState2[1];
	var getter = function() {
		return valueRef.current;
	};
	var setter = function(nextValue) {
		valueRef.current = nextValue;
		forceUpdate({});
	};
	return [
		getter,
		setter,
		getter()
	];
}
function _slicedToArray$k(arr, i) {
	return _arrayWithHoles$k(arr) || _iterableToArrayLimit$k(arr, i) || _unsupportedIterableToArray$m(arr, i) || _nonIterableRest$k();
}
function _nonIterableRest$k() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$k(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$k(arr) {
	if (Array.isArray(arr)) return arr;
}
function _toConsumableArray$6(arr) {
	return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$m(arr) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$m(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$m(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$m(o, minLen);
}
function _iterableToArray$6(iter) {
	if (iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$6(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$m(arr);
}
function _arrayLikeToArray$m(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
var EMPTY_VALUE = [];
// Submit Logic:
// *  Value:
//    * merged value using controlled value, if not, use stateValue
//    * When merged value change, [1] resync calendar value and submit value
// *  Calender Value:
//    *  When user typing is validate, change the calendar value
//    *  When user click on the panel, change the calendar value
// * Submit Value:
//    *  When user blur the input, flush calendar value to submit value
//    *  When user click on the panel is no needConfirm, flush calendar value to submit value
//    *  When user click on the panel is needConfirm and click OK, flush calendar value to submit value
// * Blur logic & close logic:
//    *  For value, always try flush submit
//    *  If `needConfirm`, reset as [1]
//    * Else (`!needConfirm`)
//      * If has another index field, active another index
// *  Flush submit:
//    * If all the start & end field is confirmed or all blur or panel closed
//    * Update `needSubmit` mark to true
//    * trigger onChange by `needSubmit` and update stateValue
function useUtil(generateConfig, locale, formatList) {
	var getDateTexts = function(dates) {
		return dates.map(function(date) {
			return formatValue(date, {
				a: generateConfig,
				b: locale,
				c: formatList[0]
			});
		});
	};
	var isSameDates = function(source, target) {
		var maxLen = Math.max(source.length, target.length);
		var diffIndex = -1;
		for (var i = 0; i < maxLen; i += 1) {
			var prev = source[i] || null;
			var next = target[i] || null;
			if (prev !== next && !isSameTimestamp(generateConfig, prev, next)) {
				diffIndex = i;
				break;
			}
		}
		return [diffIndex < 0, diffIndex !== 0];
	};
	return [getDateTexts, isSameDates];
}
function orderDates(dates, generateConfig) {
	return _toConsumableArray$6(dates).sort(function(a, b) {
		return generateConfig.isAfter(a, b) ? 1 : -1;
	});
}
/**
* Used for internal value management.
* It should always use `mergedValue` in render logic
*/
function useCalendarValue(mergedValue) {
	var _useSyncState = useSyncState(mergedValue), _useSyncState2 = _slicedToArray$k(_useSyncState, 2), calendarValue = _useSyncState2[0], setCalendarValue = _useSyncState2[1];
	/** Sync calendarValue & submitValue back with value */
	var syncWithValue = useEvent(function() {
		setCalendarValue(mergedValue);
	});
	reactExports.useEffect(function() {
		syncWithValue();
	}, [mergedValue]);
	return [calendarValue, setCalendarValue];
}
/**
* Control the internal `value` align with prop `value` and provide a temp `calendarValue` for ui.
* `calendarValue` will be reset when blur & focus & open.
*/
function useInnerValue(generateConfig, locale, formatList, rangeValue, order, defaultValue, value, onCalendarChange, onOk) {
	// This is the root value which will sync with controlled or uncontrolled value
	var _useControlledState = useControlledState(defaultValue, value), _useControlledState2 = _slicedToArray$k(_useControlledState, 2), innerValue = _useControlledState2[0], setInnerValue = _useControlledState2[1];
	var mergedValue = innerValue || EMPTY_VALUE;
	// ========================= Inner Values =========================
	var _useCalendarValue = useCalendarValue(mergedValue), _useCalendarValue2 = _slicedToArray$k(_useCalendarValue, 2), calendarValue = _useCalendarValue2[0], setCalendarValue = _useCalendarValue2[1];
	// ============================ Change ============================
	var _useUtil = useUtil(generateConfig, locale, formatList), _useUtil2 = _slicedToArray$k(_useUtil, 2), getDateTexts = _useUtil2[0], isSameDates = _useUtil2[1];
	var triggerCalendarChange = useEvent(function(nextCalendarValues) {
		var clone = _toConsumableArray$6(nextCalendarValues);
		if (rangeValue) {
			for (var i = 0; i < 2; i += 1) {
				clone[i] = clone[i] || null;
			}
		} else if (order) {
			clone = orderDates(clone.filter(function(date) {
				return date;
			}), generateConfig);
		}
		// Update merged value
		var _isSameDates = isSameDates(calendarValue(), clone), _isSameDates2 = _slicedToArray$k(_isSameDates, 2), isSameMergedDates = _isSameDates2[0], isSameStart = _isSameDates2[1];
		if (!isSameMergedDates) {
			setCalendarValue(clone);
			// Trigger calendar change event
			if (onCalendarChange) {
				var cellTexts = getDateTexts(clone);
				onCalendarChange(clone, cellTexts, { range: isSameStart ? "end" : "start" });
			}
		}
	});
	var triggerOk = function() {
		if (onOk) {
			onOk(calendarValue());
		}
	};
	return [
		mergedValue,
		setInnerValue,
		calendarValue,
		triggerCalendarChange,
		triggerOk
	];
}
function useRangeValue(info, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, open, isInvalidateDate) {
	var generateConfig = info.generateConfig, locale = info.locale, picker = info.picker, onChange = info.onChange, allowEmpty = info.allowEmpty, order = info.order;
	var orderOnChange = disabled.some(function(d) {
		return d;
	}) ? false : order;
	// ============================= Util =============================
	var _useUtil3 = useUtil(generateConfig, locale, formatList), _useUtil4 = _slicedToArray$k(_useUtil3, 2), getDateTexts = _useUtil4[0], isSameDates = _useUtil4[1];
	// ============================ Values ============================
	// Used for trigger `onChange` event.
	// Record current value which is wait for submit.
	var _useSyncState3 = useSyncState(mergedValue), _useSyncState4 = _slicedToArray$k(_useSyncState3, 2), submitValue = _useSyncState4[0], setSubmitValue = _useSyncState4[1];
	/** Sync calendarValue & submitValue back with value */
	var syncWithValue = useEvent(function() {
		setSubmitValue(mergedValue);
	});
	reactExports.useEffect(function() {
		syncWithValue();
	}, [mergedValue]);
	// ============================ Submit ============================
	var triggerSubmit = useEvent(function(nextValue) {
		var isNullValue = nextValue === null;
		var clone = _toConsumableArray$6(nextValue || submitValue());
		// Fill null value
		if (isNullValue) {
			var maxLen = Math.max(disabled.length, clone.length);
			for (var i = 0; i < maxLen; i += 1) {
				if (!disabled[i]) {
					clone[i] = null;
				}
			}
		}
		// Only when exist value to sort
		if (orderOnChange && clone[0] && clone[1]) {
			clone = orderDates(clone, generateConfig);
		}
		// Sync `calendarValue`
		triggerCalendarChange(clone);
		// ========= Validate check =========
		var _clone = clone, _clone2 = _slicedToArray$k(_clone, 2), start = _clone2[0], end = _clone2[1];
		// >>> Empty
		var startEmpty = !start;
		var endEmpty = !end;
		var validateEmptyDateRange = allowEmpty ? (!startEmpty || allowEmpty[0]) && (!endEmpty || allowEmpty[1]) : true;
		// >>> Order
		var validateOrder = !order || startEmpty || endEmpty || isSame(generateConfig, locale, start, end, picker) || generateConfig.isAfter(end, start);
		// >>> Invalid
		var validateDates = (disabled[0] || !start || !isInvalidateDate(start, { activeIndex: 0 })) && (disabled[1] || !end || !isInvalidateDate(end, {
			from: start,
			activeIndex: 1
		}));
		// >>> Result
		var allPassed = isNullValue || validateEmptyDateRange && validateOrder && validateDates;
		if (allPassed) {
			// Sync value with submit value
			setInnerValue(clone);
			var _isSameDates3 = isSameDates(clone, mergedValue), _isSameDates4 = _slicedToArray$k(_isSameDates3, 1), isSameMergedDates = _isSameDates4[0];
			// Trigger `onChange` if needed
			if (onChange && !isSameMergedDates) {
				var everyEmpty = clone.every(function(val) {
					return !val;
				});
				onChange(
					// Return null directly if all date are empty
					isNullValue && everyEmpty ? null : clone,
					everyEmpty ? null : getDateTexts(clone)
				);
			}
		}
		return allPassed;
	});
	// ========================= Flush Submit =========================
	var flushSubmit = useEvent(function(index, needTriggerChange) {
		var nextSubmitValue = fillIndex(submitValue(), index, getCalendarValue()[index]);
		setSubmitValue(nextSubmitValue);
		if (needTriggerChange) {
			triggerSubmit();
		}
	});
	// ============================ Effect ============================
	// All finished action trigger after 2 frames
	var interactiveFinished = !focused && !open;
	useLockEffect(!interactiveFinished, function() {
		if (interactiveFinished) {
			// Always try to trigger submit first
			triggerSubmit();
			// Trigger calendar change since this is a effect reset
			// https://github.com/ant-design/ant-design/issues/22351
			triggerCalendarChange(mergedValue);
			// Sync with value anyway
			syncWithValue();
		}
	}, 2);
	// ============================ Return ============================
	return [flushSubmit, triggerSubmit];
}
function useShowNow(picker, mode, showNow, showToday, rangePicker) {
	if (mode !== "date" && mode !== "time") {
		return false;
	}
	if (showNow !== void 0) {
		return showNow;
	}
	// Compatible with old version `showToday`
	if (showToday !== void 0) {
		return showToday;
	}
	return !rangePicker && (picker === "date" || picker === "time");
}
function _toConsumableArray$5(arr) {
	return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$l(arr) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$l(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$l(o);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$l(o);
}
function _iterableToArray$5(iter) {
	if (iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$5(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$l(arr);
}
function _arrayLikeToArray$l(arr, len) {
	{
		len = arr.length;
	}
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function findValidateTime(date, getHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits, generateConfig) {
	var nextDate = date;
	function alignValidate(getUnitValue, setUnitValue, units) {
		var nextValue = generateConfig[getUnitValue](nextDate);
		var nextUnit = units.find(function(unit) {
			return unit.value === nextValue;
		});
		if (!nextUnit || nextUnit.disabled) {
			// Find most closest unit
			var validateUnits = units.filter(function(unit) {
				return !unit.disabled;
			});
			var reverseEnabledUnits = _toConsumableArray$5(validateUnits).reverse();
			var validateUnit = reverseEnabledUnits.find(function(unit) {
				return unit.value <= nextValue;
			}) || validateUnits[0];
			if (validateUnit) {
				nextValue = validateUnit.value;
				nextDate = generateConfig[setUnitValue](nextDate, nextValue);
			}
		}
		return nextValue;
	}
	// Find validate hour
	var nextHour = alignValidate("getHour", "setHour", getHourUnits());
	// Find validate minute
	var nextMinute = alignValidate("getMinute", "setMinute", getMinuteUnits(nextHour));
	// Find validate second
	var nextSecond = alignValidate("getSecond", "setSecond", getSecondUnits(nextHour, nextMinute));
	// Find validate millisecond
	alignValidate("getMillisecond", "setMillisecond", getMillisecondUnits(nextHour, nextMinute, nextSecond));
	return nextDate;
}
function _typeof$j(o) {
	"@babel/helpers - typeof";
	return _typeof$j = function(o) {
		return typeof o;
	}, _typeof$j(o);
}
function ownKeys$a(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$a(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$a(Object(t), true).forEach(function(r) {
			_defineProperty$j(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$j(obj, key, value) {
	key = _toPropertyKey$j(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$j(t) {
	var i = _toPrimitive$j(t);
	return "symbol" == _typeof$j(i) ? i : String(i);
}
function _toPrimitive$j(t) {
	if ("object" != _typeof$j(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$j(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$j(arr) {
	return _arrayWithHoles$j(arr) || _iterableToArrayLimit$j(arr) || _unsupportedIterableToArray$k(arr) || _nonIterableRest$j();
}
function _nonIterableRest$j() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$k(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$k(o, 4);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$k(o, 4);
}
function _arrayLikeToArray$k(arr, len) {
	if (4 == null || 4 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$j(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 4); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$j(arr) {
	if (Array.isArray(arr)) return arr;
}
function emptyDisabled() {
	return [];
}
function generateUnits(start, end) {
	var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
	var hideDisabledOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	var disabledUnits = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
	var pad = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;
	var units = [];
	var integerStep = step >= 1 ? step | 0 : 1;
	for (var i = start; i <= end; i += integerStep) {
		var disabled = disabledUnits.includes(i);
		if (!disabled || !hideDisabledOptions) {
			units.push({
				label: leftPad(i, pad),
				value: i,
				disabled
			});
		}
	}
	return units;
}
/**
* Parse time props to get util info
*/
function useTimeInfo(generateConfig) {
	var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	var date = arguments.length > 2 ? arguments[2] : void 0;
	var _ref = props || {}, use12Hours = _ref.use12Hours, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep, _ref$millisecondStep = _ref.millisecondStep, millisecondStep = _ref$millisecondStep === void 0 ? 100 : _ref$millisecondStep, hideDisabledOptions = _ref.hideDisabledOptions, disabledTime = _ref.disabledTime, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds;
	var mergedDate = reactExports.useMemo(function() {
		return date || generateConfig.getNow();
	}, [date, generateConfig]);
	// ======================== Disabled ========================
	var getDisabledTimes = reactExports.useCallback(function(targetDate) {
		var disabledConfig = (disabledTime === null || disabledTime === void 0 ? void 0 : disabledTime(targetDate)) || {};
		return [
			disabledConfig.disabledHours || disabledHours || emptyDisabled,
			disabledConfig.disabledMinutes || disabledMinutes || emptyDisabled,
			disabledConfig.disabledSeconds || disabledSeconds || emptyDisabled,
			disabledConfig.disabledMilliseconds || emptyDisabled
		];
	}, [
		disabledTime,
		disabledHours,
		disabledMinutes,
		disabledSeconds
	]);
	var _React$useMemo = reactExports.useMemo(function() {
		return getDisabledTimes(mergedDate);
	}, [mergedDate, getDisabledTimes]), _React$useMemo2 = _slicedToArray$j(_React$useMemo), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2], mergedDisabledMilliseconds = _React$useMemo2[3];
	// ========================= Column =========================
	var getAllUnits = reactExports.useCallback(function(getDisabledHours, getDisabledMinutes, getDisabledSeconds, getDisabledMilliseconds) {
		var hours = generateUnits(0, 23, hourStep, hideDisabledOptions, getDisabledHours());
		// Hours
		var rowHourUnits = use12Hours ? hours.map(function(unit) {
			return _objectSpread$a(_objectSpread$a({}, unit), {}, { label: leftPad(unit.value % 12 || 12, 2) });
		}) : hours;
		// Minutes
		var getMinuteUnits = function(nextHour) {
			return generateUnits(0, 59, minuteStep, hideDisabledOptions, getDisabledMinutes(nextHour));
		};
		// Seconds
		var getSecondUnits = function(nextHour, nextMinute) {
			return generateUnits(0, 59, secondStep, hideDisabledOptions, getDisabledSeconds(nextHour, nextMinute));
		};
		// Milliseconds
		var getMillisecondUnits = function(nextHour, nextMinute, nextSecond) {
			return generateUnits(0, 999, millisecondStep, hideDisabledOptions, getDisabledMilliseconds(nextHour, nextMinute, nextSecond), 3);
		};
		return [
			rowHourUnits,
			getMinuteUnits,
			getSecondUnits,
			getMillisecondUnits
		];
	}, [
		hideDisabledOptions,
		hourStep,
		use12Hours,
		millisecondStep,
		minuteStep,
		secondStep
	]);
	var _React$useMemo3 = reactExports.useMemo(function() {
		return getAllUnits(mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds);
	}, [
		getAllUnits,
		mergedDisabledHours,
		mergedDisabledMinutes,
		mergedDisabledSeconds,
		mergedDisabledMilliseconds
	]), _React$useMemo4 = _slicedToArray$j(_React$useMemo3), rowHourUnits = _React$useMemo4[0], getMinuteUnits = _React$useMemo4[1], getSecondUnits = _React$useMemo4[2], getMillisecondUnits = _React$useMemo4[3];
	// ======================== Validate ========================
	/**
	* Get validate time with `disabledTime`, `certainDate` to specific the date need to check
	*/
	var getValidTime = function(nextTime, certainDate) {
		var getCheckHourUnits = function() {
			return rowHourUnits;
		};
		var getCheckMinuteUnits = getMinuteUnits;
		var getCheckSecondUnits = getSecondUnits;
		var getCheckMillisecondUnits = getMillisecondUnits;
		if (certainDate) {
			var _getDisabledTimes = getDisabledTimes(certainDate), _getDisabledTimes2 = _slicedToArray$j(_getDisabledTimes), targetDisabledHours = _getDisabledTimes2[0], targetDisabledMinutes = _getDisabledTimes2[1], targetDisabledSeconds = _getDisabledTimes2[2], targetDisabledMilliseconds = _getDisabledTimes2[3];
			var _getAllUnits = getAllUnits(targetDisabledHours, targetDisabledMinutes, targetDisabledSeconds, targetDisabledMilliseconds), _getAllUnits2 = _slicedToArray$j(_getAllUnits), targetRowHourUnits = _getAllUnits2[0], targetGetMinuteUnits = _getAllUnits2[1], targetGetSecondUnits = _getAllUnits2[2], targetGetMillisecondUnits = _getAllUnits2[3];
			getCheckHourUnits = function() {
				return targetRowHourUnits;
			};
			getCheckMinuteUnits = targetGetMinuteUnits;
			getCheckSecondUnits = targetGetSecondUnits;
			getCheckMillisecondUnits = targetGetMillisecondUnits;
		}
		var validateDate = findValidateTime(nextTime, getCheckHourUnits, getCheckMinuteUnits, getCheckSecondUnits, getCheckMillisecondUnits, generateConfig);
		return validateDate;
	};
	return [
		getValidTime,
		rowHourUnits,
		getMinuteUnits,
		getSecondUnits,
		getMillisecondUnits
	];
}
function _slicedToArray$i(arr) {
	return _arrayWithHoles$i(arr) || _iterableToArrayLimit$i(arr) || _unsupportedIterableToArray$j(arr) || _nonIterableRest$i();
}
function _nonIterableRest$i() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$j(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$j(o, 1);
}
function _arrayLikeToArray$j(arr, len) {
	if (1 == null || 1 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$i(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 1); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$i(arr) {
	if (Array.isArray(arr)) return arr;
}
function Footer(props) {
	var mode = props.mode, internalMode = props.internalMode, renderExtraFooter = props.renderExtraFooter, showNow = props.showNow, showTime = props.showTime, onSubmit = props.onSubmit, onNow = props.onNow, invalid = props.invalid, needConfirm = props.needConfirm, generateConfig = props.generateConfig, disabledDate = props.disabledDate;
	var _React$useContext = reactExports.useContext(PickerContext$1), prefixCls = _React$useContext.prefixCls, locale = _React$useContext.locale, _React$useContext$but = _React$useContext.button, Button = _React$useContext$but === void 0 ? "button" : _React$useContext$but, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	// >>> Now
	var now = generateConfig.getNow();
	var _useTimeInfo = useTimeInfo(generateConfig, showTime, now), _useTimeInfo2 = _slicedToArray$i(_useTimeInfo), getValidTime = _useTimeInfo2[0];
	// ======================== Extra =========================
	var extraNode = renderExtraFooter === null || renderExtraFooter === void 0 ? void 0 : renderExtraFooter(mode);
	// ======================== Ranges ========================
	var nowDisabled = disabledDate(now, { type: mode });
	var onInternalNow = function() {
		if (!nowDisabled) {
			var validateNow = getValidTime(now);
			onNow(validateNow);
		}
	};
	var nowPrefixCls = "".concat(prefixCls, "-now");
	var nowBtnPrefixCls = "".concat(nowPrefixCls, "-btn");
	var presetNode = showNow && reactExports.createElement("li", { className: nowPrefixCls }, reactExports.createElement("a", {
		className: clsx(nowBtnPrefixCls, nowDisabled && "".concat(nowBtnPrefixCls, "-disabled")),
		"aria-disabled": nowDisabled,
		onClick: onInternalNow
	}, internalMode === "date" ? locale.today : locale.now));
	// >>> OK
	var okNode = needConfirm && reactExports.createElement("li", { className: "".concat(prefixCls, "-ok") }, reactExports.createElement(Button, {
		disabled: invalid,
		onClick: onSubmit
	}, locale.ok));
	var rangeNode = (presetNode || okNode) && reactExports.createElement("ul", { className: "".concat(prefixCls, "-ranges") }, presetNode, okNode);
	// ======================== Render ========================
	if (!extraNode && !rangeNode) {
		return null;
	}
	return reactExports.createElement("div", {
		className: clsx("".concat(prefixCls, "-footer"), classNames.popup.footer),
		style: styles.popup.footer
	}, extraNode && reactExports.createElement("div", { className: "".concat(prefixCls, "-footer-extra") }, extraNode), rangeNode);
}
function _toConsumableArray$4(arr) {
	return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$i(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$i(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$i(o);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o);
}
function _iterableToArray$4(iter) {
	if (iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$i(arr);
}
function _arrayLikeToArray$i(arr, len) {
	{
		len = arr.length;
	}
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
/**
* Toggles the presence of a value in an array.
* If the value exists in the array, removed it.
* Else add it.
*/
function useToggleDates(generateConfig, locale, panelMode) {
	function toggleDates(list, target) {
		var index = list.findIndex(function(date) {
			return isSame(generateConfig, locale, date, target, panelMode);
		});
		if (index === -1) {
			return [].concat(_toConsumableArray$4(list), [target]);
		}
		var sliceList = _toConsumableArray$4(list);
		sliceList.splice(index, 1);
		return sliceList;
	}
	return toggleDates;
}
var SharedPanelContext = reactExports.createContext(null);
/** Used for each single Panel. e.g. DatePanel */
var PanelContext = reactExports.createContext(null);
function usePanelContext() {
	return reactExports.useContext(PanelContext);
}
/**
* Get shared props for the SharedPanelProps interface.
*/
function useInfo(props, panelType) {
	// TODO: this is not good to get from each props.
	// Should move to `SharedPanelContext` instead.
	var prefixCls = props.prefixCls, generateConfig = props.generateConfig, locale = props.locale, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, cellRender = props.cellRender, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, onHover = props.onHover, values = props.values, pickerValue = props.pickerValue, onSelect = props.onSelect, prevIcon = props.prevIcon, nextIcon = props.nextIcon, superPrevIcon = props.superPrevIcon, superNextIcon = props.superNextIcon;
	// ======================= Context ========================
	var _React$useContext = reactExports.useContext(SharedPanelContext), classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	// ========================= MISC =========================
	var now = generateConfig.getNow();
	// ========================= Info =========================
	var info = {
		now,
		values,
		pickerValue,
		prefixCls,
		classNames,
		styles,
		disabledDate,
		minDate,
		maxDate,
		cellRender,
		hoverValue,
		hoverRangeValue,
		onHover,
		locale,
		generateConfig,
		onSelect,
		panelType,
		prevIcon,
		nextIcon,
		superPrevIcon,
		superNextIcon
	};
	return [info, now];
}
// ============================== Internal ==============================
/**
* Internal usage for RangePicker to not to show the operation arrow
*/
var PickerHackContext = reactExports.createContext({});
function _typeof$i(o) {
	"@babel/helpers - typeof";
	return _typeof$i = function(o) {
		return typeof o;
	}, _typeof$i(o);
}
function ownKeys$9(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$9(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$9(Object(t), true).forEach(function(r) {
			_defineProperty$i(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$i(obj, key, value) {
	key = _toPropertyKey$i(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$i(t) {
	var i = _toPrimitive$i(t);
	return "symbol" == _typeof$i(i) ? i : String(i);
}
function _toPrimitive$i(t) {
	if ("object" != _typeof$i(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$i(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$h(arr) {
	return _arrayWithHoles$h(arr) || _iterableToArrayLimit$h(arr) || _unsupportedIterableToArray$h(arr) || _nonIterableRest$h();
}
function _nonIterableRest$h() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$h(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$h(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, 2);
}
function _arrayLikeToArray$h(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$h(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$h(arr) {
	if (Array.isArray(arr)) return arr;
}
function PanelBody(props) {
	var rowNum = props.rowNum, colNum = props.colNum, baseDate = props.baseDate, getCellDate = props.getCellDate, prefixColumn = props.prefixColumn, rowClassName = props.rowClassName, titleFormat = props.titleFormat, getCellText = props.getCellText, getCellClassName = props.getCellClassName, headerCells = props.headerCells, _props$cellSelection = props.cellSelection, cellSelection = _props$cellSelection === void 0 ? true : _props$cellSelection, disabledDate = props.disabledDate;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, type = _usePanelContext.panelType, now = _usePanelContext.now, contextDisabledDate = _usePanelContext.disabledDate, cellRender = _usePanelContext.cellRender, onHover = _usePanelContext.onHover, hoverValue = _usePanelContext.hoverValue, hoverRangeValue = _usePanelContext.hoverRangeValue, generateConfig = _usePanelContext.generateConfig, values = _usePanelContext.values, locale = _usePanelContext.locale, onSelect = _usePanelContext.onSelect;
	var mergedDisabledDate = disabledDate || contextDisabledDate;
	var cellPrefixCls = "".concat(prefixCls, "-cell");
	// ============================= Context ==============================
	var _React$useContext = reactExports.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
	// ============================== Value ===============================
	var matchValues = function(date) {
		return values.some(function(singleValue) {
			return singleValue && isSame(generateConfig, locale, date, singleValue, type);
		});
	};
	// =============================== Body ===============================
	var rows = [];
	for (var row = 0; row < rowNum; row += 1) {
		var rowNode = [];
		var rowStartDate = void 0;
		var _loop = function() {
			var offset = row * colNum + col;
			var currentDate = getCellDate(baseDate, offset);
			var disabled = mergedDisabledDate === null || mergedDisabledDate === void 0 ? void 0 : mergedDisabledDate(currentDate, { type });
			// Row Start Cell
			if (col === 0) {
				rowStartDate = currentDate;
				if (prefixColumn) {
					rowNode.push(prefixColumn(rowStartDate));
				}
			}
			// Range
			var inRange = false;
			var rangeStart = false;
			var rangeEnd = false;
			if (cellSelection && hoverRangeValue) {
				var _hoverRangeValue = _slicedToArray$h(hoverRangeValue), hoverStart = _hoverRangeValue[0], hoverEnd = _hoverRangeValue[1];
				inRange = isInRange(generateConfig, hoverStart, hoverEnd, currentDate);
				rangeStart = isSame(generateConfig, locale, currentDate, hoverStart, type);
				rangeEnd = isSame(generateConfig, locale, currentDate, hoverEnd, type);
			}
			// Title
			var title = titleFormat ? formatValue(currentDate, {
				b: locale,
				c: titleFormat,
				a: generateConfig
			}) : void 0;
			// Render
			var inner = reactExports.createElement("div", { className: "".concat(cellPrefixCls, "-inner") }, getCellText(currentDate));
			rowNode.push(reactExports.createElement("td", {
				key: col,
				title,
				className: clsx(cellPrefixCls, classNames.item, _objectSpread$9(_defineProperty$i(_defineProperty$i(_defineProperty$i(_defineProperty$i(_defineProperty$i(_defineProperty$i({}, "".concat(cellPrefixCls, "-disabled"), disabled), "".concat(cellPrefixCls, "-hover"), (hoverValue || []).some(function(date) {
					return isSame(generateConfig, locale, currentDate, date, type);
				})), "".concat(cellPrefixCls, "-in-range"), inRange && !rangeStart && !rangeEnd), "".concat(cellPrefixCls, "-range-start"), rangeStart), "".concat(cellPrefixCls, "-range-end"), rangeEnd), "".concat(prefixCls, "-cell-selected"), !hoverRangeValue && type !== "week" && matchValues(currentDate)), getCellClassName(currentDate))),
				style: styles.item,
				onClick: function() {
					if (!disabled) {
						onSelect(currentDate);
					}
				},
				onDoubleClick: function() {
					if (!disabled && onCellDblClick) {
						onCellDblClick();
					}
				},
				onMouseEnter: function() {
					if (!disabled) {
						onHover === null || onHover === void 0 || onHover(currentDate);
					}
				},
				onMouseLeave: function() {
					if (!disabled) {
						onHover === null || onHover === void 0 || onHover(null);
					}
				}
			}, cellRender ? cellRender(currentDate, {
				prefixCls,
				originNode: inner,
				today: now,
				type,
				locale
			}) : inner));
		};
		for (var col = 0; col < colNum; col += 1) {
			_loop();
		}
		rows.push(reactExports.createElement("tr", {
			key: row,
			className: rowClassName === null || rowClassName === void 0 ? void 0 : rowClassName(rowStartDate)
		}, rowNode));
	}
	// ============================== Render ==============================
	return reactExports.createElement("div", {
		className: clsx("".concat(prefixCls, "-body"), classNames.body),
		style: styles.body
	}, reactExports.createElement("table", {
		className: clsx("".concat(prefixCls, "-content"), classNames.content),
		style: styles.content
	}, headerCells && reactExports.createElement("thead", null, reactExports.createElement("tr", null, headerCells)), reactExports.createElement("tbody", null, rows)));
}
var HIDDEN_STYLE = { visibility: "hidden" };
function PanelHeader(props) {
	var offset = props.offset, superOffset = props.superOffset, onChange = props.onChange, getStart = props.getStart, getEnd = props.getEnd, children = props.children;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, _usePanelContext$prev = _usePanelContext.prevIcon, prevIcon = _usePanelContext$prev === void 0 ? "" : _usePanelContext$prev, _usePanelContext$next = _usePanelContext.nextIcon, nextIcon = _usePanelContext$next === void 0 ? "" : _usePanelContext$next, _usePanelContext$supe = _usePanelContext.superPrevIcon, superPrevIcon = _usePanelContext$supe === void 0 ? "" : _usePanelContext$supe, _usePanelContext$supe2 = _usePanelContext.superNextIcon, superNextIcon = _usePanelContext$supe2 === void 0 ? "" : _usePanelContext$supe2, minDate = _usePanelContext.minDate, maxDate = _usePanelContext.maxDate, generateConfig = _usePanelContext.generateConfig, locale = _usePanelContext.locale, pickerValue = _usePanelContext.pickerValue, type = _usePanelContext.panelType;
	var headerPrefixCls = "".concat(prefixCls, "-header");
	var _React$useContext = reactExports.useContext(PickerHackContext), hidePrev = _React$useContext.hidePrev, hideNext = _React$useContext.hideNext, hideHeader = _React$useContext.hideHeader;
	// ======================= Limitation =======================
	var disabledOffsetPrev = reactExports.useMemo(function() {
		if (!minDate || !offset || !getEnd) {
			return false;
		}
		var prevPanelLimitDate = getEnd(offset(-1, pickerValue));
		return !isSameOrAfter(generateConfig, locale, prevPanelLimitDate, minDate, type);
	}, [
		minDate,
		offset,
		pickerValue,
		getEnd,
		generateConfig,
		locale,
		type
	]);
	var disabledSuperOffsetPrev = reactExports.useMemo(function() {
		if (!minDate || !superOffset || !getEnd) {
			return false;
		}
		var prevPanelLimitDate = getEnd(superOffset(-1, pickerValue));
		return !isSameOrAfter(generateConfig, locale, prevPanelLimitDate, minDate, type);
	}, [
		minDate,
		superOffset,
		pickerValue,
		getEnd,
		generateConfig,
		locale,
		type
	]);
	var disabledOffsetNext = reactExports.useMemo(function() {
		if (!maxDate || !offset || !getStart) {
			return false;
		}
		var nextPanelLimitDate = getStart(offset(1, pickerValue));
		return !isSameOrAfter(generateConfig, locale, maxDate, nextPanelLimitDate, type);
	}, [
		maxDate,
		offset,
		pickerValue,
		getStart,
		generateConfig,
		locale,
		type
	]);
	var disabledSuperOffsetNext = reactExports.useMemo(function() {
		if (!maxDate || !superOffset || !getStart) {
			return false;
		}
		var nextPanelLimitDate = getStart(superOffset(1, pickerValue));
		return !isSameOrAfter(generateConfig, locale, maxDate, nextPanelLimitDate, type);
	}, [
		maxDate,
		superOffset,
		pickerValue,
		getStart,
		generateConfig,
		locale,
		type
	]);
	// ========================= Offset =========================
	var onOffset = function(distance) {
		if (offset) {
			onChange(offset(distance, pickerValue));
		}
	};
	var onSuperOffset = function(distance) {
		if (superOffset) {
			onChange(superOffset(distance, pickerValue));
		}
	};
	// ========================= Render =========================
	if (hideHeader) {
		return null;
	}
	var prevBtnCls = "".concat(headerPrefixCls, "-prev-btn");
	var nextBtnCls = "".concat(headerPrefixCls, "-next-btn");
	var superPrevBtnCls = "".concat(headerPrefixCls, "-super-prev-btn");
	var superNextBtnCls = "".concat(headerPrefixCls, "-super-next-btn");
	return reactExports.createElement("div", {
		className: clsx(headerPrefixCls, classNames.header),
		style: styles.header
	}, superOffset && reactExports.createElement("button", {
		type: "button",
		"aria-label": locale.previousYear,
		onClick: function() {
			return onSuperOffset(-1), void 0;
		},
		tabIndex: -1,
		className: clsx(superPrevBtnCls, disabledSuperOffsetPrev && "".concat(superPrevBtnCls, "-disabled")),
		disabled: disabledSuperOffsetPrev,
		style: hidePrev ? HIDDEN_STYLE : {}
	}, superPrevIcon), offset && reactExports.createElement("button", {
		type: "button",
		"aria-label": locale.previousMonth,
		onClick: function() {
			return onOffset(-1), void 0;
		},
		tabIndex: -1,
		className: clsx(prevBtnCls, disabledOffsetPrev && "".concat(prevBtnCls, "-disabled")),
		disabled: disabledOffsetPrev,
		style: hidePrev ? HIDDEN_STYLE : {}
	}, prevIcon), reactExports.createElement("div", { className: "".concat(headerPrefixCls, "-view") }, children), offset && reactExports.createElement("button", {
		type: "button",
		"aria-label": locale.nextMonth,
		onClick: function() {
			return onOffset(1), void 0;
		},
		tabIndex: -1,
		className: clsx(nextBtnCls, disabledOffsetNext && "".concat(nextBtnCls, "-disabled")),
		disabled: disabledOffsetNext,
		style: hideNext ? HIDDEN_STYLE : {}
	}, nextIcon), superOffset && reactExports.createElement("button", {
		type: "button",
		"aria-label": locale.nextYear,
		onClick: function() {
			return onSuperOffset(1), void 0;
		},
		tabIndex: -1,
		className: clsx(superNextBtnCls, disabledSuperOffsetNext && "".concat(superNextBtnCls, "-disabled")),
		disabled: disabledSuperOffsetNext,
		style: hideNext ? HIDDEN_STYLE : {}
	}, superNextIcon));
}
function _typeof$h(o) {
	"@babel/helpers - typeof";
	return _typeof$h = function(o) {
		return typeof o;
	}, _typeof$h(o);
}
function _extends$j() {
	_extends$j = Object.assign.bind();
	return _extends$j.apply(this, arguments);
}
function _defineProperty$h(obj, key, value) {
	key = _toPropertyKey$h(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$h(t) {
	var i = _toPrimitive$h(t);
	return "symbol" == _typeof$h(i) ? i : String(i);
}
function _toPrimitive$h(t) {
	if ("object" != _typeof$h(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$h(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$g(arr) {
	return _arrayWithHoles$g(arr) || _iterableToArrayLimit$g(arr) || _unsupportedIterableToArray$g(arr) || _nonIterableRest$g();
}
function _nonIterableRest$g() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$g(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, 2);
}
function _arrayLikeToArray$g(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$g(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$g(arr) {
	if (Array.isArray(arr)) return arr;
}
function DatePanel(props) {
	var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, locale = props.locale, generateConfig = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, _props$mode = props.mode, mode = _props$mode === void 0 ? "date" : _props$mode, disabledDate = props.disabledDate, onSelect = props.onSelect, onHover = props.onHover, showWeek = props.showWeek;
	var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
	var cellPrefixCls = "".concat(prefixCls, "-cell");
	var isWeek = mode === "week";
	// ========================== Base ==========================
	var _useInfo = useInfo(props, mode), _useInfo2 = _slicedToArray$g(_useInfo), info = _useInfo2[0], now = _useInfo2[1];
	var weekFirstDay = generateConfig.locale.getWeekFirstDay(locale.locale);
	var monthStartDate = generateConfig.setDate(pickerValue, 1);
	var baseDate = getWeekStartDate(locale.locale, generateConfig, monthStartDate);
	var month = generateConfig.getMonth(pickerValue);
	// =========================== PrefixColumn ===========================
	var showPrefixColumn = showWeek === void 0 ? isWeek : showWeek;
	var prefixColumn = showPrefixColumn ? function(date) {
		// >>> Additional check for disabled
		var disabled = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date, { type: "week" });
		return reactExports.createElement("td", {
			key: "week",
			className: clsx(cellPrefixCls, "".concat(cellPrefixCls, "-week"), _defineProperty$h({}, "".concat(cellPrefixCls, "-disabled"), disabled)),
			onClick: function() {
				if (!disabled) {
					onSelect(date);
				}
			},
			onMouseEnter: function() {
				if (!disabled) {
					onHover === null || onHover === void 0 || onHover(date);
				}
			},
			onMouseLeave: function() {
				if (!disabled) {
					onHover === null || onHover === void 0 || onHover(null);
				}
			}
		}, reactExports.createElement("div", { className: "".concat(cellPrefixCls, "-inner") }, generateConfig.locale.getWeek(locale.locale, date)));
	} : null;
	// ========================= Cells ==========================
	// >>> Header Cells
	var headerCells = [];
	var weekDaysLocale = locale.shortWeekDays || (generateConfig.locale.getShortWeekDays ? generateConfig.locale.getShortWeekDays(locale.locale) : []);
	if (prefixColumn) {
		headerCells.push(reactExports.createElement("th", { key: "empty" }, reactExports.createElement("span", { style: {
			width: 0,
			height: 0,
			position: "absolute",
			overflow: "hidden",
			opacity: 0
		} }, locale.week)));
	}
	for (var i = 0; i < 7; i += 1) {
		headerCells.push(reactExports.createElement("th", { key: i }, weekDaysLocale[(i + weekFirstDay) % 7]));
	}
	// >>> Body Cells
	var getCellDate = function(date, offset) {
		return generateConfig.addDate(date, offset);
	};
	var getCellText = function(date) {
		return formatValue(date, {
			b: locale,
			c: locale.cellDateFormat,
			a: generateConfig
		});
	};
	var getCellClassName = function(date) {
		var classObj = _defineProperty$h(_defineProperty$h({}, "".concat(prefixCls, "-cell-in-view"), isSameMonth(generateConfig, date, pickerValue)), "".concat(prefixCls, "-cell-today"), isSameDate(generateConfig, date, now));
		return classObj;
	};
	// ========================= Header =========================
	var monthsLocale = locale.shortMonths || (generateConfig.locale.getShortMonths ? generateConfig.locale.getShortMonths(locale.locale) : []);
	var yearNode = reactExports.createElement("button", {
		type: "button",
		"aria-label": locale.yearSelect,
		key: "year",
		onClick: function() {
			onModeChange("year", pickerValue);
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-year-btn")
	}, formatValue(pickerValue, {
		b: locale,
		c: locale.yearFormat,
		a: generateConfig
	}));
	var monthNode = reactExports.createElement("button", {
		type: "button",
		"aria-label": locale.monthSelect,
		key: "month",
		onClick: function() {
			onModeChange("month", pickerValue);
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-month-btn")
	}, locale.monthFormat ? formatValue(pickerValue, {
		b: locale,
		c: locale.monthFormat,
		a: generateConfig
	}) : monthsLocale[month]);
	var monthYearNodes = locale.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
	// ========================= Render =========================
	return reactExports.createElement(PanelContext.Provider, { value: info }, reactExports.createElement("div", { className: clsx(panelPrefixCls, showWeek && "".concat(panelPrefixCls, "-show-week")) }, reactExports.createElement(PanelHeader, {
		offset: function(distance) {
			return generateConfig.addMonth(pickerValue, distance);
		},
		superOffset: function(distance) {
			return generateConfig.addYear(pickerValue, distance);
		},
		onChange: onPickerValueChange,
		getStart: function(date) {
			return generateConfig.setDate(date, 1);
		},
		getEnd: function(date) {
			var clone = generateConfig.setDate(date, 1);
			clone = generateConfig.addMonth(clone, 1);
			return generateConfig.addDate(clone, -1);
		}
	}, monthYearNodes), reactExports.createElement(PanelBody, _extends$j({ titleFormat: locale.fieldDateFormat }, props, {
		colNum: 7,
		rowNum: 6,
		baseDate,
		headerCells,
		getCellDate,
		getCellText,
		getCellClassName,
		prefixColumn,
		cellSelection: !isWeek
	}))));
}
var SPEED_PTG = 1 / 3;
function useScrollTo(ulRef, value) {
	// ========================= Scroll =========================
	var scrollingRef = reactExports.useRef(false);
	var scrollRafRef = reactExports.useRef(null);
	var scrollDistRef = reactExports.useRef(null);
	var isScrolling = function() {
		return scrollingRef.current;
	};
	var stopScroll = function() {
		wrapperRaf.a(scrollRafRef.current);
		scrollingRef.current = false;
	};
	var scrollRafTimesRef = reactExports.useRef();
	var startScroll = function() {
		var ul = ulRef.current;
		scrollDistRef.current = null;
		scrollRafTimesRef.current = 0;
		if (ul) {
			var targetLi = ul.querySelector("[data-value=\"".concat(value, "\"]"));
			var firstLi = ul.querySelector("li");
			var doScroll = function doScroll() {
				stopScroll();
				scrollingRef.current = true;
				scrollRafTimesRef.current += 1;
				var currentTop = ul.scrollTop;
				var firstLiTop = firstLi.offsetTop;
				var targetLiTop = targetLi.offsetTop;
				var targetTop = targetLiTop - firstLiTop;
				// Wait for element exist. 5 frames is enough
				if (targetLiTop === 0 && targetLi !== firstLi || !isVisible(ul)) {
					if (scrollRafTimesRef.current <= 5) {
						scrollRafRef.current = wrapperRaf(doScroll);
					}
					return;
				}
				var nextTop = currentTop + (targetTop - currentTop) * SPEED_PTG;
				var dist = Math.abs(targetTop - nextTop);
				// Break if dist get larger, which means user is scrolling
				if (scrollDistRef.current !== null && scrollDistRef.current < dist) {
					stopScroll();
					return;
				}
				scrollDistRef.current = dist;
				// Stop when dist is less than 1
				if (dist <= 1) {
					ul.scrollTop = targetTop;
					stopScroll();
					return;
				}
				// IE not support `scrollTo`
				ul.scrollTop = nextTop;
				scrollRafRef.current = wrapperRaf(doScroll);
			};
			if (targetLi && firstLi) {
				doScroll();
			}
		}
	};
	// ======================== Trigger =========================
	var syncScroll = useEvent(startScroll);
	return [
		syncScroll,
		stopScroll,
		isScrolling
	];
}
function _typeof$g(o) {
	"@babel/helpers - typeof";
	return _typeof$g = function(o) {
		return typeof o;
	}, _typeof$g(o);
}
function _defineProperty$g(obj, key, value) {
	key = _toPropertyKey$g(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$g(t) {
	var i = _toPrimitive$g(t);
	return "symbol" == _typeof$g(i) ? i : String(i);
}
function _toPrimitive$g(t) {
	if ("object" != _typeof$g(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$g(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _toConsumableArray$3(arr) {
	return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$f(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$3(iter) {
	if (iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$f(arr);
}
function _slicedToArray$f(arr) {
	return _arrayWithHoles$f(arr) || _iterableToArrayLimit$f(arr) || _unsupportedIterableToArray$f(arr, 3) || _nonIterableRest$f();
}
function _nonIterableRest$f() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$f(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$f(o, void 0);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen);
}
function _arrayLikeToArray$f(arr, len) {
	if (len == null || 3 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$f(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 3); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$f(arr) {
	if (Array.isArray(arr)) return arr;
}
// Not use JSON.stringify to avoid dead loop
function flattenUnits(units) {
	return units.map(function(_ref) {
		var value = _ref.value, label = _ref.label, disabled = _ref.disabled;
		return [
			value,
			label,
			disabled
		].join(",");
	}).join(";");
}
function TimeColumn(props) {
	var units = props.units, value = props.value, optionalValue = props.optionalValue, type = props.type, onChange = props.onChange, onHover = props.onHover, onDblClick = props.onDblClick, changeOnScroll = props.changeOnScroll;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, cellRender = _usePanelContext.cellRender, now = _usePanelContext.now, locale = _usePanelContext.locale, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles;
	var panelPrefixCls = "".concat(prefixCls, "-time-panel");
	var cellPrefixCls = "".concat(prefixCls, "-time-panel-cell");
	// ========================== Refs ==========================
	var ulRef = reactExports.useRef(null);
	// ========================= Scroll =========================
	var checkDelayRef = reactExports.useRef();
	var clearDelayCheck = function() {
		clearTimeout(checkDelayRef.current);
	};
	// ========================== Sync ==========================
	var _useScrollTo = useScrollTo(ulRef, value !== null && value !== void 0 ? value : optionalValue), _useScrollTo2 = _slicedToArray$f(_useScrollTo), syncScroll = _useScrollTo2[0], stopScroll = _useScrollTo2[1], isScrolling = _useScrollTo2[2];
	// Effect sync value scroll
	useLayoutEffect(function() {
		syncScroll();
		clearDelayCheck();
		return function() {
			stopScroll();
			clearDelayCheck();
		};
	}, [
		value,
		optionalValue,
		flattenUnits(units)
	]);
	// ========================= Change =========================
	// Scroll event if sync onScroll
	var onInternalScroll = function(event) {
		clearDelayCheck();
		var target = event.target;
		if (!isScrolling() && changeOnScroll) {
			checkDelayRef.current = setTimeout(function() {
				var ul = ulRef.current;
				var firstLiTop = ul.querySelector("li").offsetTop;
				var liList = Array.from(ul.querySelectorAll("li"));
				var liTopList = liList.map(function(li) {
					return li.offsetTop - firstLiTop;
				});
				var liDistList = liTopList.map(function(top, index) {
					if (units[index].disabled) {
						return Number.MAX_SAFE_INTEGER;
					}
					return Math.abs(top - target.scrollTop);
				});
				// Find min distance index
				var minDist = Math.min.apply(Math, _toConsumableArray$3(liDistList));
				var minDistIndex = liDistList.findIndex(function(dist) {
					return dist === minDist;
				});
				var targetUnit = units[minDistIndex];
				if (targetUnit && !targetUnit.disabled) {
					onChange(targetUnit.value);
				}
			}, 300);
		}
	};
	// ========================= Render =========================
	var columnPrefixCls = "".concat(panelPrefixCls, "-column");
	return reactExports.createElement("ul", {
		className: columnPrefixCls,
		ref: ulRef,
		"data-type": type,
		onScroll: onInternalScroll
	}, units.map(function(_ref2) {
		var label = _ref2.label, unitValue = _ref2.value, disabled = _ref2.disabled;
		var inner = reactExports.createElement("div", { className: "".concat(cellPrefixCls, "-inner") }, label);
		return reactExports.createElement("li", {
			key: unitValue,
			style: styles.item,
			className: clsx(cellPrefixCls, classNames.item, _defineProperty$g(_defineProperty$g({}, "".concat(cellPrefixCls, "-selected"), value === unitValue), "".concat(cellPrefixCls, "-disabled"), disabled)),
			onClick: function() {
				if (!disabled) {
					onChange(unitValue);
				}
			},
			onDoubleClick: function() {
				if (!disabled && onDblClick) {
					onDblClick();
				}
			},
			onMouseEnter: function() {
				onHover(unitValue);
			},
			onMouseLeave: function() {
				onHover(null);
			},
			"data-value": unitValue
		}, cellRender ? cellRender(unitValue, {
			prefixCls,
			originNode: inner,
			today: now,
			type: "time",
			subType: type,
			locale
		}) : inner);
	}));
}
function _extends$i() {
	_extends$i = Object.assign.bind();
	return _extends$i.apply(this, arguments);
}
function _slicedToArray$e(arr, i) {
	return _arrayWithHoles$e(arr) || _iterableToArrayLimit$e(arr, i) || _unsupportedIterableToArray$e(arr, i) || _nonIterableRest$e();
}
function _nonIterableRest$e() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$e(o, minLen) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen);
}
function _arrayLikeToArray$e(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$e(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$e(arr) {
	if (Array.isArray(arr)) return arr;
}
function isAM(hour) {
	return hour < 12;
}
function TimePanelBody(props) {
	var showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, showMillisecond = props.showMillisecond, showMeridiem = props.use12Hours, changeOnScroll = props.changeOnScroll;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, values = _usePanelContext.values, generateConfig = _usePanelContext.generateConfig, locale = _usePanelContext.locale, onSelect = _usePanelContext.onSelect, _usePanelContext$onHo = _usePanelContext.onHover, onHover = _usePanelContext$onHo === void 0 ? function() {} : _usePanelContext$onHo, pickerValue = _usePanelContext.pickerValue;
	var value = (values === null || values === void 0 ? void 0 : values[0]) || null;
	var _React$useContext = reactExports.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
	// ========================== Info ==========================
	var _useTimeInfo = useTimeInfo(generateConfig, props, value), _useTimeInfo2 = _slicedToArray$e(_useTimeInfo, 5), getValidTime = _useTimeInfo2[0], rowHourUnits = _useTimeInfo2[1], getMinuteUnits = _useTimeInfo2[2], getSecondUnits = _useTimeInfo2[3], getMillisecondUnits = _useTimeInfo2[4];
	// ========================= Value ==========================
	// PickerValue will tell which one to align on the top
	var getUnitValue = function(func) {
		var valueUnitVal = value && generateConfig[func](value);
		var pickerUnitValue = pickerValue && generateConfig[func](pickerValue);
		return [valueUnitVal, pickerUnitValue];
	};
	var _getUnitValue = getUnitValue("getHour"), _getUnitValue2 = _slicedToArray$e(_getUnitValue, 2), hour = _getUnitValue2[0], pickerHour = _getUnitValue2[1];
	var _getUnitValue3 = getUnitValue("getMinute"), _getUnitValue4 = _slicedToArray$e(_getUnitValue3, 2), minute = _getUnitValue4[0], pickerMinute = _getUnitValue4[1];
	var _getUnitValue5 = getUnitValue("getSecond"), _getUnitValue6 = _slicedToArray$e(_getUnitValue5, 2), second = _getUnitValue6[0], pickerSecond = _getUnitValue6[1];
	var _getUnitValue7 = getUnitValue("getMillisecond"), _getUnitValue8 = _slicedToArray$e(_getUnitValue7, 2), millisecond = _getUnitValue8[0], pickerMillisecond = _getUnitValue8[1];
	var meridiem = hour === null ? null : isAM(hour) ? "am" : "pm";
	// ========================= Column =========================
	// Hours
	var hourUnits = reactExports.useMemo(function() {
		if (!showMeridiem) {
			return rowHourUnits;
		}
		return isAM(hour) ? rowHourUnits.filter(function(h) {
			return isAM(h.value);
		}) : rowHourUnits.filter(function(h) {
			return !isAM(h.value);
		});
	}, [
		hour,
		rowHourUnits,
		showMeridiem
	]);
	// >>> Pick Fallback
	var getEnabled = function(units, val) {
		var _enabledUnits$;
		var enabledUnits = units.filter(function(unit) {
			return !unit.disabled;
		});
		return val !== null && val !== void 0 ? val : enabledUnits === null || enabledUnits === void 0 || (_enabledUnits$ = enabledUnits[0]) === null || _enabledUnits$ === void 0 ? void 0 : _enabledUnits$.value;
	};
	// >>> Minutes
	var validHour = getEnabled(rowHourUnits, hour);
	var minuteUnits = reactExports.useMemo(function() {
		return getMinuteUnits(validHour);
	}, [getMinuteUnits, validHour]);
	// >>> Seconds
	var validMinute = getEnabled(minuteUnits, minute);
	var secondUnits = reactExports.useMemo(function() {
		return getSecondUnits(validHour, validMinute);
	}, [
		getSecondUnits,
		validHour,
		validMinute
	]);
	// >>> Milliseconds
	var validSecond = getEnabled(secondUnits, second);
	var millisecondUnits = reactExports.useMemo(function() {
		return getMillisecondUnits(validHour, validMinute, validSecond);
	}, [
		getMillisecondUnits,
		validHour,
		validMinute,
		validSecond
	]);
	var validMillisecond = getEnabled(millisecondUnits, millisecond);
	// Meridiem
	var meridiemUnits = reactExports.useMemo(function() {
		if (!showMeridiem) {
			return [];
		}
		var base = generateConfig.getNow();
		var amDate = generateConfig.setHour(base, 6);
		var pmDate = generateConfig.setHour(base, 18);
		var formatMeridiem = function(date, defaultLabel) {
			var cellMeridiemFormat = locale.cellMeridiemFormat;
			return cellMeridiemFormat ? formatValue(date, {
				a: generateConfig,
				b: locale,
				c: cellMeridiemFormat
			}) : defaultLabel;
		};
		return [{
			label: formatMeridiem(amDate, "AM"),
			value: "am",
			disabled: rowHourUnits.every(function(h) {
				return h.disabled || !isAM(h.value);
			})
		}, {
			label: formatMeridiem(pmDate, "PM"),
			value: "pm",
			disabled: rowHourUnits.every(function(h) {
				return h.disabled || isAM(h.value);
			})
		}];
	}, [
		rowHourUnits,
		showMeridiem,
		generateConfig,
		locale
	]);
	// ========================= Change =========================
	/**
	* Check if time is validate or will match to validate one
	*/
	var triggerChange = function(nextDate) {
		var validateDate = getValidTime(nextDate);
		onSelect(validateDate);
	};
	// ========================= Column =========================
	// Create a template date for the trigger change event
	var triggerDateTmpl = reactExports.useMemo(function() {
		var tmpl = value || pickerValue || generateConfig.getNow();
		var isNotNull = function(num) {
			return num !== null && num !== void 0;
		};
		if (isNotNull(hour)) {
			tmpl = generateConfig.setHour(tmpl, hour);
			tmpl = generateConfig.setMinute(tmpl, minute);
			tmpl = generateConfig.setSecond(tmpl, second);
			tmpl = generateConfig.setMillisecond(tmpl, millisecond);
		} else if (isNotNull(pickerHour)) {
			tmpl = generateConfig.setHour(tmpl, pickerHour);
			tmpl = generateConfig.setMinute(tmpl, pickerMinute);
			tmpl = generateConfig.setSecond(tmpl, pickerSecond);
			tmpl = generateConfig.setMillisecond(tmpl, pickerMillisecond);
		} else if (isNotNull(validHour)) {
			tmpl = generateConfig.setHour(tmpl, validHour);
			tmpl = generateConfig.setMinute(tmpl, validMinute);
			tmpl = generateConfig.setSecond(tmpl, validSecond);
			tmpl = generateConfig.setMillisecond(tmpl, validMillisecond);
		}
		return tmpl;
	}, [
		value,
		pickerValue,
		hour,
		minute,
		second,
		millisecond,
		validHour,
		validMinute,
		validSecond,
		validMillisecond,
		pickerHour,
		pickerMinute,
		pickerSecond,
		pickerMillisecond,
		generateConfig
	]);
	// ===================== Columns Change =====================
	var fillColumnValue = function(val, func) {
		if (val === null) {
			return null;
		}
		return generateConfig[func](triggerDateTmpl, val);
	};
	var getNextHourTime = function(val) {
		return fillColumnValue(val, "setHour");
	};
	var getNextMinuteTime = function(val) {
		return fillColumnValue(val, "setMinute");
	};
	var getNextSecondTime = function(val) {
		return fillColumnValue(val, "setSecond");
	};
	var getNextMillisecondTime = function(val) {
		return fillColumnValue(val, "setMillisecond");
	};
	var getMeridiemTime = function(val) {
		if (val === null) {
			return null;
		}
		if (val === "am" && !isAM(hour)) {
			return generateConfig.setHour(triggerDateTmpl, hour - 12);
		} else if (val === "pm" && isAM(hour)) {
			return generateConfig.setHour(triggerDateTmpl, hour + 12);
		}
		return triggerDateTmpl;
	};
	var onHourChange = function(val) {
		triggerChange(getNextHourTime(val));
	};
	var onMinuteChange = function(val) {
		triggerChange(getNextMinuteTime(val));
	};
	var onSecondChange = function(val) {
		triggerChange(getNextSecondTime(val));
	};
	var onMillisecondChange = function(val) {
		triggerChange(getNextMillisecondTime(val));
	};
	var onMeridiemChange = function(val) {
		triggerChange(getMeridiemTime(val));
	};
	// ====================== Column Hover ======================
	var onHourHover = function(val) {
		onHover(getNextHourTime(val));
	};
	var onMinuteHover = function(val) {
		onHover(getNextMinuteTime(val));
	};
	var onSecondHover = function(val) {
		onHover(getNextSecondTime(val));
	};
	var onMillisecondHover = function(val) {
		onHover(getNextMillisecondTime(val));
	};
	var onMeridiemHover = function(val) {
		onHover(getMeridiemTime(val));
	};
	// ========================= Render =========================
	var sharedColumnProps = {
		onDblClick: onCellDblClick,
		changeOnScroll
	};
	return reactExports.createElement("div", {
		className: clsx("".concat(prefixCls, "-content"), classNames.content),
		style: styles.content
	}, showHour && reactExports.createElement(TimeColumn, _extends$i({
		units: hourUnits,
		value: hour,
		optionalValue: pickerHour,
		type: "hour",
		onChange: onHourChange,
		onHover: onHourHover
	}, sharedColumnProps)), showMinute && reactExports.createElement(TimeColumn, _extends$i({
		units: minuteUnits,
		value: minute,
		optionalValue: pickerMinute,
		type: "minute",
		onChange: onMinuteChange,
		onHover: onMinuteHover
	}, sharedColumnProps)), showSecond && reactExports.createElement(TimeColumn, _extends$i({
		units: secondUnits,
		value: second,
		optionalValue: pickerSecond,
		type: "second",
		onChange: onSecondChange,
		onHover: onSecondHover
	}, sharedColumnProps)), showMillisecond && reactExports.createElement(TimeColumn, _extends$i({
		units: millisecondUnits,
		value: millisecond,
		optionalValue: pickerMillisecond,
		type: "millisecond",
		onChange: onMillisecondChange,
		onHover: onMillisecondHover
	}, sharedColumnProps)), showMeridiem && reactExports.createElement(TimeColumn, _extends$i({
		units: meridiemUnits,
		value: meridiem,
		type: "meridiem",
		onChange: onMeridiemChange,
		onHover: onMeridiemHover
	}, sharedColumnProps)));
}
function _slicedToArray$d(arr) {
	return _arrayWithHoles$d(arr) || _iterableToArrayLimit$d(arr) || _unsupportedIterableToArray$d(arr) || _nonIterableRest$d();
}
function _nonIterableRest$d() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$d(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, 1);
}
function _arrayLikeToArray$d(arr, len) {
	if (1 == null || 1 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$d(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 1); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$d(arr) {
	if (Array.isArray(arr)) return arr;
}
function TimePanel(props) {
	var prefixCls = props.prefixCls, value = props.value, locale = props.locale, generateConfig = props.generateConfig, showTime = props.showTime;
	var _ref = showTime || {}, format = _ref.format;
	var panelPrefixCls = "".concat(prefixCls, "-time-panel");
	// ========================== Base ==========================
	var _useInfo = useInfo(props, "time"), _useInfo2 = _slicedToArray$d(_useInfo), info = _useInfo2[0];
	// ========================= Render =========================
	return reactExports.createElement(PanelContext.Provider, { value: info }, reactExports.createElement("div", { className: clsx(panelPrefixCls) }, reactExports.createElement(PanelHeader, null, value ? formatValue(value, {
		b: locale,
		c: format,
		a: generateConfig
	}) : "\xA0"), reactExports.createElement(TimePanelBody, showTime)));
}
function _extends$h() {
	_extends$h = Object.assign.bind();
	return _extends$h.apply(this, arguments);
}
function _slicedToArray$c(arr) {
	return _arrayWithHoles$c(arr) || _iterableToArrayLimit$c(arr) || _unsupportedIterableToArray$c(arr) || _nonIterableRest$c();
}
function _nonIterableRest$c() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$c(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, 1);
}
function _arrayLikeToArray$c(arr, len) {
	if (1 == null || 1 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$c(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 1); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$c(arr) {
	if (Array.isArray(arr)) return arr;
}
function DateTimePanel(props) {
	var prefixCls = props.prefixCls, generateConfig = props.generateConfig, showTime = props.showTime, onSelect = props.onSelect, value = props.value, pickerValue = props.pickerValue, onHover = props.onHover;
	var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
	// =============================== Time ===============================
	var _useTimeInfo = useTimeInfo(generateConfig, showTime), _useTimeInfo2 = _slicedToArray$c(_useTimeInfo), getValidTime = _useTimeInfo2[0];
	// Merge the time info from `value` or `pickerValue`
	var mergeTime = function(date) {
		if (value) {
			return fillTime(generateConfig, date, value);
		}
		return fillTime(generateConfig, date, pickerValue);
	};
	// ============================== Hover ===============================
	var onDateHover = function(date) {
		onHover === null || onHover === void 0 || onHover(date ? mergeTime(date) : date);
	};
	// ============================== Select ==============================
	var onDateSelect = function(date) {
		// Merge with current time
		var cloneDate = mergeTime(date);
		onSelect(getValidTime(cloneDate, cloneDate));
	};
	// ============================== Render ==============================
	return reactExports.createElement("div", { className: panelPrefixCls }, reactExports.createElement(DatePanel, _extends$h({}, props, {
		onSelect: onDateSelect,
		onHover: onDateHover
	})), reactExports.createElement(TimePanel, props));
}
function _typeof$f(o) {
	"@babel/helpers - typeof";
	return _typeof$f = function(o) {
		return typeof o;
	}, _typeof$f(o);
}
function _extends$g() {
	_extends$g = Object.assign.bind();
	return _extends$g.apply(this, arguments);
}
function _defineProperty$f(obj, key, value) {
	key = _toPropertyKey$f(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$f(t) {
	var i = _toPrimitive$f(t);
	return "symbol" == _typeof$f(i) ? i : String(i);
}
function _toPrimitive$f(t) {
	if ("object" != _typeof$f(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$f(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$b(arr) {
	return _arrayWithHoles$b(arr) || _iterableToArrayLimit$b(arr) || _unsupportedIterableToArray$b(arr) || _nonIterableRest$b();
}
function _nonIterableRest$b() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, 1);
}
function _arrayLikeToArray$b(arr, len) {
	if (1 == null || 1 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$b(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 1); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$b(arr) {
	if (Array.isArray(arr)) return arr;
}
function DecadePanel(props) {
	var prefixCls = props.prefixCls, locale = props.locale, generateConfig = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange;
	var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
	// ========================== Base ==========================
	var _useInfo = useInfo(props, "decade"), _useInfo2 = _slicedToArray$b(_useInfo), info = _useInfo2[0];
	var getStartYear = function(date) {
		var startYear = Math.floor(generateConfig.getYear(date) / 100) * 100;
		return generateConfig.setYear(date, startYear);
	};
	var getEndYear = function(date) {
		var startYear = getStartYear(date);
		return generateConfig.addYear(startYear, 99);
	};
	var startYearDate = getStartYear(pickerValue);
	var endYearDate = getEndYear(pickerValue);
	var baseDate = generateConfig.addYear(startYearDate, -10);
	// ========================= Cells ==========================
	var getCellDate = function(date, offset) {
		return generateConfig.addYear(date, offset * 10);
	};
	var getCellText = function(date) {
		var cellYearFormat = locale.cellYearFormat;
		var startYearStr = formatValue(date, {
			b: locale,
			c: cellYearFormat,
			a: generateConfig
		});
		var endYearStr = formatValue(generateConfig.addYear(date, 9), {
			b: locale,
			c: cellYearFormat,
			a: generateConfig
		});
		return "".concat(startYearStr, "-").concat(endYearStr);
	};
	var getCellClassName = function(date) {
		return _defineProperty$f({}, "".concat(prefixCls, "-cell-in-view"), isSameDecade(generateConfig, date, startYearDate) || isSameDecade(generateConfig, date, endYearDate) || isInRange(generateConfig, startYearDate, endYearDate, date));
	};
	// ======================== Disabled ========================
	var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
		// Start
		var baseStartDate = generateConfig.setDate(currentDate, 1);
		var baseStartMonth = generateConfig.setMonth(baseStartDate, 0);
		var baseStartYear = generateConfig.setYear(baseStartMonth, Math.floor(generateConfig.getYear(baseStartMonth) / 10) * 10);
		// End
		var baseEndYear = generateConfig.addYear(baseStartYear, 10);
		var baseEndDate = generateConfig.addDate(baseEndYear, -1);
		return disabledDate(baseStartYear, disabledInfo) && disabledDate(baseEndDate, disabledInfo);
	} : null;
	// ========================= Header =========================
	var yearNode = "".concat(formatValue(startYearDate, {
		b: locale,
		c: locale.yearFormat,
		a: generateConfig
	}), "-").concat(formatValue(endYearDate, {
		b: locale,
		c: locale.yearFormat,
		a: generateConfig
	}));
	// ========================= Render =========================
	return reactExports.createElement(PanelContext.Provider, { value: info }, reactExports.createElement("div", { className: panelPrefixCls }, reactExports.createElement(PanelHeader, {
		superOffset: function(distance) {
			return generateConfig.addYear(pickerValue, distance * 100);
		},
		onChange: onPickerValueChange,
		getStart: getStartYear,
		getEnd: getEndYear
	}, yearNode), reactExports.createElement(PanelBody, _extends$g({}, props, {
		disabledDate: mergedDisabledDate,
		colNum: 3,
		rowNum: 4,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}
function _typeof$e(o) {
	"@babel/helpers - typeof";
	return _typeof$e = function(o) {
		return typeof o;
	}, _typeof$e(o);
}
function _extends$f() {
	_extends$f = Object.assign.bind();
	return _extends$f.apply(this, arguments);
}
function _defineProperty$e(obj, key) {
	key = _toPropertyKey$e(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: true,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = true;
	}
	return obj;
}
function _toPropertyKey$e(t) {
	var i = _toPrimitive$e(t);
	return "symbol" == _typeof$e(i) ? i : String(i);
}
function _toPrimitive$e(t) {
	if ("object" != _typeof$e(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$e(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$a(arr) {
	return _arrayWithHoles$a(arr) || _iterableToArrayLimit$a(arr) || _unsupportedIterableToArray$a(arr) || _nonIterableRest$a();
}
function _nonIterableRest$a() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, 1);
}
function _arrayLikeToArray$a(arr, len) {
	if (1 == null || 1 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$a(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 1); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$a(arr) {
	if (Array.isArray(arr)) return arr;
}
function MonthPanel(props) {
	var prefixCls = props.prefixCls, locale = props.locale, generateConfig = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
	var panelPrefixCls = "".concat(prefixCls, "-month-panel");
	// ========================== Base ==========================
	var _useInfo = useInfo(props, "month"), _useInfo2 = _slicedToArray$a(_useInfo), info = _useInfo2[0];
	var baseDate = generateConfig.setMonth(pickerValue, 0);
	// ========================= Month ==========================
	var monthsLocale = locale.shortMonths || (generateConfig.locale.getShortMonths ? generateConfig.locale.getShortMonths(locale.locale) : []);
	// ========================= Cells ==========================
	var getCellDate = function(date, offset) {
		return generateConfig.addMonth(date, offset);
	};
	var getCellText = function(date) {
		var month = generateConfig.getMonth(date);
		return locale.monthFormat ? formatValue(date, {
			b: locale,
			c: locale.monthFormat,
			a: generateConfig
		}) : monthsLocale[month];
	};
	var getCellClassName = function() {
		return _defineProperty$e({}, "".concat(prefixCls, "-cell-in-view"));
	};
	// ======================== Disabled ========================
	var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
		var startDate = generateConfig.setDate(currentDate, 1);
		var nextMonthStartDate = generateConfig.setMonth(startDate, generateConfig.getMonth(startDate) + 1);
		var endDate = generateConfig.addDate(nextMonthStartDate, -1);
		return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
	} : null;
	// ========================= Header =========================
	var yearNode = reactExports.createElement("button", {
		type: "button",
		key: "year",
		"aria-label": locale.yearSelect,
		onClick: function() {
			onModeChange("year");
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-year-btn")
	}, formatValue(pickerValue, {
		b: locale,
		c: locale.yearFormat,
		a: generateConfig
	}));
	// ========================= Render =========================
	return reactExports.createElement(PanelContext.Provider, { value: info }, reactExports.createElement("div", { className: panelPrefixCls }, reactExports.createElement(PanelHeader, {
		superOffset: function(distance) {
			return generateConfig.addYear(pickerValue, distance);
		},
		onChange: onPickerValueChange,
		getStart: function(date) {
			return generateConfig.setMonth(date, 0);
		},
		getEnd: function(date) {
			return generateConfig.setMonth(date, 11);
		}
	}, yearNode), reactExports.createElement(PanelBody, _extends$f({}, props, {
		disabledDate: mergedDisabledDate,
		titleFormat: locale.fieldMonthFormat,
		colNum: 3,
		rowNum: 4,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}
function _typeof$d(o) {
	"@babel/helpers - typeof";
	return _typeof$d = function(o) {
		return typeof o;
	}, _typeof$d(o);
}
function _extends$e() {
	_extends$e = Object.assign.bind();
	return _extends$e.apply(this, arguments);
}
function _defineProperty$d(obj, key) {
	key = _toPropertyKey$d(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: true,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = true;
	}
	return obj;
}
function _toPropertyKey$d(t) {
	var i = _toPrimitive$d(t);
	return "symbol" == _typeof$d(i) ? i : String(i);
}
function _toPrimitive$d(t) {
	if ("object" != _typeof$d(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$d(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$9(arr) {
	return _arrayWithHoles$9(arr) || _iterableToArrayLimit$9(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, 1);
}
function _arrayLikeToArray$9(arr, len) {
	if (1 == null || 1 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$9(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 1); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$9(arr) {
	if (Array.isArray(arr)) return arr;
}
function QuarterPanel(props) {
	var prefixCls = props.prefixCls, locale = props.locale, generateConfig = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
	var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
	// ========================== Base ==========================
	var _useInfo = useInfo(props, "quarter"), _useInfo2 = _slicedToArray$9(_useInfo), info = _useInfo2[0];
	var baseDate = generateConfig.setMonth(pickerValue, 0);
	// ========================= Cells ==========================
	var getCellDate = function(date, offset) {
		return generateConfig.addMonth(date, offset * 3);
	};
	var getCellText = function(date) {
		return formatValue(date, {
			b: locale,
			c: locale.cellQuarterFormat,
			a: generateConfig
		});
	};
	var getCellClassName = function() {
		return _defineProperty$d({}, "".concat(prefixCls, "-cell-in-view"));
	};
	// ========================= Header =========================
	var yearNode = reactExports.createElement("button", {
		type: "button",
		key: "year",
		"aria-label": locale.yearSelect,
		onClick: function() {
			onModeChange("year");
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-year-btn")
	}, formatValue(pickerValue, {
		b: locale,
		c: locale.yearFormat,
		a: generateConfig
	}));
	// ========================= Render =========================
	return reactExports.createElement(PanelContext.Provider, { value: info }, reactExports.createElement("div", { className: panelPrefixCls }, reactExports.createElement(PanelHeader, {
		superOffset: function(distance) {
			return generateConfig.addYear(pickerValue, distance);
		},
		onChange: onPickerValueChange,
		getStart: function(date) {
			return generateConfig.setMonth(date, 0);
		},
		getEnd: function(date) {
			return generateConfig.setMonth(date, 11);
		}
	}, yearNode), reactExports.createElement(PanelBody, _extends$e({}, props, {
		titleFormat: locale.fieldQuarterFormat,
		colNum: 4,
		rowNum: 1,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}
function _typeof$c(o) {
	"@babel/helpers - typeof";
	return _typeof$c = function(o) {
		return typeof o;
	}, _typeof$c(o);
}
function _extends$d() {
	_extends$d = Object.assign.bind();
	return _extends$d.apply(this, arguments);
}
function _defineProperty$c(obj, key, value) {
	key = _toPropertyKey$c(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$c(t) {
	var i = _toPrimitive$c(t);
	return "symbol" == _typeof$c(i) ? i : String(i);
}
function _toPrimitive$c(t) {
	if ("object" != _typeof$c(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$c(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$8(arr) {
	return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$8(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, 2);
}
function _arrayLikeToArray$8(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$8(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$8(arr) {
	if (Array.isArray(arr)) return arr;
}
function WeekPanel(props) {
	var prefixCls = props.prefixCls, generateConfig = props.generateConfig, locale = props.locale, value = props.value, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue;
	// =============================== Row ================================
	var localeName = locale.locale;
	var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
	var rowClassName = function(currentDate) {
		var rangeCls = {};
		if (hoverRangeValue) {
			var _hoverRangeValue = _slicedToArray$8(hoverRangeValue), rangeStart = _hoverRangeValue[0], rangeEnd = _hoverRangeValue[1];
			var isRangeStart = isSameWeek(generateConfig, localeName, rangeStart, currentDate);
			var isRangeEnd = isSameWeek(generateConfig, localeName, rangeEnd, currentDate);
			rangeCls["".concat(rowPrefixCls, "-range-start")] = isRangeStart;
			rangeCls["".concat(rowPrefixCls, "-range-end")] = isRangeEnd;
			rangeCls["".concat(rowPrefixCls, "-range-hover")] = !isRangeStart && !isRangeEnd && isInRange(generateConfig, rangeStart, rangeEnd, currentDate);
		}
		if (hoverValue) {
			rangeCls["".concat(rowPrefixCls, "-hover")] = hoverValue.some(function(date) {
				return isSameWeek(generateConfig, localeName, currentDate, date);
			});
		}
		return clsx(
			rowPrefixCls,
			_defineProperty$c({}, "".concat(rowPrefixCls, "-selected"), !hoverRangeValue && isSameWeek(generateConfig, localeName, value, currentDate)),
			// Patch for hover range
			rangeCls
		);
	};
	// ============================== Render ==============================
	return reactExports.createElement(DatePanel, _extends$d({}, props, {
		mode: "week",
		panelName: "week",
		rowClassName
	}));
}
function _typeof$b(o) {
	"@babel/helpers - typeof";
	return _typeof$b = function(o) {
		return typeof o;
	}, _typeof$b(o);
}
function _extends$c() {
	_extends$c = Object.assign.bind();
	return _extends$c.apply(this, arguments);
}
function _defineProperty$b(obj, key, value) {
	key = _toPropertyKey$b(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$b(t) {
	var i = _toPrimitive$b(t);
	return "symbol" == _typeof$b(i) ? i : String(i);
}
function _toPrimitive$b(t) {
	if ("object" != _typeof$b(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$b(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$7(arr) {
	return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, 1);
}
function _arrayLikeToArray$7(arr, len) {
	if (1 == null || 1 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$7(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 1); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$7(arr) {
	if (Array.isArray(arr)) return arr;
}
function YearPanel(props) {
	var prefixCls = props.prefixCls, locale = props.locale, generateConfig = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
	var panelPrefixCls = "".concat(prefixCls, "-year-panel");
	// ========================== Base ==========================
	var _useInfo = useInfo(props, "year"), _useInfo2 = _slicedToArray$7(_useInfo), info = _useInfo2[0];
	var getStartYear = function(date) {
		var startYear = Math.floor(generateConfig.getYear(date) / 10) * 10;
		return generateConfig.setYear(date, startYear);
	};
	var getEndYear = function(date) {
		var startYear = getStartYear(date);
		return generateConfig.addYear(startYear, 9);
	};
	var startYearDate = getStartYear(pickerValue);
	var endYearDate = getEndYear(pickerValue);
	var baseDate = generateConfig.addYear(startYearDate, -1);
	// ========================= Cells ==========================
	var getCellDate = function(date, offset) {
		return generateConfig.addYear(date, offset);
	};
	var getCellText = function(date) {
		return formatValue(date, {
			b: locale,
			c: locale.cellYearFormat,
			a: generateConfig
		});
	};
	var getCellClassName = function(date) {
		return _defineProperty$b({}, "".concat(prefixCls, "-cell-in-view"), isSameYear(generateConfig, date, startYearDate) || isSameYear(generateConfig, date, endYearDate) || isInRange(generateConfig, startYearDate, endYearDate, date));
	};
	// ======================== Disabled ========================
	var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
		// Start
		var startMonth = generateConfig.setMonth(currentDate, 0);
		var startDate = generateConfig.setDate(startMonth, 1);
		// End
		var endMonth = generateConfig.addYear(startDate, 1);
		var endDate = generateConfig.addDate(endMonth, -1);
		return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
	} : null;
	// ========================= Header =========================
	var yearNode = reactExports.createElement("button", {
		type: "button",
		key: "decade",
		"aria-label": locale.decadeSelect,
		onClick: function() {
			onModeChange("decade");
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-decade-btn")
	}, formatValue(startYearDate, {
		b: locale,
		c: locale.yearFormat,
		a: generateConfig
	}), "-", formatValue(endYearDate, {
		b: locale,
		c: locale.yearFormat,
		a: generateConfig
	}));
	// ========================= Render =========================
	return reactExports.createElement(PanelContext.Provider, { value: info }, reactExports.createElement("div", { className: panelPrefixCls }, reactExports.createElement(PanelHeader, {
		superOffset: function(distance) {
			return generateConfig.addYear(pickerValue, distance * 10);
		},
		onChange: onPickerValueChange,
		getStart: getStartYear,
		getEnd: getEndYear
	}, yearNode), reactExports.createElement(PanelBody, _extends$c({}, props, {
		disabledDate: mergedDisabledDate,
		titleFormat: locale.fieldYearFormat,
		colNum: 3,
		rowNum: 4,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}
function _typeof$a(o) {
	"@babel/helpers - typeof";
	return _typeof$a = function(o) {
		return typeof o;
	}, _typeof$a(o);
}
function _extends$b() {
	_extends$b = Object.assign.bind();
	return _extends$b.apply(this, arguments);
}
function ownKeys$8(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$8(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$8(Object(t), true).forEach(function(r) {
			_defineProperty$a(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$a(obj, key, value) {
	key = _toPropertyKey$a(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$a(t) {
	var i = _toPrimitive$a(t);
	return "symbol" == _typeof$a(i) ? i : String(i);
}
function _toPrimitive$a(t) {
	if ("object" != _typeof$a(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$a(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _toConsumableArray$2(arr) {
	return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$6(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$2(iter) {
	if (iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$6(arr);
}
function _slicedToArray$6(arr, i) {
	return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$6(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$6(arr) {
	if (Array.isArray(arr)) return arr;
}
var DefaultComponents = {
	date: DatePanel,
	datetime: DateTimePanel,
	week: WeekPanel,
	month: MonthPanel,
	quarter: QuarterPanel,
	year: YearPanel,
	decade: DecadePanel,
	time: TimePanel
};
function PickerPanel(props, ref) {
	var panelClassNames = props.classNames, panelStyles = props.styles, locale = props.locale, generateConfig = props.generateConfig, direction = props.direction, prefixCls = props.prefixCls, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, multiple = props.multiple, defaultValue = props.defaultValue, value = props.value, onChange = props.onChange, onSelect = props.onSelect, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, mode = props.mode, onPanelChange = props.onPanelChange, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, showTime = props.showTime, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, cellRender = props.cellRender, dateRender = props.dateRender, monthCellRender = props.monthCellRender, _props$components = props.components, components = _props$components === void 0 ? {} : _props$components, hideHeader = props.hideHeader;
	// ======================== Context ========================
	var _ref = reactExports.useContext(PickerContext$1) || {}, contextPrefixCls = _ref.prefixCls, pickerClassNames = _ref.classNames, pickerStyles = _ref.styles;
	// ======================== prefixCls ========================
	var mergedPrefixCls = contextPrefixCls || prefixCls || "rc-picker";
	// ========================== Refs ==========================
	var rootRef = reactExports.useRef();
	reactExports.useImperativeHandle(ref, function() {
		return { nativeElement: rootRef.current };
	});
	// ========================== Time ==========================
	// Auto `format` need to check `showTime.showXXX` first.
	// And then merge the `locale` into `mergedShowTime`.
	var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray$6(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
	// ========================= Locale =========================
	var filledLocale = useLocale(locale, localeTimeProps);
	// ========================= Picker =========================
	var internalPicker = picker === "date" && showTime ? "datetime" : picker;
	// ======================== ShowTime ========================
	var mergedShowTime = reactExports.useMemo(function() {
		return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, filledLocale);
	}, [
		internalPicker,
		showTimeFormat,
		propFormat,
		timeProps,
		filledLocale
	]);
	// ========================== Now ===========================
	var now = generateConfig.getNow();
	// ========================== Mode ==========================
	var _useControlledState = useControlledState(picker || "date", mode), _useControlledState2 = _slicedToArray$6(_useControlledState, 2), mergedMode = _useControlledState2[0], setMergedMode = _useControlledState2[1];
	var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
	// ========================= Toggle =========================
	var toggleDates = useToggleDates(generateConfig, locale, internalPicker);
	// ========================= Value ==========================
	// >>> Real value
	// Interactive with `onChange` event which only trigger when the `mode` is `picker`
	var _useControlledState3 = useControlledState(defaultValue, value), _useControlledState4 = _slicedToArray$6(_useControlledState3, 2), innerValue = _useControlledState4[0], setMergedValue = _useControlledState4[1];
	var mergedValue = reactExports.useMemo(function() {
		// Clean up `[null]`
		var values = toArray(innerValue).filter(function(val) {
			return val;
		});
		return multiple ? values : values.slice(0, 1);
	}, [innerValue, multiple]);
	// Sync value and only trigger onChange event when changed
	var triggerChange = useEvent(function(nextValue) {
		setMergedValue(nextValue);
		if (onChange && (nextValue === null || mergedValue.length !== nextValue.length || mergedValue.some(function(ori, index) {
			return !isSame(generateConfig, locale, ori, nextValue[index], internalPicker);
		}))) {
			onChange === null || onChange === void 0 || onChange(multiple ? nextValue : nextValue[0]);
		}
	});
	// >>> CalendarValue
	// CalendarValue is a temp value for user operation
	// which will only trigger `onCalendarChange` but not `onChange`
	var onInternalSelect = useEvent(function(newDate) {
		onSelect === null || onSelect === void 0 || onSelect(newDate);
		if (mergedMode === picker) {
			var nextValues = multiple ? toggleDates(mergedValue, newDate) : [newDate];
			triggerChange(nextValues);
		}
	});
	// >>> PickerValue
	// PickerValue is used to control the current displaying panel
	var _useControlledState5 = useControlledState(defaultPickerValue || mergedValue[0] || now, pickerValue), _useControlledState6 = _slicedToArray$6(_useControlledState5, 2), mergedPickerValue = _useControlledState6[0], setInternalPickerValue = _useControlledState6[1];
	reactExports.useEffect(function() {
		if (mergedValue[0] && !pickerValue) {
			setInternalPickerValue(mergedValue[0]);
		}
	}, [mergedValue[0]]);
	// Both trigger when manually pickerValue or mode change
	var triggerPanelChange = function(viewDate, nextMode) {
		onPanelChange === null || onPanelChange === void 0 || onPanelChange(viewDate || pickerValue, nextMode || mergedMode);
	};
	var setPickerValue = function(nextPickerValue) {
		var triggerPanelEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
		setInternalPickerValue(nextPickerValue);
		onPickerValueChange === null || onPickerValueChange === void 0 || onPickerValueChange(nextPickerValue);
		if (triggerPanelEvent) {
			triggerPanelChange(nextPickerValue);
		}
	};
	var triggerModeChange = function(nextMode, viewDate) {
		setMergedMode(nextMode);
		if (viewDate) {
			setPickerValue(viewDate);
		}
		triggerPanelChange(viewDate, nextMode);
	};
	var onPanelValueSelect = function(nextValue) {
		onInternalSelect(nextValue);
		setPickerValue(nextValue);
		// Update mode if needed
		if (mergedMode !== picker) {
			var decadeYearQueue = ["decade", "year"];
			var decadeYearMonthQueue = [].concat(decadeYearQueue, ["month"]);
			var pickerQueue = {
				quarter: [].concat(decadeYearQueue, ["quarter"]),
				week: [].concat(_toConsumableArray$2(decadeYearMonthQueue), ["week"]),
				date: [].concat(_toConsumableArray$2(decadeYearMonthQueue), ["date"])
			};
			var queue = pickerQueue[picker] || decadeYearMonthQueue;
			var index = queue.indexOf(mergedMode);
			var nextMode = queue[index + 1];
			if (nextMode) {
				triggerModeChange(nextMode, nextValue);
			}
		}
	};
	// ======================= Hover Date =======================
	var hoverRangeDate = reactExports.useMemo(function() {
		var start;
		var end;
		if (Array.isArray(hoverRangeValue)) {
			var _hoverRangeValue = _slicedToArray$6(hoverRangeValue, 2);
			start = _hoverRangeValue[0];
			end = _hoverRangeValue[1];
		} else {
			start = hoverRangeValue;
		}
		// Return for not exist
		if (!start && !end) {
			return null;
		}
		// Fill if has empty
		start = start || end;
		end = end || start;
		return generateConfig.isAfter(start, end) ? [end, start] : [start, end];
	}, [hoverRangeValue, generateConfig]);
	// ======================= Components =======================
	// >>> cellRender
	var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
	// ======================= Components =======================
	var PanelComponent = components[internalMode] || DefaultComponents[internalMode] || DatePanel;
	// ======================== Context =========================
	var sharedPanelContext = reactExports.useMemo(function() {
		var _ref2, _pickerClassNames$pop, _ref3, _pickerStyles$popup;
		return {
			classNames: (_ref2 = (_pickerClassNames$pop = pickerClassNames === null || pickerClassNames === void 0 ? void 0 : pickerClassNames.popup) !== null && _pickerClassNames$pop !== void 0 ? _pickerClassNames$pop : panelClassNames) !== null && _ref2 !== void 0 ? _ref2 : {},
			styles: (_ref3 = (_pickerStyles$popup = pickerStyles === null || pickerStyles === void 0 ? void 0 : pickerStyles.popup) !== null && _pickerStyles$popup !== void 0 ? _pickerStyles$popup : panelStyles) !== null && _ref3 !== void 0 ? _ref3 : {}
		};
	}, [
		pickerClassNames,
		panelClassNames,
		pickerStyles,
		panelStyles
	]);
	var parentHackContext = reactExports.useContext(PickerHackContext);
	var pickerPanelContext = reactExports.useMemo(function() {
		return _objectSpread$8(_objectSpread$8({}, parentHackContext), {}, { hideHeader });
	}, [parentHackContext, hideHeader]);
	// ========================= Render =========================
	var panelCls = "".concat(mergedPrefixCls, "-panel");
	var panelProps = pickProps(props, [
		"showWeek",
		"prevIcon",
		"nextIcon",
		"superPrevIcon",
		"superNextIcon",
		"disabledDate",
		"minDate",
		"maxDate",
		"onHover"
	]);
	return reactExports.createElement(SharedPanelContext.Provider, { value: sharedPanelContext }, reactExports.createElement(PickerHackContext.Provider, { value: pickerPanelContext }, reactExports.createElement("div", {
		ref: rootRef,
		tabIndex,
		className: clsx(panelCls, _defineProperty$a({}, "".concat(panelCls, "-rtl"), direction === "rtl"))
	}, reactExports.createElement(PanelComponent, _extends$b({}, panelProps, {
		showTime: mergedShowTime,
		prefixCls: mergedPrefixCls,
		locale: filledLocale,
		generateConfig,
		onModeChange: triggerModeChange,
		pickerValue: mergedPickerValue,
		onPickerValueChange: function(nextPickerValue) {
			setPickerValue(nextPickerValue, true);
		},
		value: mergedValue[0],
		onSelect: onPanelValueSelect,
		values: mergedValue,
		cellRender: onInternalCellRender,
		hoverRangeValue: hoverRangeDate,
		hoverValue
	})))));
}
var RefPanelPicker = reactExports.memo(reactExports.forwardRef(PickerPanel));
// Make support generic
var RCPickerPanel = RefPanelPicker;
function _typeof$9(o) {
	"@babel/helpers - typeof";
	return _typeof$9 = function(o) {
		return typeof o;
	}, _typeof$9(o);
}
function _extends$a() {
	_extends$a = Object.assign.bind();
	return _extends$a.apply(this, arguments);
}
function ownKeys$7(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$7(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$7(Object(t), true).forEach(function(r) {
			_defineProperty$9(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$9(obj, key, value) {
	key = _toPropertyKey$9(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$9(t) {
	var i = _toPrimitive$9(t);
	return "symbol" == _typeof$9(i) ? i : String(i);
}
function _toPrimitive$9(t) {
	if ("object" != _typeof$9(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$9(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function PopupPanel(props) {
	var picker = props.picker, multiplePanel = props.multiplePanel, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, needConfirm = props.needConfirm, onSubmit = props.onSubmit, range = props.range, hoverValue = props.hoverValue;
	var _React$useContext = reactExports.useContext(PickerContext$1), prefixCls = _React$useContext.prefixCls, generateConfig = _React$useContext.generateConfig;
	// ======================== Offset ========================
	var internalOffsetDate = reactExports.useCallback(function(date, offset) {
		return offsetPanelDate(generateConfig, picker, date, offset);
	}, [generateConfig, picker]);
	var nextPickerValue = reactExports.useMemo(function() {
		return internalOffsetDate(pickerValue, 1);
	}, [pickerValue, internalOffsetDate]);
	// Outside
	var onSecondPickerValueChange = function(nextDate) {
		onPickerValueChange(internalOffsetDate(nextDate, -1));
	};
	// ======================= Context ========================
	var sharedContext = { onCellDblClick: function() {
		if (needConfirm) {
			onSubmit();
		}
	} };
	var hideHeader = picker === "time";
	// ======================== Props =========================
	var pickerProps = _objectSpread$7(_objectSpread$7({}, props), {}, {
		hoverValue: null,
		hoverRangeValue: null,
		hideHeader
	});
	if (range) {
		pickerProps.hoverRangeValue = hoverValue;
	} else {
		pickerProps.hoverValue = hoverValue;
	}
	// ======================== Render ========================
	// Multiple
	if (multiplePanel) {
		return reactExports.createElement("div", { className: "".concat(prefixCls, "-panels") }, reactExports.createElement(PickerHackContext.Provider, { value: _objectSpread$7(_objectSpread$7({}, sharedContext), {}, { hideNext: true }) }, reactExports.createElement(RCPickerPanel, pickerProps)), reactExports.createElement(PickerHackContext.Provider, { value: _objectSpread$7(_objectSpread$7({}, sharedContext), {}, { hidePrev: true }) }, reactExports.createElement(RCPickerPanel, _extends$a({}, pickerProps, {
			pickerValue: nextPickerValue,
			onPickerValueChange: onSecondPickerValueChange
		}))));
	}
	// Single
	return reactExports.createElement(PickerHackContext.Provider, { value: _objectSpread$7({}, sharedContext) }, reactExports.createElement(RCPickerPanel, pickerProps));
}
function executeValue(value) {
	return typeof value === "function" ? value() : value;
}
function PresetPanel(props) {
	var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
	if (!presets.length) {
		return null;
	}
	return reactExports.createElement("div", { className: "".concat(prefixCls, "-presets") }, reactExports.createElement("ul", null, presets.map(function(_ref, index) {
		var label = _ref.label, value = _ref.value;
		return reactExports.createElement("li", {
			key: index,
			onClick: function() {
				_onClick(executeValue(value));
			},
			onMouseEnter: function() {
				onHover(executeValue(value));
			},
			onMouseLeave: function() {
				onHover(null);
			}
		}, label);
	})));
}
function _typeof$8(o) {
	"@babel/helpers - typeof";
	return _typeof$8 = function(o) {
		return typeof o;
	}, _typeof$8(o);
}
function ownKeys$6(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$6(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$6(Object(t), true).forEach(function(r) {
			_defineProperty$8(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$8(obj, key, value) {
	key = _toPropertyKey$8(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$8(t) {
	var i = _toPrimitive$8(t);
	return "symbol" == _typeof$8(i) ? i : String(i);
}
function _toPrimitive$8(t) {
	if ("object" != _typeof$8(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$8(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _extends$9() {
	_extends$9 = Object.assign.bind();
	return _extends$9.apply(this, arguments);
}
function _slicedToArray$5(arr, i) {
	return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$5(arr, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
}
function _arrayLikeToArray$5(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$5(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$5(arr) {
	if (Array.isArray(arr)) return arr;
}
function Popup(props) {
	var _classNames$popup, _styles$popup;
	var panelRender = props.panelRender, internalMode = props.internalMode, picker = props.picker, showNow = props.showNow, range = props.range, multiple = props.multiple, _props$activeInfo = props.activeInfo, activeInfo = _props$activeInfo === void 0 ? [
		0,
		0,
		0
	] : _props$activeInfo, presets = props.presets, onPresetHover = props.onPresetHover, onPresetSubmit = props.onPresetSubmit, onFocus = props.onFocus, onBlur = props.onBlur, onPanelMouseDown = props.onPanelMouseDown, direction = props.direction, value = props.value, onSelect = props.onSelect, isInvalid = props.isInvalid, defaultOpenValue = props.defaultOpenValue, onOk = props.onOk, onSubmit = props.onSubmit, classNames = props.classNames, styles = props.styles;
	var _React$useContext = reactExports.useContext(PickerContext$1), prefixCls = _React$useContext.prefixCls;
	var panelPrefixCls = "".concat(prefixCls, "-panel");
	var rtl = direction === "rtl";
	// ========================= Refs =========================
	var arrowRef = reactExports.useRef(null);
	var wrapperRef = reactExports.useRef(null);
	// ======================== Offset ========================
	var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray$5(_React$useState, 2), containerWidth = _React$useState2[0], setContainerWidth = _React$useState2[1];
	var _React$useState3 = reactExports.useState(0), _React$useState4 = _slicedToArray$5(_React$useState3, 2), containerOffset = _React$useState4[0], setContainerOffset = _React$useState4[1];
	var _React$useState5 = reactExports.useState(0), _React$useState6 = _slicedToArray$5(_React$useState5, 2), arrowOffset = _React$useState6[0], setArrowOffset = _React$useState6[1];
	var onResize = function(info) {
		if (info.width) {
			setContainerWidth(info.width);
		}
	};
	var _activeInfo = _slicedToArray$5(activeInfo, 3), activeInputLeft = _activeInfo[0], activeInputRight = _activeInfo[1], selectorWidth = _activeInfo[2];
	var _React$useState7 = reactExports.useState(0), _React$useState8 = _slicedToArray$5(_React$useState7, 2), retryTimes = _React$useState8[0], setRetryTimes = _React$useState8[1];
	reactExports.useEffect(function() {
		setRetryTimes(10);
	}, [activeInputLeft]);
	reactExports.useEffect(function() {
		// `activeOffset` is always align with the active input element
		// So we need only check container contains the `activeOffset`
		if (range && wrapperRef.current) {
			var _arrowRef$current;
			// Offset in case container has border radius
			var arrowWidth = ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.offsetWidth) || 0;
			// Arrow Offset
			var wrapperRect = wrapperRef.current.getBoundingClientRect();
			if (!wrapperRect.height || wrapperRect.right < 0) {
				setRetryTimes(function(times) {
					return Math.max(0, times - 1);
				});
				return;
			}
			var nextArrowOffset = (rtl ? activeInputRight - arrowWidth : activeInputLeft) - wrapperRect.left;
			setArrowOffset(nextArrowOffset);
			// Container Offset
			if (containerWidth && containerWidth < selectorWidth) {
				var offset = rtl ? wrapperRect.right - (activeInputRight - arrowWidth + containerWidth) : activeInputLeft + arrowWidth - wrapperRect.left - containerWidth;
				var safeOffset = Math.max(0, offset);
				setContainerOffset(safeOffset);
			} else {
				setContainerOffset(0);
			}
		}
	}, [
		retryTimes,
		rtl,
		containerWidth,
		activeInputLeft,
		activeInputRight,
		selectorWidth,
		range
	]);
	// ======================== Custom ========================
	function filterEmpty(list) {
		return list.filter(function(item) {
			return item;
		});
	}
	var valueList = reactExports.useMemo(function() {
		return filterEmpty(toArray(value));
	}, [value]);
	var isTimePickerEmptyValue = picker === "time" && !valueList.length;
	var footerSubmitValue = reactExports.useMemo(function() {
		if (isTimePickerEmptyValue) {
			return filterEmpty([defaultOpenValue]);
		}
		return valueList;
	}, [
		isTimePickerEmptyValue,
		valueList,
		defaultOpenValue
	]);
	var popupPanelValue = isTimePickerEmptyValue ? defaultOpenValue : valueList;
	var disableSubmit = reactExports.useMemo(function() {
		// Empty is invalid
		if (!footerSubmitValue.length) {
			return true;
		}
		return footerSubmitValue.some(function(val) {
			return isInvalid(val);
		});
	}, [footerSubmitValue, isInvalid]);
	var onFooterSubmit = function() {
		// For TimePicker, we will additional trigger the value update
		if (isTimePickerEmptyValue) {
			onSelect(defaultOpenValue);
		}
		onOk();
		onSubmit();
	};
	var mergedNodes = reactExports.createElement("div", { className: "".concat(prefixCls, "-panel-layout") }, reactExports.createElement(PresetPanel, {
		prefixCls,
		presets,
		onClick: onPresetSubmit,
		onHover: onPresetHover
	}), reactExports.createElement("div", null, reactExports.createElement(PopupPanel, _extends$9({}, props, { value: popupPanelValue })), reactExports.createElement(Footer, _extends$9({}, props, {
		showNow: multiple ? false : showNow,
		invalid: disableSubmit,
		onSubmit: onFooterSubmit
	}))));
	if (panelRender) {
		mergedNodes = panelRender(mergedNodes);
	}
	// ======================== Render ========================
	var containerPrefixCls = "".concat(panelPrefixCls, "-container");
	// Container
	var renderNode = reactExports.createElement("div", {
		onMouseDown: onPanelMouseDown,
		tabIndex: -1,
		className: clsx(containerPrefixCls, "".concat(prefixCls, "-").concat(internalMode, "-panel-container"), classNames === null || classNames === void 0 || (_classNames$popup = classNames.popup) === null || _classNames$popup === void 0 ? void 0 : _classNames$popup.container),
		style: _objectSpread$6(_defineProperty$8(_defineProperty$8({}, rtl ? "marginRight" : "marginLeft", containerOffset), rtl ? "marginLeft" : "marginRight", "auto"), styles === null || styles === void 0 || (_styles$popup = styles.popup) === null || _styles$popup === void 0 ? void 0 : _styles$popup.container),
		onFocus,
		onBlur
	}, mergedNodes);
	if (range) {
		renderNode = reactExports.createElement("div", {
			onMouseDown: onPanelMouseDown,
			ref: wrapperRef,
			className: clsx("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper"))
		}, reactExports.createElement("div", {
			ref: arrowRef,
			className: "".concat(prefixCls, "-range-arrow"),
			style: { left: arrowOffset }
		}), reactExports.createElement(RefResizeObserver, { onResize }, renderNode));
	}
	return renderNode;
}
function _typeof$7(o) {
	"@babel/helpers - typeof";
	return _typeof$7 = function(o) {
		return typeof o;
	}, _typeof$7(o);
}
function ownKeys$5(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$5(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$5(Object(t), true).forEach(function(r) {
			_defineProperty$7(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$7(obj, key, value) {
	key = _toPropertyKey$7(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$7(t) {
	var i = _toPrimitive$7(t);
	return "symbol" == _typeof$7(i) ? i : String(i);
}
function _toPrimitive$7(t) {
	if ("object" != _typeof$7(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$7(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function useInputProps(props, postProps) {
	var format = props.format, maskFormat = props.maskFormat, generateConfig = props.generateConfig, locale = props.locale, preserveInvalidOnBlur = props.preserveInvalidOnBlur, inputReadOnly = props.inputReadOnly, required = props.required, ariaRequired = props["aria-required"], onSubmit = props.onSubmit, _onFocus = props.onFocus, _onBlur = props.onBlur, onInputChange = props.onInputChange, onInvalid = props.onInvalid, open = props.open, onOpenChange = props.onOpenChange, _onKeyDown = props.onKeyDown, _onChange = props.onChange, activeHelp = props.activeHelp, name = props.name, autoComplete = props.autoComplete, id = props.id, value = props.value, invalid = props.invalid, placeholder = props.placeholder, disabled = props.disabled, activeIndex = props.activeIndex, allHelp = props.allHelp, picker = props.picker;
	// ======================== Parser ========================
	var parseDate = function(str, formatStr) {
		var parsed = generateConfig.locale.parse(locale.locale, str, [formatStr]);
		return parsed && generateConfig.isValidate(parsed) ? parsed : null;
	};
	// ========================= Text =========================
	var firstFormat = format[0];
	var getText = reactExports.useCallback(function(date) {
		return formatValue(date, {
			b: locale,
			c: firstFormat,
			a: generateConfig
		});
	}, [
		locale,
		generateConfig,
		firstFormat
	]);
	var valueTexts = reactExports.useMemo(function() {
		return value.map(getText);
	}, [value, getText]);
	// ========================= Size =========================
	var size = reactExports.useMemo(function() {
		var defaultSize = picker === "time" ? 8 : 10;
		var length = typeof firstFormat === "function" ? firstFormat(generateConfig.getNow()).length : firstFormat.length;
		return Math.max(defaultSize, length) + 2;
	}, [
		firstFormat,
		picker,
		generateConfig
	]);
	// ======================= Validate =======================
	var _validateFormat = function(text) {
		for (var i = 0; i < format.length; i += 1) {
			var singleFormat = format[i];
			// Only support string type
			if (typeof singleFormat === "string") {
				var parsed = parseDate(text, singleFormat);
				if (parsed) {
					return parsed;
				}
			}
		}
		return false;
	};
	// ======================== Input =========================
	var getInputProps = function(index) {
		function getProp(propValue) {
			return index !== void 0 ? propValue[index] : propValue;
		}
		var pickedAttrs = pickAttrs(props, {
			aria: true,
			data: true
		});
		var inputProps = _objectSpread$5(_objectSpread$5({}, pickedAttrs), {}, {
			format: maskFormat,
			validateFormat: function(text) {
				return !!_validateFormat(text);
			},
			preserveInvalidOnBlur,
			readOnly: inputReadOnly,
			required,
			"aria-required": ariaRequired,
			name,
			autoComplete,
			size,
			id: getProp(id),
			value: getProp(valueTexts) || "",
			invalid: getProp(invalid),
			placeholder: getProp(placeholder),
			active: activeIndex === index,
			helped: allHelp || activeHelp && activeIndex === index,
			disabled: getProp(disabled),
			onFocus: function(event) {
				_onFocus(event, index);
			},
			onBlur: function(event) {
				// Blur do not trigger close
				// Since it may focus to the popup panel
				_onBlur(event, index);
			},
			onSubmit,
			onChange: function(text) {
				onInputChange();
				var parsed = _validateFormat(text);
				if (parsed) {
					onInvalid(false, index);
					_onChange(parsed, index);
					return;
				}
				// Tell outer that the value typed is invalid.
				// If text is empty, it means valid.
				onInvalid(!!text, index);
			},
			onHelp: function() {
				onOpenChange(true, { index });
			},
			onKeyDown: function(event) {
				var prevented = false;
				_onKeyDown === null || _onKeyDown === void 0 || _onKeyDown(event, function() {
					prevented = true;
				});
				if (!event.defaultPrevented && !prevented) {
					switch (event.key) {
						case "Escape":
							onOpenChange(false, { index });
							break;
						case "Enter":
							if (!open) {
								onOpenChange(true);
							}
							break;
					}
				}
			}
		}, postProps === void 0 ? void 0 : postProps({ valueTexts }));
		// ============== Clean Up ==============
		Object.keys(inputProps).forEach(function(key) {
			if (inputProps[key] === void 0) {
				delete inputProps[key];
			}
		});
		return inputProps;
	};
	return [getInputProps, getText];
}
var propNames = ["onMouseEnter", "onMouseLeave"];
function useRootProps(props) {
	return reactExports.useMemo(function() {
		return pickProps(props, propNames);
	}, [props]);
}
var _excluded$3 = ["icon", "type"], _excluded2$1 = ["onClear"];
function _extends$8() {
	_extends$8 = Object.assign.bind();
	return _extends$8.apply(this, arguments);
}
function _objectWithoutProperties$3(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$3(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function Icon(props) {
	var icon = props.icon, type = props.type, restProps = _objectWithoutProperties$3(props, _excluded$3);
	var _React$useContext = reactExports.useContext(PickerContext$1), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	return icon ? reactExports.createElement("span", _extends$8({
		className: clsx("".concat(prefixCls, "-").concat(type), classNames.suffix),
		style: styles.suffix
	}, restProps), icon) : null;
}
function ClearIcon(_ref) {
	var onClear = _ref.onClear, restProps = _objectWithoutProperties$3(_ref, _excluded2$1);
	return reactExports.createElement(Icon, _extends$8({}, restProps, {
		type: "clear",
		role: "button",
		onMouseDown: function(e) {
			e.preventDefault();
		},
		onClick: function(e) {
			e.stopPropagation();
			onClear();
		}
	}));
}
function _typeof$6(o) {
	"@babel/helpers - typeof";
	return _typeof$6 = function(o) {
		return typeof o;
	}, _typeof$6(o);
}
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError("Cannot call a class as a function");
	}
}
function _defineProperties(target, props) {
	for (var i = 0; i < 4; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$6(descriptor.key), descriptor);
	}
}
function _createClass(Constructor, protoProps) {
	{
		_defineProperties(Constructor.prototype, protoProps);
	}
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return;
}
function _defineProperty$6(obj, key) {
	key = _toPropertyKey$6(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: void 0,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = void 0;
	}
	return;
}
function _toPropertyKey$6(t) {
	var i = _toPrimitive$6(t);
	return "symbol" == _typeof$6(i) ? i : String(i);
}
function _toPrimitive$6(t) {
	if ("object" != _typeof$6(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$6(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
var FORMAT_KEYS = [
	"YYYY",
	"MM",
	"DD",
	"HH",
	"mm",
	"ss",
	"SSS"
];
var MaskFormat = function() {
	function MaskFormat(format) {
		_classCallCheck(this, MaskFormat);
		_defineProperty$6(this, "format");
		_defineProperty$6(this, "maskFormat");
		_defineProperty$6(this, "cells");
		_defineProperty$6(this, "maskCells");
		this.format = format;
		// Generate mask format
		var replaceKeys = FORMAT_KEYS.map(function(key) {
			return "(".concat(key, ")");
		}).join("|");
		var replaceReg = new RegExp(replaceKeys, "g");
		this.maskFormat = format.replace(
			replaceReg,
			// Use Chinese character to avoid user use it in format
			function(key) {
				return "".repeat(key.length);
			}
		);
		// Generate cells
		var cellReg = new RegExp("(".concat(FORMAT_KEYS.join("|"), ")"));
		var strCells = (format.split(cellReg) || []).filter(function(str) {
			return str;
		});
		var offset = 0;
		this.cells = strCells.map(function(text) {
			var mask = FORMAT_KEYS.includes(text);
			var start = offset;
			var end = offset + text.length;
			offset = end;
			return {
				text,
				mask,
				start,
				end
			};
		});
		// Mask cells
		this.maskCells = this.cells.filter(function(cell) {
			return cell.mask;
		});
	}
	_createClass(MaskFormat, [
		{
			key: "getSelection",
			value: function(maskCellIndex) {
				var _ref = this.maskCells[maskCellIndex] || {}, start = _ref.start, end = _ref.end;
				return [start || 0, end || 0];
			}
		},
		{
			key: "match",
			value: function(text) {
				for (var i = 0; i < this.maskFormat.length; i += 1) {
					var maskChar = this.maskFormat[i];
					var textChar = text[i];
					if (!textChar || maskChar !== "" && maskChar !== textChar) {
						return false;
					}
				}
				return true;
			}
		},
		{
			key: "size",
			value: function() {
				return this.maskCells.length;
			}
		},
		{
			key: "getMaskCellIndex",
			value: function(anchorIndex) {
				var closetDist = Number.MAX_SAFE_INTEGER;
				var closetIndex = 0;
				for (var i = 0; i < this.maskCells.length; i += 1) {
					var _this$maskCells$i = this.maskCells[i], start = _this$maskCells$i.start, end = _this$maskCells$i.end;
					if (anchorIndex >= start && anchorIndex <= end) {
						return i;
					}
					var dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));
					if (dist < closetDist) {
						closetDist = dist;
						closetIndex = i;
					}
				}
				return closetIndex;
			}
		}
	]);
	return MaskFormat;
}();
function getMaskRange(key) {
	var PresetRange = {
		YYYY: [
			0,
			9999,
			new Date().getFullYear()
		],
		MM: [1, 12],
		DD: [1, 31],
		HH: [0, 23],
		mm: [0, 59],
		ss: [0, 59],
		SSS: [0, 999]
	};
	return PresetRange[key];
}
function _typeof$5(o) {
	"@babel/helpers - typeof";
	return _typeof$5 = function(o) {
		return typeof o;
	}, _typeof$5(o);
}
var _excluded$2 = [
	"className",
	"active",
	"showActiveCls",
	"suffixIcon",
	"format",
	"validateFormat",
	"onChange",
	"onInput",
	"helped",
	"onHelp",
	"onSubmit",
	"onKeyDown",
	"preserveInvalidOnBlur",
	"invalid",
	"clearIcon"
];
function _extends$7() {
	_extends$7 = Object.assign.bind();
	return _extends$7.apply(this, arguments);
}
function _defineProperty$5(obj, key, value) {
	key = _toPropertyKey$5(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$5(t) {
	var i = _toPrimitive$5(t);
	return "symbol" == _typeof$5(i) ? i : String(i);
}
function _toPrimitive$5(t) {
	if ("object" != _typeof$5(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$5(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$4(arr, i) {
	return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$4(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$4(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$4(arr) {
	if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$2(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$2(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
// Format logic
//
// First time on focus:
//  1. check if the text is valid, if not fill with format
//  2. set highlight cell to the first cell
// Cells
//  1. Selection the index cell, set inner `cacheValue` to ''
//  2. Key input filter non-number char, patch after the `cacheValue`
//    1. Replace the `cacheValue` with input align the cell length
//    2. Re-selection the mask cell
//  3. If `cacheValue` match the limit length or cell format (like 1 ~ 12 month), go to next cell
var Input = reactExports.forwardRef(function(props, ref) {
	var className = props.className, active = props.active, _props$showActiveCls = props.showActiveCls, showActiveCls = _props$showActiveCls === void 0 ? true : _props$showActiveCls, suffixIcon = props.suffixIcon, format = props.format, validateFormat = props.validateFormat, onChange = props.onChange;
	var helped = props.helped, onHelp = props.onHelp, onSubmit = props.onSubmit, onKeyDown = props.onKeyDown, _props$preserveInvali = props.preserveInvalidOnBlur, preserveInvalidOnBlur = _props$preserveInvali === void 0 ? false : _props$preserveInvali, invalid = props.invalid, clearIcon = props.clearIcon, restProps = _objectWithoutProperties$2(props, _excluded$2);
	var value = props.value, onFocus = props.onFocus, onBlur = props.onBlur, onMouseUp = props.onMouseUp;
	var _React$useContext = reactExports.useContext(PickerContext$1), prefixCls = _React$useContext.prefixCls, _React$useContext$inp = _React$useContext.input, Component = _React$useContext$inp === void 0 ? "input" : _React$useContext$inp, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	var inputPrefixCls = "".concat(prefixCls, "-input");
	// ======================== Value =========================
	var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
	var _React$useState3 = reactExports.useState(value), _React$useState4 = _slicedToArray$4(_React$useState3, 2), internalInputValue = _React$useState4[0], setInputValue = _React$useState4[1];
	var _React$useState5 = reactExports.useState(""), _React$useState6 = _slicedToArray$4(_React$useState5, 2), focusCellText = _React$useState6[0], setFocusCellText = _React$useState6[1];
	var _React$useState7 = reactExports.useState(null), _React$useState8 = _slicedToArray$4(_React$useState7, 2), focusCellIndex = _React$useState8[0], setFocusCellIndex = _React$useState8[1];
	var _React$useState9 = reactExports.useState(null), _React$useState10 = _slicedToArray$4(_React$useState9, 2), forceSelectionSyncMark = _React$useState10[0], forceSelectionSync = _React$useState10[1];
	var inputValue = internalInputValue || "";
	// Sync value if needed
	reactExports.useEffect(function() {
		setInputValue(value);
	}, [value]);
	// ========================= Refs =========================
	var holderRef = reactExports.useRef(null);
	var inputRef = reactExports.useRef(null);
	reactExports.useImperativeHandle(ref, function() {
		return {
			nativeElement: holderRef.current,
			inputElement: inputRef.current,
			focus: function(options) {
				inputRef.current.focus(options);
			},
			blur: function() {
				inputRef.current.blur();
			}
		};
	});
	// ======================== Format ========================
	var maskFormat = reactExports.useMemo(function() {
		return new MaskFormat(format || "");
	}, [format]);
	var _React$useMemo = reactExports.useMemo(function() {
		if (helped) {
			return [0, 0];
		}
		return maskFormat.getSelection(focusCellIndex);
	}, [
		maskFormat,
		focusCellIndex,
		helped
	]), _React$useMemo2 = _slicedToArray$4(_React$useMemo, 2), selectionStart = _React$useMemo2[0], selectionEnd = _React$useMemo2[1];
	// ======================== Modify ========================
	// When input modify content, trigger `onHelp` if is not the format
	var onModify = function(text) {
		if (text && text !== format && text !== value) {
			onHelp();
		}
	};
	// ======================== Change ========================
	/**
	* Triggered by paste, keyDown and focus to show format
	*/
	var triggerInputChange = useEvent(function(text) {
		if (validateFormat(text)) {
			onChange(text);
		}
		setInputValue(text);
		onModify(text);
	});
	// Directly trigger `onChange` if `format` is empty
	var onInternalChange = function(event) {
		// Hack `onChange` with format to do nothing
		if (!format) {
			var text = event.target.value;
			onModify(text);
			setInputValue(text);
			onChange(text);
		}
	};
	var onFormatPaste = function(event) {
		// Get paste text
		var pasteText = event.clipboardData.getData("text");
		if (validateFormat(pasteText)) {
			triggerInputChange(pasteText);
		}
	};
	// ======================== Mouse =========================
	// When `mouseDown` get focus, it's better to not to change the selection
	// Since the up position maybe not is the first cell
	var mouseDownRef = reactExports.useRef(false);
	var onFormatMouseDown = function() {
		mouseDownRef.current = true;
	};
	var onFormatMouseUp = function(event) {
		var _ref = event.target, start = _ref.selectionStart;
		var closeMaskIndex = maskFormat.getMaskCellIndex(start);
		setFocusCellIndex(closeMaskIndex);
		// Force update the selection
		forceSelectionSync({});
		onMouseUp === null || onMouseUp === void 0 || onMouseUp(event);
		mouseDownRef.current = false;
	};
	// ====================== Focus Blur ======================
	var onFormatFocus = function(event) {
		setFocused(true);
		setFocusCellIndex(0);
		setFocusCellText("");
		onFocus(event);
	};
	var onSharedBlur = function(event) {
		onBlur(event);
	};
	var onFormatBlur = function(event) {
		setFocused(false);
		onSharedBlur(event);
	};
	// ======================== Active ========================
	// Check if blur need reset input value
	useLockEffect(active, function() {
		if (!active && !preserveInvalidOnBlur) {
			setInputValue(value);
		}
	});
	// ======================= Keyboard =======================
	var onSharedKeyDown = function(event) {
		if (event.key === "Enter" && validateFormat(inputValue)) {
			onSubmit();
		}
		onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);
	};
	var onFormatKeyDown = function(event) {
		onSharedKeyDown(event);
		var key = event.key;
		// Save the cache with cell text
		var nextCellText = null;
		// Fill in the input
		var nextFillText = null;
		var maskCellLen = selectionEnd - selectionStart;
		var cellFormat = format.slice(selectionStart, selectionEnd);
		// Cell Index
		var offsetCellIndex = function(offset) {
			setFocusCellIndex(function(idx) {
				var nextIndex = idx + offset;
				nextIndex = Math.max(nextIndex, 0);
				nextIndex = Math.min(nextIndex, maskFormat.size() - 1);
				return nextIndex;
			});
		};
		// Range
		var offsetCellValue = function(offset) {
			var _getMaskRange = getMaskRange(cellFormat), _getMaskRange2 = _slicedToArray$4(_getMaskRange, 3), rangeStart = _getMaskRange2[0], rangeEnd = _getMaskRange2[1], rangeDefault = _getMaskRange2[2];
			var currentText = inputValue.slice(selectionStart, selectionEnd);
			var currentTextNum = Number(currentText);
			if (isNaN(currentTextNum)) {
				return String(rangeDefault ? rangeDefault : offset > 0 ? rangeStart : rangeEnd);
			}
			var num = currentTextNum + offset;
			var range = rangeEnd - rangeStart + 1;
			return String(rangeStart + (range + num - rangeStart) % range);
		};
		switch (key) {
			case "Backspace":
			case "Delete":
				nextCellText = "";
				nextFillText = cellFormat;
				break;
			case "ArrowLeft":
				nextCellText = "";
				offsetCellIndex(-1);
				break;
			case "ArrowRight":
				nextCellText = "";
				offsetCellIndex(1);
				break;
			case "ArrowUp":
				nextCellText = "";
				nextFillText = offsetCellValue(1);
				break;
			case "ArrowDown":
				nextCellText = "";
				nextFillText = offsetCellValue(-1);
				break;
			default:
				if (!isNaN(Number(key))) {
					nextCellText = focusCellText + key;
					nextFillText = nextCellText;
				}
				break;
		}
		// Update cell text
		if (nextCellText !== null) {
			setFocusCellText(nextCellText);
			if (nextCellText.length >= maskCellLen) {
				// Go to next cell
				offsetCellIndex(1);
				setFocusCellText("");
			}
		}
		// Update the input text
		if (nextFillText !== null) {
			// Replace selection range with `nextCellText`
			var nextFocusValue = inputValue.slice(0, selectionStart) + leftPad(nextFillText, maskCellLen) + inputValue.slice(selectionEnd);
			triggerInputChange(nextFocusValue.slice(0, format.length));
		}
		// Always trigger selection sync after key down
		forceSelectionSync({});
	};
	// ======================== Format ========================
	var rafRef = reactExports.useRef();
	useLayoutEffect(function() {
		if (!focused || !format || mouseDownRef.current) {
			return;
		}
		// Reset with format if not match
		if (!maskFormat.match(inputValue)) {
			triggerInputChange(format);
			return;
		}
		// Match the selection range
		inputRef.current.setSelectionRange(selectionStart, selectionEnd);
		// Chrome has the bug anchor position looks not correct but actually correct
		rafRef.current = wrapperRaf(function() {
			inputRef.current.setSelectionRange(selectionStart, selectionEnd);
		});
		return function() {
			wrapperRaf.a(rafRef.current);
		};
	}, [
		maskFormat,
		format,
		focused,
		inputValue,
		focusCellIndex,
		selectionStart,
		selectionEnd,
		forceSelectionSyncMark,
		triggerInputChange
	]);
	// ======================== Render ========================
	// Input props for format
	var inputProps = format ? {
		onFocus: onFormatFocus,
		onBlur: onFormatBlur,
		onKeyDown: onFormatKeyDown,
		onMouseDown: onFormatMouseDown,
		onMouseUp: onFormatMouseUp,
		onPaste: onFormatPaste
	} : {};
	return reactExports.createElement("div", {
		ref: holderRef,
		className: clsx(inputPrefixCls, _defineProperty$5(_defineProperty$5({}, "".concat(inputPrefixCls, "-active"), active && showActiveCls), "".concat(inputPrefixCls, "-placeholder"), helped), className)
	}, reactExports.createElement(Component, _extends$7({
		ref: inputRef,
		"aria-invalid": invalid,
		autoComplete: "off"
	}, restProps, {
		onKeyDown: onSharedKeyDown,
		onBlur: onSharedBlur
	}, inputProps, {
		value: inputValue,
		onChange: onInternalChange,
		className: classNames.input,
		style: styles.input
	})), reactExports.createElement(Icon, {
		type: "suffix",
		icon: suffixIcon
	}), clearIcon);
});
var Input$1 = Input;
var _excluded$1 = [
	"id",
	"prefix",
	"clearIcon",
	"suffixIcon",
	"separator",
	"activeIndex",
	"activeHelp",
	"allHelp",
	"focused",
	"onFocus",
	"onBlur",
	"onKeyDown",
	"locale",
	"generateConfig",
	"placeholder",
	"className",
	"style",
	"onClick",
	"onClear",
	"value",
	"onChange",
	"onSubmit",
	"onInputChange",
	"format",
	"maskFormat",
	"preserveInvalidOnBlur",
	"onInvalid",
	"disabled",
	"invalid",
	"inputReadOnly",
	"direction",
	"onOpenChange",
	"onActiveInfo",
	"placement",
	"onMouseDown",
	"required",
	"aria-required",
	"autoFocus",
	"tabIndex"
], _excluded2 = ["index"];
function _extends$6() {
	_extends$6 = Object.assign.bind();
	return _extends$6.apply(this, arguments);
}
function ownKeys$4(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$4(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$4(Object(t), true).forEach(function(r) {
			_defineProperty$4(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$4(obj, key, value) {
	key = _toPropertyKey$4(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$4(t) {
	var i = _toPrimitive$4(t);
	return "symbol" == _typeof$4(i) ? i : String(i);
}
function _toPrimitive$4(t) {
	if ("object" != _typeof$4(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$4(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$3(arr, i) {
	return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$3(o, 2);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$3(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$3(arr) {
	if (Array.isArray(arr)) return arr;
}
function _typeof$4(o) {
	"@babel/helpers - typeof";
	return _typeof$4 = function(o) {
		return typeof o;
	}, _typeof$4(o);
}
function _objectWithoutProperties$1(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$1(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function RangeSelector(props, ref) {
	var id = props.id, prefix = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon, _props$separator = props.separator, separator = _props$separator === void 0 ? "~" : _props$separator, activeIndex = props.activeIndex;
	var focused = props.focused;
	var placeholder = props.placeholder, className = props.className, style = props.style, onClick = props.onClick, onClear = props.onClear, value = props.value;
	var disabled = props.disabled, invalid = props.invalid;
	var direction = props.direction;
	var onActiveInfo = props.onActiveInfo;
	var _onMouseDown = props.onMouseDown;
	var autoFocus = props.autoFocus, tabIndex = props.tabIndex, restProps = _objectWithoutProperties$1(props, _excluded$1);
	var rtl = direction === "rtl";
	// ======================== Prefix ========================
	var _React$useContext = reactExports.useContext(PickerContext$1), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	// ========================== Id ==========================
	var ids = reactExports.useMemo(function() {
		if (typeof id === "string") {
			return [id];
		}
		var mergedId = id || {};
		return [mergedId.start, mergedId.end];
	}, [id]);
	// ========================= Refs =========================
	var rootRef = reactExports.useRef();
	var inputStartRef = reactExports.useRef();
	var inputEndRef = reactExports.useRef();
	var getInput = function(index) {
		var _index;
		return (_index = [inputStartRef, inputEndRef][index]) === null || _index === void 0 ? void 0 : _index.current;
	};
	reactExports.useImperativeHandle(ref, function() {
		return {
			nativeElement: rootRef.current,
			focus: function(options) {
				if (_typeof$4(options) === "object") {
					var _getInput;
					var _ref = options || {}, _ref$index = _ref.index, _index2 = _ref$index === void 0 ? 0 : _ref$index, rest = _objectWithoutProperties$1(_ref, _excluded2);
					(_getInput = getInput(_index2)) === null || _getInput === void 0 || _getInput.focus(rest);
				} else {
					var _getInput2;
					(_getInput2 = getInput(options !== null && options !== void 0 ? options : 0)) === null || _getInput2 === void 0 || _getInput2.focus();
				}
			},
			blur: function() {
				var _getInput3, _getInput4;
				(_getInput3 = getInput(0)) === null || _getInput3 === void 0 || _getInput3.blur();
				(_getInput4 = getInput(1)) === null || _getInput4 === void 0 || _getInput4.blur();
			}
		};
	});
	// ======================== Props =========================
	var rootProps = useRootProps(restProps);
	// ===================== Placeholder ======================
	var mergedPlaceholder = reactExports.useMemo(function() {
		return Array.isArray(placeholder) ? placeholder : [placeholder, placeholder];
	}, [placeholder]);
	// ======================== Inputs ========================
	var _useInputProps = useInputProps(_objectSpread$4(_objectSpread$4({}, props), {}, {
		id: ids,
		placeholder: mergedPlaceholder
	})), _useInputProps2 = _slicedToArray$3(_useInputProps, 1), getInputProps = _useInputProps2[0];
	// ====================== ActiveBar =======================
	var _React$useState = reactExports.useState({
		position: "absolute",
		width: 0
	}), _React$useState2 = _slicedToArray$3(_React$useState, 2), activeBarStyle = _React$useState2[0], setActiveBarStyle = _React$useState2[1];
	var syncActiveOffset = useEvent(function() {
		var input = getInput(activeIndex);
		if (input) {
			var inputRect = input.nativeElement.getBoundingClientRect();
			var parentRect = rootRef.current.getBoundingClientRect();
			var rectOffset = inputRect.left - parentRect.left;
			setActiveBarStyle(function(ori) {
				return _objectSpread$4(_objectSpread$4({}, ori), {}, {
					width: inputRect.width,
					left: rectOffset
				});
			});
			onActiveInfo([
				inputRect.left,
				inputRect.right,
				parentRect.width
			]);
		}
	});
	reactExports.useEffect(function() {
		syncActiveOffset();
	}, [activeIndex]);
	// ======================== Clear =========================
	var showClear = clearIcon && (value[0] && !disabled[0] || value[1] && !disabled[1]);
	// ======================= Disabled =======================
	var startAutoFocus = autoFocus && !disabled[0];
	var endAutoFocus = autoFocus && !startAutoFocus && !disabled[1];
	// ======================== Render ========================
	return reactExports.createElement(RefResizeObserver, { onResize: syncActiveOffset }, reactExports.createElement("div", _extends$6({}, rootProps, {
		className: clsx(prefixCls, "".concat(prefixCls, "-range"), _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4({}, "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled.every(function(i) {
			return i;
		})), "".concat(prefixCls, "-invalid"), invalid.some(function(i) {
			return i;
		})), "".concat(prefixCls, "-rtl"), rtl), className),
		style,
		ref: rootRef,
		onClick,
		onMouseDown: function(e) {
			var target = e.target;
			if (target !== inputStartRef.current.inputElement && target !== inputEndRef.current.inputElement) {
				e.preventDefault();
			}
			_onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e);
		}
	}), prefix && reactExports.createElement("div", {
		className: clsx("".concat(prefixCls, "-prefix"), classNames.prefix),
		style: styles.prefix
	}, prefix), reactExports.createElement(Input$1, _extends$6({ ref: inputStartRef }, getInputProps(0), {
		className: "".concat(prefixCls, "-input-start"),
		autoFocus: startAutoFocus,
		tabIndex,
		"date-range": "start"
	})), reactExports.createElement("div", { className: "".concat(prefixCls, "-range-separator") }, separator), reactExports.createElement(Input$1, _extends$6({ ref: inputEndRef }, getInputProps(1), {
		className: "".concat(prefixCls, "-input-end"),
		autoFocus: endAutoFocus,
		tabIndex,
		"date-range": "end"
	})), reactExports.createElement("div", {
		className: "".concat(prefixCls, "-active-bar"),
		style: activeBarStyle
	}), reactExports.createElement(Icon, {
		type: "suffix",
		icon: suffixIcon
	}), showClear && reactExports.createElement(ClearIcon, {
		icon: clearIcon,
		onClear
	})));
}
var RefRangeSelector = reactExports.forwardRef(RangeSelector);
var RangeSelector$1 = RefRangeSelector;
function _typeof$3(o) {
	"@babel/helpers - typeof";
	return _typeof$3 = function(o) {
		return typeof o;
	}, _typeof$3(o);
}
function ownKeys$3(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$3(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$3(Object(t), true).forEach(function(r) {
			_defineProperty$3(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$3(obj, key, value) {
	key = _toPropertyKey$3(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$3(t) {
	var i = _toPrimitive$3(t);
	return "symbol" == _typeof$3(i) ? i : String(i);
}
function _toPrimitive$3(t) {
	if ("object" != _typeof$3(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$3(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
/**
* Convert `classNames` & `styles` to a fully filled object
*/
function useSemantic(classNames, styles) {
	return reactExports.useMemo(function() {
		var mergedClassNames = _objectSpread$3(_objectSpread$3({}, classNames), {}, { popup: (classNames === null || classNames === void 0 ? void 0 : classNames.popup) || {} });
		var mergedStyles = _objectSpread$3(_objectSpread$3({}, styles), {}, { popup: (styles === null || styles === void 0 ? void 0 : styles.popup) || {} });
		return [mergedClassNames, mergedStyles];
	}, [classNames, styles]);
}
function _typeof$2(o) {
	"@babel/helpers - typeof";
	return _typeof$2 = function(o) {
		return typeof o;
	}, _typeof$2(o);
}
function _extends$5() {
	_extends$5 = Object.assign.bind();
	return _extends$5.apply(this, arguments);
}
function _toConsumableArray$1(arr) {
	return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$1(iter) {
	if (iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);
}
function ownKeys$2(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$2(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$2(Object(t), true).forEach(function(r) {
			_defineProperty$2(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$2(obj, key, value) {
	key = _toPropertyKey$2(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey$2(t) {
	var i = _toPrimitive$2(t);
	return "symbol" == _typeof$2(i) ? i : String(i);
}
function _toPrimitive$2(t) {
	if ("object" != _typeof$2(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$2(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$2(arr, i) {
	return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$2(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$2(arr) {
	if (Array.isArray(arr)) return arr;
}
function separateConfig(config) {
	var singleConfig = config !== null && config !== void 0 ? config : false;
	if (Array.isArray(singleConfig)) {
		return singleConfig;
	}
	return [singleConfig, singleConfig];
}
/** Used for change event, it should always be not undefined */
function getActiveRange(activeIndex) {
	return activeIndex === 1 ? "end" : "start";
}
function RangePicker(props, ref) {
	// ========================= Prop =========================
	var _useFilledProps = useFilledProps(props, function() {
		var disabled = props.disabled, allowEmpty = props.allowEmpty;
		var mergedDisabled = separateConfig(disabled);
		var mergedAllowEmpty = separateConfig(allowEmpty);
		return {
			disabled: mergedDisabled,
			allowEmpty: mergedAllowEmpty
		};
	}), _useFilledProps2 = _slicedToArray$2(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
	var prefixCls = filledProps.prefixCls, rootClassName = filledProps.rootClassName, propStyles = filledProps.styles, propClassNames = filledProps.classNames, previewValue = filledProps.previewValue, defaultValue = filledProps.defaultValue, value = filledProps.value, needConfirm = filledProps.needConfirm, onKeyDown = filledProps.onKeyDown, disabled = filledProps.disabled, allowEmpty = filledProps.allowEmpty, disabledDate = filledProps.disabledDate, minDate = filledProps.minDate, maxDate = filledProps.maxDate, defaultOpen = filledProps.defaultOpen, open = filledProps.open, onOpenChange = filledProps.onOpenChange, locale = filledProps.locale, generateConfig = filledProps.generateConfig, picker = filledProps.picker, showNow = filledProps.showNow, showToday = filledProps.showToday, showTime = filledProps.showTime, mode = filledProps.mode, onPanelChange = filledProps.onPanelChange, onCalendarChange = filledProps.onCalendarChange, onOk = filledProps.onOk, defaultPickerValue = filledProps.defaultPickerValue, pickerValue = filledProps.pickerValue, onPickerValueChange = filledProps.onPickerValueChange, inputReadOnly = filledProps.inputReadOnly, suffixIcon = filledProps.suffixIcon, onFocus = filledProps.onFocus, onBlur = filledProps.onBlur, presets = filledProps.presets, ranges = filledProps.ranges, components = filledProps.components, cellRender = filledProps.cellRender, dateRender = filledProps.dateRender, monthCellRender = filledProps.monthCellRender, onClick = filledProps.onClick;
	// ========================= Refs =========================
	var selectorRef = usePickerRef(ref);
	// ======================= Semantic =======================
	var _useSemantic = useSemantic(propClassNames, propStyles), _useSemantic2 = _slicedToArray$2(_useSemantic, 2), mergedClassNames = _useSemantic2[0], mergedStyles = _useSemantic2[1];
	// ========================= Open =========================
	var _useOpen = useOpen(open, defaultOpen, disabled, onOpenChange), _useOpen2 = _slicedToArray$2(_useOpen, 2), mergedOpen = _useOpen2[0], setMergeOpen = _useOpen2[1];
	var triggerOpen = function(nextOpen, config) {
		// No need to open if all disabled
		if (disabled.some(function(fieldDisabled) {
			return !fieldDisabled;
		}) || !nextOpen) {
			setMergeOpen(nextOpen, config);
		}
	};
	// ======================== Values ========================
	var _useInnerValue = useInnerValue(generateConfig, locale, formatList, true, 0, defaultValue, value, onCalendarChange, onOk), _useInnerValue2 = _slicedToArray$2(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
	var calendarValue = getCalendarValue();
	// ======================== Active ========================
	var _useRangeActive = useRangeActive(disabled, allowEmpty, mergedOpen), _useRangeActive2 = _slicedToArray$2(_useRangeActive, 9), focused = _useRangeActive2[0], triggerFocus = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3], setActiveIndex = _useRangeActive2[4], nextActiveIndex = _useRangeActive2[5], activeIndexList = _useRangeActive2[6], updateSubmitIndex = _useRangeActive2[7], hasActiveSubmitValue = _useRangeActive2[8];
	var onSharedFocus = function(event, index) {
		triggerFocus(true);
		onFocus === null || onFocus === void 0 || onFocus(event, { range: getActiveRange(index !== null && index !== void 0 ? index : activeIndex) });
	};
	var onSharedBlur = function(event, index) {
		triggerFocus(false);
		onBlur === null || onBlur === void 0 || onBlur(event, { range: getActiveRange(index !== null && index !== void 0 ? index : activeIndex) });
	};
	// ======================= ShowTime =======================
	/** Used for Popup panel */
	var mergedShowTime = reactExports.useMemo(function() {
		if (!showTime) {
			return null;
		}
		var disabledTime = showTime.disabledTime;
		var proxyDisabledTime = disabledTime ? function(date) {
			var range = getActiveRange(activeIndex);
			var fromDate = getFromDate(calendarValue, activeIndexList, activeIndex);
			return disabledTime(date, range, { from: fromDate });
		} : void 0;
		return _objectSpread$2(_objectSpread$2({}, showTime), {}, { disabledTime: proxyDisabledTime });
	}, [
		showTime,
		activeIndex,
		calendarValue,
		activeIndexList
	]);
	// ========================= Mode =========================
	var _useControlledState = useControlledState([picker, picker], mode), _useControlledState2 = _slicedToArray$2(_useControlledState, 2), modes = _useControlledState2[0], setModes = _useControlledState2[1];
	var mergedMode = modes[activeIndex] || picker;
	/** Extends from `mergedMode` to patch `datetime` mode */
	var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
	// ====================== PanelCount ======================
	var multiplePanel = internalMode === picker && internalMode !== "time";
	// ======================= Show Now =======================
	var mergedShowNow = useShowNow(0, mergedMode, showNow, showToday, true);
	// ======================== Value =========================
	var _useRangeValue = useRangeValue(filledProps, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, mergedOpen, isInvalidateDate), _useRangeValue2 = _slicedToArray$2(_useRangeValue, 2), flushSubmit = _useRangeValue2[0], triggerSubmitChange = _useRangeValue2[1];
	// ===================== DisabledDate =====================
	var mergedDisabledDate = useRangeDisabledDate(calendarValue, disabled, activeIndexList, generateConfig, locale, disabledDate);
	// ======================= Validate =======================
	var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate, allowEmpty), _useFieldsInvalidate2 = _slicedToArray$2(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
	// ===================== Picker Value =====================
	var _useRangePickerValue = useRangePickerValue(generateConfig, locale, calendarValue, modes, mergedOpen, activeIndex, internalPicker, multiplePanel, defaultPickerValue, pickerValue, mergedShowTime === null || mergedShowTime === void 0 ? void 0 : mergedShowTime.defaultOpenValue, onPickerValueChange, minDate, maxDate), _useRangePickerValue2 = _slicedToArray$2(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
	// >>> Mode need wait for `pickerValue`
	var triggerModeChange = useEvent(function(nextPickerValue, nextMode, triggerEvent) {
		var clone = fillIndex(modes, activeIndex, nextMode);
		if (clone[0] !== modes[0] || clone[1] !== modes[1]) {
			setModes(clone);
		}
		// Compatible with `onPanelChange`
		if (onPanelChange && triggerEvent !== false) {
			var clonePickerValue = _toConsumableArray$1(calendarValue);
			if (nextPickerValue) {
				clonePickerValue[activeIndex] = nextPickerValue;
			}
			onPanelChange(clonePickerValue, clone);
		}
	});
	// ======================== Change ========================
	var fillCalendarValue = function(date, index) {
		return fillIndex(calendarValue, index, date);
	};
	// ======================== Submit ========================
	/**
	* Trigger by confirm operation.
	* This function has already handle the `needConfirm` check logic.
	* - Selector: enter key
	* - Panel: OK button
	*/
	var triggerPartConfirm = function(date, skipFocus) {
		var nextValue = calendarValue;
		if (date) {
			nextValue = fillCalendarValue(date, activeIndex);
		}
		updateSubmitIndex(activeIndex);
		// Get next focus index
		var nextIndex = nextActiveIndex(nextValue);
		// Change calendar value and tell flush it
		triggerCalendarChange(nextValue);
		flushSubmit(activeIndex, nextIndex === null);
		if (nextIndex === null) {
			triggerOpen(false, { force: true });
		} else if (!skipFocus) {
			selectorRef.current.focus({ index: nextIndex });
		}
	};
	// ======================== Click =========================
	var onSelectorClick = function(event) {
		var _activeElement;
		var rootNode = event.target.getRootNode();
		if (!selectorRef.current.nativeElement.contains((_activeElement = rootNode.activeElement) !== null && _activeElement !== void 0 ? _activeElement : document.activeElement)) {
			// Click to focus the enabled input
			var enabledIndex = disabled.findIndex(function(d) {
				return !d;
			});
			if (enabledIndex >= 0) {
				selectorRef.current.focus({ index: enabledIndex });
			}
		}
		triggerOpen(true);
		onClick === null || onClick === void 0 || onClick(event);
	};
	var onSelectorClear = function() {
		triggerSubmitChange(null);
		triggerOpen(false, { force: true });
	};
	// ======================== Hover =========================
	var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray$2(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
	var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray$2(_React$useState3, 2), internalHoverValues = _React$useState4[0], setInternalHoverValues = _React$useState4[1];
	var hoverValues = reactExports.useMemo(function() {
		return internalHoverValues || calendarValue;
	}, [calendarValue, internalHoverValues]);
	// Clean up `internalHoverValues` when closed
	reactExports.useEffect(function() {
		if (!mergedOpen) {
			setInternalHoverValues(null);
		}
	}, [mergedOpen]);
	// ========================================================
	// ==                       Panels                       ==
	// ========================================================
	// Save the offset with active bar position
	// const [activeOffset, setActiveOffset] = React.useState(0);
	var _React$useState5 = reactExports.useState([
		0,
		0,
		0
	]), _React$useState6 = _slicedToArray$2(_React$useState5, 2), activeInfo = _React$useState6[0], setActiveInfo = _React$useState6[1];
	var onSetHover = function(date, source) {
		if (previewValue !== "hover") {
			return;
		}
		setInternalHoverValues(date);
		setHoverSource(source);
	};
	// ======================= Presets ========================
	var presetList = usePresets(presets, ranges);
	var onPresetHover = function(nextValues) {
		onSetHover(nextValues, "preset");
	};
	var onPresetSubmit = function(nextValues) {
		var passed = triggerSubmitChange(nextValues);
		if (passed) {
			triggerOpen(false, { force: true });
		}
	};
	var onNow = function(now) {
		triggerPartConfirm(now);
	};
	// ======================== Panel =========================
	var onPanelHover = function(date) {
		onSetHover(date ? fillCalendarValue(date, activeIndex) : null, "cell");
	};
	// >>> Focus
	var onPanelFocus = function(event) {
		triggerOpen(true);
		onSharedFocus(event);
	};
	// >>> MouseDown
	var onPanelMouseDown = function() {
		lastOperation("panel");
	};
	// >>> Calendar
	var onPanelSelect = function(date) {
		var clone = fillIndex(calendarValue, activeIndex, date);
		// Only trigger calendar event but not update internal `calendarValue` state
		triggerCalendarChange(clone);
		// >>> Trigger next active if !needConfirm
		// Fully logic check `useRangeValue` hook
		if (!needConfirm && !complexPicker && internalPicker === internalMode) {
			triggerPartConfirm(date);
		}
	};
	// >>> Close
	var onPopupClose = function() {
		// Close popup
		triggerOpen(false);
	};
	// >>> cellRender
	var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender, getActiveRange(activeIndex));
	// >>> Value
	var panelValue = calendarValue[activeIndex] || null;
	// >>> invalid
	var isPopupInvalidateDate = useEvent(function(date) {
		return isInvalidateDate(date, { activeIndex });
	});
	var panelProps = reactExports.useMemo(function() {
		var domProps = pickAttrs(filledProps, false);
		var restProps = omit(filledProps, [].concat(_toConsumableArray$1(Object.keys(domProps)), [
			"onChange",
			"onCalendarChange",
			"style",
			"className",
			"onPanelChange",
			"disabledTime",
			"classNames",
			"styles"
		]));
		return restProps;
	}, [filledProps]);
	// >>> Render
	var panel = reactExports.createElement(Popup, _extends$5({}, panelProps, {
		showNow: mergedShowNow,
		showTime: mergedShowTime,
		range: true,
		multiplePanel,
		activeInfo,
		disabledDate: mergedDisabledDate,
		onFocus: onPanelFocus,
		onBlur: onSharedBlur,
		onPanelMouseDown,
		picker,
		mode: mergedMode,
		internalMode,
		onPanelChange: triggerModeChange,
		format: maskFormat,
		value: panelValue,
		isInvalid: isPopupInvalidateDate,
		onChange: null,
		onSelect: onPanelSelect,
		pickerValue: currentPickerValue,
		defaultOpenValue: toArray(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue)[activeIndex],
		onPickerValueChange: setCurrentPickerValue,
		hoverValue: hoverValues,
		onHover: onPanelHover,
		needConfirm,
		onSubmit: triggerPartConfirm,
		onOk: triggerOk,
		presets: presetList,
		onPresetHover,
		onPresetSubmit,
		onNow,
		cellRender: onInternalCellRender,
		classNames: mergedClassNames,
		styles: mergedStyles
	}));
	// ========================================================
	// ==                      Selector                      ==
	// ========================================================
	// ======================== Change ========================
	var onSelectorChange = function(date, index) {
		var clone = fillCalendarValue(date, index);
		triggerCalendarChange(clone);
	};
	var onSelectorInputChange = function() {
		lastOperation("input");
	};
	// ======================= Selector =======================
	var onSelectorFocus = function(event, index) {
		// Check if `needConfirm` but user not submit yet
		var activeListLen = activeIndexList.length;
		var lastActiveIndex = activeIndexList[activeListLen - 1];
		if (activeListLen && lastActiveIndex !== index && needConfirm && !allowEmpty[lastActiveIndex] && !hasActiveSubmitValue(lastActiveIndex) && calendarValue[lastActiveIndex]) {
			selectorRef.current.focus({ index: lastActiveIndex });
			return;
		}
		lastOperation("input");
		triggerOpen(true, { inherit: true });
		// When click input to switch the field, it will not trigger close.
		// Which means it will lose the part confirm and we need fill back.
		// ref: https://github.com/ant-design/ant-design/issues/49512
		if (activeIndex !== index && mergedOpen && !needConfirm && complexPicker) {
			triggerPartConfirm(null, true);
		}
		setActiveIndex(index);
		onSharedFocus(event, index);
	};
	var onSelectorBlur = function(event, index) {
		triggerOpen(false);
		if (!needConfirm && lastOperation() === "input") {
			var nextIndex = nextActiveIndex(calendarValue);
			flushSubmit(activeIndex, nextIndex === null);
		}
		onSharedBlur(event, index);
	};
	var onSelectorKeyDown = function(event, preventDefault) {
		if (event.key === "Tab") {
			triggerPartConfirm(null, true);
		}
		onKeyDown === null || onKeyDown === void 0 || onKeyDown(event, preventDefault);
	};
	// ======================= Context ========================
	var context = reactExports.useMemo(function() {
		return {
			prefixCls,
			locale,
			generateConfig,
			button: components.button,
			input: components.input,
			classNames: mergedClassNames,
			styles: mergedStyles
		};
	}, [
		prefixCls,
		locale,
		generateConfig,
		components.button,
		components.input,
		mergedClassNames,
		mergedStyles
	]);
	// ======================== Effect ========================
	// >>> Mode
	// Reset for every active
	useLayoutEffect(function() {
		if (mergedOpen && activeIndex !== void 0) {
			// Legacy compatible. This effect update should not trigger `onPanelChange`
			triggerModeChange(null, picker, false);
		}
	}, [
		mergedOpen,
		activeIndex,
		picker
	]);
	// >>> For complex picker, we need check if need to focus next one
	useLayoutEffect(function() {
		var lastOp = lastOperation();
		// Trade as confirm on field leave
		if (!mergedOpen && lastOp === "input") {
			triggerOpen(false);
			triggerPartConfirm(null, true);
		}
		// Submit with complex picker
		if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
			triggerOpen(true);
			triggerPartConfirm();
		}
	}, [mergedOpen]);
	// ======================== Render ========================
	return reactExports.createElement(PickerContext$1.Provider, { value: context }, reactExports.createElement(PickerTrigger, _extends$5({}, pickTriggerProps(filledProps), {
		popupElement: panel,
		popupStyle: mergedStyles.popup.root,
		popupClassName: clsx(rootClassName, mergedClassNames.popup.root),
		visible: mergedOpen,
		onClose: onPopupClose,
		range: true
	}), reactExports.createElement(RangeSelector$1, _extends$5({}, filledProps, {
		ref: selectorRef,
		className: clsx(filledProps.className, rootClassName, mergedClassNames.root),
		style: _objectSpread$2(_objectSpread$2({}, mergedStyles.root), filledProps.style),
		suffixIcon,
		activeIndex: focused || mergedOpen ? activeIndex : null,
		activeHelp: !!internalHoverValues,
		allHelp: !!internalHoverValues && hoverSource === "preset",
		focused,
		onFocus: onSelectorFocus,
		onBlur: onSelectorBlur,
		onKeyDown: onSelectorKeyDown,
		onSubmit: triggerPartConfirm,
		value: hoverValues,
		maskFormat,
		onChange: onSelectorChange,
		onInputChange: onSelectorInputChange,
		format: formatList,
		inputReadOnly,
		disabled,
		open: mergedOpen,
		onOpenChange: triggerOpen,
		onClick: onSelectorClick,
		onClear: onSelectorClear,
		invalid: submitInvalidates,
		onInvalid: onSelectorInvalid,
		onActiveInfo: setActiveInfo
	}))));
}
var RefRangePicker = reactExports.forwardRef(RangePicker);
var RCRangePicker = RefRangePicker;
function MultipleDates(props) {
	var prefixCls = props.prefixCls, value = props.value, onRemove = props.onRemove, _props$removeIcon = props.removeIcon, removeIcon = _props$removeIcon === void 0 ? "" : _props$removeIcon, formatDate = props.formatDate, disabled = props.disabled, maxTagCount = props.maxTagCount, placeholder = props.placeholder;
	var selectorCls = "".concat(prefixCls, "-selector");
	var selectionCls = "".concat(prefixCls, "-selection");
	var overflowCls = "".concat(selectionCls, "-overflow");
	// ========================= Item =========================
	function renderSelector(content, onClose) {
		return reactExports.createElement("span", {
			className: clsx("".concat(selectionCls, "-item")),
			title: typeof content === "string" ? content : null
		}, reactExports.createElement("span", { className: "".concat(selectionCls, "-item-content") }, content), !disabled && onClose && reactExports.createElement("span", {
			onMouseDown: function(e) {
				e.preventDefault();
			},
			onClick: onClose,
			className: "".concat(selectionCls, "-item-remove")
		}, removeIcon));
	}
	function renderItem(date) {
		var displayLabel = formatDate(date);
		var onClose = function(event) {
			if (event) event.stopPropagation();
			onRemove(date);
		};
		return renderSelector(displayLabel, onClose);
	}
	// ========================= Rest =========================
	function renderRest(omittedValues) {
		var content = "+ ".concat(omittedValues.length, " ...");
		return renderSelector(content);
	}
	// ======================== Render ========================
	return reactExports.createElement("div", { className: selectorCls }, reactExports.createElement(ForwardOverflow, {
		prefixCls: overflowCls,
		data: value,
		renderItem,
		renderRest,
		itemKey: function(date) {
			return formatDate(date);
		},
		maxCount: maxTagCount
	}), !value.length && reactExports.createElement("span", { className: "".concat(prefixCls, "-selection-placeholder") }, placeholder));
}
function _typeof$1(o) {
	"@babel/helpers - typeof";
	return _typeof$1 = function(o) {
		return typeof o;
	}, _typeof$1(o);
}
var _excluded = [
	"id",
	"open",
	"prefix",
	"clearIcon",
	"suffixIcon",
	"activeHelp",
	"allHelp",
	"focused",
	"onFocus",
	"onBlur",
	"onKeyDown",
	"locale",
	"generateConfig",
	"placeholder",
	"className",
	"style",
	"onClick",
	"onClear",
	"internalPicker",
	"value",
	"onChange",
	"onSubmit",
	"onInputChange",
	"multiple",
	"maxTagCount",
	"format",
	"maskFormat",
	"preserveInvalidOnBlur",
	"onInvalid",
	"disabled",
	"invalid",
	"inputReadOnly",
	"direction",
	"onOpenChange",
	"onMouseDown",
	"required",
	"aria-required",
	"autoFocus",
	"tabIndex",
	"removeIcon"
];
function _extends$4() {
	_extends$4 = Object.assign.bind();
	return _extends$4.apply(this, arguments);
}
function ownKeys$1(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$1(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$1(Object(t), true).forEach(function(r) {
			_defineProperty$1(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty$1(obj, key, value) {
	key = _toPropertyKey$1(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return obj;
}
function _toPropertyKey$1(t) {
	var i = _toPrimitive$1(t);
	return "symbol" == _typeof$1(i) ? i : String(i);
}
function _toPrimitive$1(t) {
	if ("object" != _typeof$1(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof$1(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray$1(arr) {
	return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o) {
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, 2);
}
function _arrayLikeToArray$1(arr, len) {
	if (2 == null || 2 > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$1(r) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== 2); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles$1(arr) {
	if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function SingleSelector(props, ref) {
	var open = props.open, prefix = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon;
	var focused = props.focused;
	var locale = props.locale, generateConfig = props.generateConfig, placeholder = props.placeholder, className = props.className, style = props.style, onClick = props.onClick, onClear = props.onClear, internalPicker = props.internalPicker, value = props.value, onChange = props.onChange, onSubmit = props.onSubmit;
	var multiple = props.multiple, maxTagCount = props.maxTagCount;
	var disabled = props.disabled, invalid = props.invalid;
	var direction = props.direction;
	var _onMouseDown = props.onMouseDown;
	var autoFocus = props.autoFocus, tabIndex = props.tabIndex, removeIcon = props.removeIcon, restProps = _objectWithoutProperties(props, _excluded);
	var rtl = direction === "rtl";
	// ======================== Prefix ========================
	var _React$useContext = reactExports.useContext(PickerContext$1), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	// ========================= Refs =========================
	var rootRef = reactExports.useRef();
	var inputRef = reactExports.useRef();
	reactExports.useImperativeHandle(ref, function() {
		return {
			nativeElement: rootRef.current,
			focus: function(options) {
				var _inputRef$current;
				(_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options);
			},
			blur: function() {
				var _inputRef$current2;
				(_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
			}
		};
	});
	// ======================== Props =========================
	var rootProps = useRootProps(restProps);
	// ======================== Change ========================
	var onSingleChange = function(date) {
		onChange([date]);
	};
	var onMultipleRemove = function(date) {
		var nextValues = value.filter(function(oriDate) {
			return oriDate && !isSame(generateConfig, locale, oriDate, date, internalPicker);
		});
		onChange(nextValues);
		// When `open`, it means user is operating the
		if (!open) {
			onSubmit();
		}
	};
	// ======================== Inputs ========================
	var _useInputProps = useInputProps(_objectSpread$1(_objectSpread$1({}, props), {}, { onChange: onSingleChange }), function(_ref) {
		var valueTexts = _ref.valueTexts;
		return {
			value: valueTexts[0] || "",
			active: focused
		};
	}), _useInputProps2 = _slicedToArray$1(_useInputProps), getInputProps = _useInputProps2[0], getText = _useInputProps2[1];
	// ======================== Clear =========================
	var showClear = !!(clearIcon && value.length && !disabled);
	// ======================= Multiple =======================
	var selectorNode = multiple ? reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(MultipleDates, {
		prefixCls,
		value,
		onRemove: onMultipleRemove,
		formatDate: getText,
		maxTagCount,
		disabled,
		removeIcon,
		placeholder
	}), reactExports.createElement("input", {
		className: "".concat(prefixCls, "-multiple-input"),
		value: value.map(getText).join(","),
		ref: inputRef,
		readOnly: true,
		autoFocus,
		tabIndex
	}), reactExports.createElement(Icon, {
		type: "suffix",
		icon: suffixIcon
	}), showClear && reactExports.createElement(ClearIcon, {
		icon: clearIcon,
		onClear
	})) : reactExports.createElement(Input$1, _extends$4({ ref: inputRef }, getInputProps(), {
		autoFocus,
		tabIndex,
		suffixIcon,
		clearIcon: showClear && reactExports.createElement(ClearIcon, {
			icon: clearIcon,
			onClear
		}),
		showActiveCls: false
	}));
	// ======================== Render ========================
	return reactExports.createElement("div", _extends$4({}, rootProps, {
		className: clsx(prefixCls, _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1({}, "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-invalid"), invalid), "".concat(prefixCls, "-rtl"), rtl), className),
		style,
		ref: rootRef,
		onClick,
		onMouseDown: function(e) {
			var _inputRef$current3;
			var target = e.target;
			if (target !== ((_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.inputElement)) {
				e.preventDefault();
			}
			_onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e);
		}
	}), prefix && reactExports.createElement("div", {
		className: clsx("".concat(prefixCls, "-prefix"), classNames.prefix),
		style: styles.prefix
	}, prefix), selectorNode);
}
var RefSingleSelector = reactExports.forwardRef(SingleSelector);
var SingleSelector$1 = RefSingleSelector;
function _typeof(o) {
	"@babel/helpers - typeof";
	return _typeof = function(o) {
		return typeof o;
	}, _typeof(o);
}
function _extends$3() {
	_extends$3 = Object.assign.bind();
	return _extends$3.apply(this, arguments);
}
function _toConsumableArray(arr) {
	return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
	if (iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function ownKeys(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys(Object(t), true).forEach(function(r) {
			_defineProperty(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
function _defineProperty(obj, key, value) {
	key = _toPropertyKey(key);
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}
	return;
}
function _toPropertyKey(t) {
	var i = _toPrimitive(t);
	return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t) {
	if ("object" != _typeof(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, "string");
		if ("object" != _typeof(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t);
}
function _slicedToArray(arr, i) {
	return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit(r, l) {
	var t = null == r ? null : r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a = [], f = true, o = false;
		try {
			{
				i = (t = t.call(r)).next;
				for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
			}
		} catch (r) {
			o = true, n = r;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a;
	}
}
function _arrayWithHoles(arr) {
	if (Array.isArray(arr)) return arr;
}
// TODO: isInvalidateDate with showTime.disabledTime should not provide `range` prop
/** Internal usage. For cross function get same aligned props */
function Picker(props, ref) {
	// ========================= Prop =========================
	var _useFilledProps = useFilledProps(props), _useFilledProps2 = _slicedToArray(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
	var _ref = filledProps, prefixCls = _ref.prefixCls, rootClassName = _ref.rootClassName, propStyles = _ref.styles, propClassNames = _ref.classNames, previewValue = _ref.previewValue, order = _ref.order, defaultValue = _ref.defaultValue, value = _ref.value, needConfirm = _ref.needConfirm, onChange = _ref.onChange, onKeyDown = _ref.onKeyDown, disabled = _ref.disabled, disabledDate = _ref.disabledDate, minDate = _ref.minDate, maxDate = _ref.maxDate, defaultOpen = _ref.defaultOpen, open = _ref.open, onOpenChange = _ref.onOpenChange, locale = _ref.locale, generateConfig = _ref.generateConfig, picker = _ref.picker, showNow = _ref.showNow, showToday = _ref.showToday, showTime = _ref.showTime, mode = _ref.mode, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, onOk = _ref.onOk, multiple = _ref.multiple, defaultPickerValue = _ref.defaultPickerValue, pickerValue = _ref.pickerValue, onPickerValueChange = _ref.onPickerValueChange, inputReadOnly = _ref.inputReadOnly, suffixIcon = _ref.suffixIcon, removeIcon = _ref.removeIcon, onFocus = _ref.onFocus, onBlur = _ref.onBlur, presets = _ref.presets, components = _ref.components, cellRender = _ref.cellRender, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, onClick = _ref.onClick;
	// ========================= Refs =========================
	var selectorRef = usePickerRef(ref);
	// ========================= Util =========================
	function pickerParam(values) {
		if (values === null) {
			return null;
		}
		return multiple ? values : values[0];
	}
	var toggleDates = useToggleDates(generateConfig, locale, internalPicker);
	// ======================= Semantic =======================
	var _useSemantic = useSemantic(propClassNames, propStyles), _useSemantic2 = _slicedToArray(_useSemantic, 2), mergedClassNames = _useSemantic2[0], mergedStyles = _useSemantic2[1];
	// ========================= Open =========================
	var _useOpen = useOpen(open, defaultOpen, [disabled], onOpenChange), _useOpen2 = _slicedToArray(_useOpen, 2), mergedOpen = _useOpen2[0], triggerOpen = _useOpen2[1];
	// ======================= Calendar =======================
	var onInternalCalendarChange = function(dates, dateStrings, info) {
		if (onCalendarChange) {
			var filteredInfo = _objectSpread({}, info);
			delete filteredInfo.range;
			onCalendarChange(pickerParam(dates), pickerParam(dateStrings), filteredInfo);
		}
	};
	var onInternalOk = function(dates) {
		onOk === null || onOk === void 0 || onOk(pickerParam(dates));
	};
	// ======================== Values ========================
	var _useInnerValue = useInnerValue(generateConfig, locale, formatList, false, order, defaultValue, value, onInternalCalendarChange, onInternalOk), _useInnerValue2 = _slicedToArray(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
	var calendarValue = getCalendarValue();
	// ======================== Active ========================
	// In SinglePicker, we will always get `activeIndex` is 0.
	var _useRangeActive = useRangeActive([disabled]), _useRangeActive2 = _slicedToArray(_useRangeActive, 4), focused = _useRangeActive2[0], triggerFocus = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3];
	var onSharedFocus = function(event) {
		triggerFocus(true);
		onFocus === null || onFocus === void 0 || onFocus(event, {});
	};
	var onSharedBlur = function(event) {
		triggerFocus(false);
		onBlur === null || onBlur === void 0 || onBlur(event, {});
	};
	// ========================= Mode =========================
	var _useControlledState = useControlledState(picker, mode), _useControlledState2 = _slicedToArray(_useControlledState, 2), mergedMode = _useControlledState2[0], setMode = _useControlledState2[1];
	/** Extends from `mergedMode` to patch `datetime` mode */
	var internalMode = mergedMode === "date" && showTime ? "datetime" : mergedMode;
	// ======================= Show Now =======================
	var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday);
	// ======================== Value =========================
	var onInternalChange = onChange && function(dates, dateStrings) {
		onChange(pickerParam(dates), pickerParam(dateStrings));
	};
	var _useRangeValue = useRangeValue(
		_objectSpread(_objectSpread({}, filledProps), {}, { onChange: onInternalChange }),
		mergedValue,
		setInnerValue,
		getCalendarValue,
		triggerCalendarChange,
		[],
		//disabled,
		formatList,
		focused,
		mergedOpen,
		isInvalidateDate
	), _useRangeValue2 = _slicedToArray(_useRangeValue, 2), triggerSubmitChange = _useRangeValue2[1];
	// ======================= Validate =======================
	var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate), _useFieldsInvalidate2 = _slicedToArray(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
	var submitInvalidate = reactExports.useMemo(function() {
		return submitInvalidates.some(function(invalidated) {
			return invalidated;
		});
	}, [submitInvalidates]);
	// ===================== Picker Value =====================
	// Proxy to single pickerValue
	var onInternalPickerValueChange = function(dates, info) {
		if (onPickerValueChange) {
			var cleanInfo = _objectSpread(_objectSpread({}, info), {}, { mode: info.mode[0] });
			delete cleanInfo.range;
			onPickerValueChange(dates[0], cleanInfo);
		}
	};
	var _useRangePickerValue = useRangePickerValue(
		generateConfig,
		locale,
		calendarValue,
		[mergedMode],
		mergedOpen,
		activeIndex,
		internalPicker,
		false,
		// multiplePanel,
		defaultPickerValue,
		pickerValue,
		toArray(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue),
		onInternalPickerValueChange,
		minDate,
		maxDate
	), _useRangePickerValue2 = _slicedToArray(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
	// >>> Mode need wait for `pickerValue`
	var triggerModeChange = useEvent(function(nextPickerValue, nextMode, triggerEvent) {
		setMode(nextMode);
		// Compatible with `onPanelChange`
		if (onPanelChange && triggerEvent !== false) {
			var lastPickerValue = nextPickerValue || calendarValue[calendarValue.length - 1];
			onPanelChange(lastPickerValue, nextMode);
		}
	});
	// ======================== Submit ========================
	/**
	* Different with RangePicker, confirm should check `multiple` logic.
	* This will never provide `date` instead.
	*/
	var triggerConfirm = function() {
		triggerSubmitChange(getCalendarValue());
		triggerOpen(false, { force: true });
	};
	// ======================== Click =========================
	var onSelectorClick = function(event) {
		if (!disabled && !selectorRef.current.nativeElement.contains(document.activeElement)) {
			// Click to focus the enabled input
			selectorRef.current.focus();
		}
		triggerOpen(true);
		onClick === null || onClick === void 0 || onClick(event);
	};
	var onSelectorClear = function() {
		triggerSubmitChange(null);
		triggerOpen(false, { force: true });
	};
	// ======================== Hover =========================
	var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
	var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), internalHoverValue = _React$useState4[0], setInternalHoverValue = _React$useState4[1];
	var hoverValues = reactExports.useMemo(function() {
		var values = [internalHoverValue].concat(_toConsumableArray(calendarValue)).filter(function(date) {
			return date;
		});
		return multiple ? values : values.slice(0, 1);
	}, [
		calendarValue,
		internalHoverValue,
		multiple
	]);
	// Selector values is different with RangePicker
	// which can not use `hoverValue` directly
	var selectorValues = reactExports.useMemo(function() {
		if (!multiple && internalHoverValue) {
			return [internalHoverValue];
		}
		return calendarValue.filter(function(date) {
			return date;
		});
	}, [
		calendarValue,
		internalHoverValue,
		multiple
	]);
	// Clean up `internalHoverValues` when closed
	reactExports.useEffect(function() {
		if (!mergedOpen) {
			setInternalHoverValue(null);
		}
	}, [mergedOpen]);
	var onSetHover = function(date, source) {
		if (previewValue !== "hover") {
			return;
		}
		setInternalHoverValue(date);
		setHoverSource(source);
	};
	// ========================================================
	// ==                       Panels                       ==
	// ========================================================
	// ======================= Presets ========================
	var presetList = usePresets(presets);
	var onPresetHover = function(nextValue) {
		onSetHover(nextValue, "preset");
	};
	// TODO: handle this
	var onPresetSubmit = function(nextValue) {
		var nextCalendarValues = multiple ? toggleDates(getCalendarValue(), nextValue) : [nextValue];
		var passed = triggerSubmitChange(nextCalendarValues);
		if (passed && !multiple) {
			triggerOpen(false, { force: true });
		}
	};
	var onNow = function(now) {
		onPresetSubmit(now);
	};
	// ======================== Panel =========================
	var onPanelHover = function(date) {
		onSetHover(date, "cell");
	};
	// >>> Focus
	var onPanelFocus = function(event) {
		triggerOpen(true);
		onSharedFocus(event);
	};
	// >>> Calendar
	var onPanelSelect = function(date) {
		lastOperation("panel");
		// Not change values if multiple and current panel is to match with picker
		if (multiple && internalMode !== picker) {
			return;
		}
		var nextValues = multiple ? toggleDates(getCalendarValue(), date) : [date];
		// Only trigger calendar event but not update internal `calendarValue` state
		triggerCalendarChange(nextValues);
		// >>> Trigger next active if !needConfirm
		// Fully logic check `useRangeValue` hook
		if (!needConfirm && !complexPicker && internalPicker === internalMode) {
			triggerConfirm();
		}
	};
	// >>> Close
	var onPopupClose = function() {
		// Close popup
		triggerOpen(false);
	};
	// >>> cellRender
	var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
	// >>> invalid
	var panelProps = reactExports.useMemo(function() {
		var domProps = pickAttrs(filledProps, false);
		var restProps = omit(filledProps, [].concat(_toConsumableArray(Object.keys(domProps)), [
			"onChange",
			"onCalendarChange",
			"style",
			"className",
			"onPanelChange",
			"classNames",
			"styles"
		]));
		return _objectSpread(_objectSpread({}, restProps), {}, { multiple: filledProps.multiple });
	}, [filledProps]);
	// >>> Render
	var panel = reactExports.createElement(Popup, _extends$3({}, panelProps, {
		showNow: mergedShowNow,
		showTime,
		disabledDate,
		onFocus: onPanelFocus,
		onBlur: onSharedBlur,
		picker,
		mode: mergedMode,
		internalMode,
		onPanelChange: triggerModeChange,
		format: maskFormat,
		value: calendarValue,
		isInvalid: isInvalidateDate,
		onChange: null,
		onSelect: onPanelSelect,
		pickerValue: currentPickerValue,
		defaultOpenValue: showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue,
		onPickerValueChange: setCurrentPickerValue,
		hoverValue: hoverValues,
		onHover: onPanelHover,
		needConfirm,
		onSubmit: triggerConfirm,
		onOk: triggerOk,
		presets: presetList,
		onPresetHover,
		onPresetSubmit,
		onNow,
		cellRender: onInternalCellRender,
		classNames: mergedClassNames,
		styles: mergedStyles
	}));
	// ========================================================
	// ==                      Selector                      ==
	// ========================================================
	// ======================== Change ========================
	var onSelectorChange = function(date) {
		triggerCalendarChange(date);
	};
	var onSelectorInputChange = function() {
		lastOperation("input");
	};
	// ======================= Selector =======================
	var onSelectorFocus = function(event) {
		lastOperation("input");
		triggerOpen(true, { inherit: true });
		// setActiveIndex(index);
		onSharedFocus(event);
	};
	var onSelectorBlur = function(event) {
		triggerOpen(false);
		onSharedBlur(event);
	};
	var onSelectorKeyDown = function(event, preventDefault) {
		if (event.key === "Tab") {
			triggerConfirm();
		}
		onKeyDown === null || onKeyDown === void 0 || onKeyDown(event, preventDefault);
	};
	// ======================= Context ========================
	var context = reactExports.useMemo(function() {
		return {
			prefixCls,
			locale,
			generateConfig,
			button: components.button,
			input: components.input,
			classNames: mergedClassNames,
			styles: mergedStyles
		};
	}, [
		prefixCls,
		locale,
		generateConfig,
		components.button,
		components.input,
		mergedClassNames,
		mergedStyles
	]);
	// ======================== Effect ========================
	// >>> Mode
	// Reset for every active
	useLayoutEffect(function() {
		if (mergedOpen && activeIndex !== void 0) {
			// Legacy compatible. This effect update should not trigger `onPanelChange`
			triggerModeChange(null, picker, false);
		}
	}, [
		mergedOpen,
		activeIndex,
		picker
	]);
	// >>> For complex picker, we need check if need to focus next one
	useLayoutEffect(function() {
		var lastOp = lastOperation();
		// Trade as confirm on field leave
		if (!mergedOpen && lastOp === "input") {
			triggerOpen(false);
			triggerConfirm();
		}
		// Submit with complex picker
		if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
			triggerConfirm();
		}
	}, [mergedOpen]);
	// ======================== Render ========================
	return reactExports.createElement(PickerContext$1.Provider, { value: context }, reactExports.createElement(PickerTrigger, _extends$3({}, pickTriggerProps(filledProps), {
		popupElement: panel,
		popupStyle: mergedStyles.popup.root,
		popupClassName: clsx(rootClassName, mergedClassNames.popup.root),
		visible: mergedOpen,
		onClose: onPopupClose
	}), reactExports.createElement(SingleSelector$1, _extends$3({}, filledProps, {
		ref: selectorRef,
		className: clsx(filledProps.className, rootClassName, mergedClassNames.root),
		style: _objectSpread(_objectSpread({}, mergedStyles.root), filledProps.style),
		suffixIcon,
		removeIcon,
		activeHelp: !!internalHoverValue,
		allHelp: !!internalHoverValue && hoverSource === "preset",
		focused,
		onFocus: onSelectorFocus,
		onBlur: onSelectorBlur,
		onKeyDown: onSelectorKeyDown,
		onSubmit: triggerConfirm,
		value: selectorValues,
		maskFormat,
		onChange: onSelectorChange,
		onInputChange: onSelectorInputChange,
		internalPicker,
		format: formatList,
		inputReadOnly,
		disabled,
		open: mergedOpen,
		onOpenChange: triggerOpen,
		onClick: onSelectorClick,
		onClear: onSelectorClear,
		invalid: submitInvalidate,
		onInvalid: function(invalid) {
			// Only `single` mode support type date.
			// `multiple` mode can not typing.
			onSelectorInvalid(invalid, 0);
		}
	}))));
}
var RefPicker = reactExports.forwardRef(Picker);
var Picker$1 = RefPicker;
function initInputToken(token) {
	return merge(token, { inputAffixPadding: token.paddingXXS });
}
const initComponentToken = (token) => {
	const { controlHeight, fontSize, lineHeight, lineWidth, controlHeightSM, controlHeightLG, fontSizeLG, lineHeightLG, paddingSM, controlPaddingHorizontalSM, controlPaddingHorizontal, colorFillAlter, colorPrimaryHover, colorPrimary, controlOutlineWidth, controlOutline, colorErrorOutline, colorWarningOutline, colorBgContainer, inputFontSize, inputFontSizeLG, inputFontSizeSM } = token;
	const mergedFontSize = inputFontSize || fontSize;
	const mergedFontSizeSM = inputFontSizeSM || mergedFontSize;
	const mergedFontSizeLG = inputFontSizeLG || fontSizeLG;
	const paddingBlock = Math.round((controlHeight - mergedFontSize * lineHeight) / 2 * 10) / 10 - lineWidth;
	const paddingBlockSM = Math.round((controlHeightSM - mergedFontSizeSM * lineHeight) / 2 * 10) / 10 - lineWidth;
	const paddingBlockLG = Math.ceil((controlHeightLG - mergedFontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth;
	return {
		paddingBlock: Math.max(paddingBlock, 0),
		paddingBlockSM: Math.max(paddingBlockSM, 0),
		paddingBlockLG: Math.max(paddingBlockLG, 0),
		paddingInline: paddingSM - lineWidth,
		paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
		paddingInlineLG: controlPaddingHorizontal - lineWidth,
		addonBg: colorFillAlter,
		activeBorderColor: colorPrimary,
		hoverBorderColor: colorPrimaryHover,
		activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
		errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
		warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
		hoverBg: colorBgContainer,
		activeBg: colorBgContainer,
		inputFontSize: mergedFontSize,
		inputFontSizeLG: mergedFontSizeLG,
		inputFontSizeSM: mergedFontSizeSM
	};
};
const genHoverStyle = (token) => ({
	borderColor: token.hoverBorderColor,
	backgroundColor: token.hoverBg
});
const genDisabledStyle = (token) => ({
	color: token.colorTextDisabled,
	backgroundColor: token.colorBgContainerDisabled,
	borderColor: token.colorBorder,
	boxShadow: "none",
	cursor: "not-allowed",
	opacity: 1,
	"input[disabled], textarea[disabled]": { cursor: "not-allowed" },
	"&:hover:not([disabled])": { ...genHoverStyle(merge(token, {
		hoverBorderColor: token.colorBorder,
		hoverBg: token.colorBgContainerDisabled
	})) }
});
/* ============== Outlined ============== */
const genBaseOutlinedStyle = (token, options) => ({
	background: token.colorBgContainer,
	borderWidth: token.lineWidth,
	borderStyle: token.lineType,
	borderColor: options.a,
	"&:hover": {
		borderColor: options.b,
		backgroundColor: token.hoverBg
	},
	"&:focus, &:focus-within": {
		borderColor: options.c,
		boxShadow: options.d,
		outline: 0,
		backgroundColor: token.activeBg
	}
});
const genOutlinedStatusStyle = (token, options) => ({
	[`&${token.componentCls}-status-${options.f}:not(${token.componentCls}-disabled)`]: {
		...genBaseOutlinedStyle(token, options),
		[`${token.componentCls}-prefix, ${token.componentCls}-suffix`]: { color: options.e }
	},
	[`&${token.componentCls}-status-${options.f}${token.componentCls}-disabled`]: { borderColor: options.a }
});
const genOutlinedStyle = (token) => ({ "&-outlined": {
	...genBaseOutlinedStyle(token, {
		a: token.colorBorder,
		b: token.hoverBorderColor,
		c: token.activeBorderColor,
		d: token.activeShadow
	}),
	[`&${token.componentCls}-disabled, &[disabled]`]: { ...genDisabledStyle(token) },
	...genOutlinedStatusStyle(token, {
		f: "error",
		a: token.colorError,
		b: token.colorErrorBorderHover,
		c: token.colorError,
		d: token.errorActiveShadow,
		e: token.colorError
	}),
	...genOutlinedStatusStyle(token, {
		f: "warning",
		a: token.colorWarning,
		b: token.colorWarningBorderHover,
		c: token.colorWarning,
		d: token.warningActiveShadow,
		e: token.colorWarning
	}),
	...void 0
} });
const genOutlinedGroupStatusStyle = (token, options) => ({ [`&${token.componentCls}-group-wrapper-status-${options.c}`]: { [`${token.componentCls}-group-addon`]: {
	borderColor: options.a,
	color: options.b
} } });
const genOutlinedGroupStyle = (token) => ({ "&-outlined": {
	[`${token.componentCls}-group`]: {
		"&-addon": {
			background: token.addonBg,
			border: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
		},
		"&-addon:first-child": { borderInlineEnd: 0 },
		"&-addon:last-child": { borderInlineStart: 0 }
	},
	...genOutlinedGroupStatusStyle(token, {
		c: "error",
		a: token.colorError,
		b: token.colorErrorText
	}),
	...genOutlinedGroupStatusStyle(token, {
		c: "warning",
		a: token.colorWarning,
		b: token.colorWarningText
	}),
	[`&${token.componentCls}-group-wrapper-disabled`]: { [`${token.componentCls}-group-addon`]: { ...genDisabledStyle(token) } }
} });
/* ============ Borderless ============ */
const genBorderlessStyle = (token) => {
	const { componentCls } = token;
	return { "&-borderless": {
		background: "transparent",
		border: "none",
		"&:focus, &:focus-within": { outline: "none" },
		[`&${componentCls}-disabled, &[disabled]`]: {
			color: token.colorTextDisabled,
			cursor: "not-allowed"
		},
		[`&${componentCls}-status-error`]: { "&, & input, & textarea": { color: token.colorError } },
		[`&${componentCls}-status-warning`]: { "&, & input, & textarea": { color: token.colorWarning } },
		...void 0
	} };
};
/* ============== Filled ============== */
const genBaseFilledStyle = (token, options) => ({
	background: options.a,
	borderWidth: token.lineWidth,
	borderStyle: token.lineType,
	borderColor: "transparent",
	"input&, & input, textarea&, & textarea": { color: options.b ?? "unset" },
	"&:hover": { background: options.c },
	"&:focus, &:focus-within": {
		outline: 0,
		borderColor: options.d,
		backgroundColor: token.activeBg
	}
});
const genFilledStatusStyle = (token, options) => ({ [`&${token.componentCls}-status-${options.f}:not(${token.componentCls}-disabled)`]: {
	...genBaseFilledStyle(token, options),
	[`${token.componentCls}-prefix, ${token.componentCls}-suffix`]: { color: options.e }
} });
const genFilledStyle = (token) => ({ "&-filled": {
	...genBaseFilledStyle(token, {
		a: token.colorFillTertiary,
		c: token.colorFillSecondary,
		d: token.activeBorderColor,
		b: token.colorText
	}),
	[`&${token.componentCls}-disabled, &[disabled]`]: { ...genDisabledStyle(token) },
	...genFilledStatusStyle(token, {
		f: "error",
		a: token.colorErrorBg,
		c: token.colorErrorBgHover,
		d: token.colorError,
		b: token.colorErrorText,
		e: token.colorError
	}),
	...genFilledStatusStyle(token, {
		f: "warning",
		a: token.colorWarningBg,
		c: token.colorWarningBgHover,
		d: token.colorWarning,
		b: token.colorWarningText,
		e: token.colorWarning
	}),
	...void 0
} });
const genFilledGroupStatusStyle = (token, options) => ({ [`&${token.componentCls}-group-wrapper-status-${options.c}`]: { [`${token.componentCls}-group-addon`]: {
	background: options.a,
	color: options.b
} } });
const genFilledGroupStyle = (token) => ({ "&-filled": {
	[`${token.componentCls}-group-addon`]: {
		background: token.colorFillTertiary,
		"&:last-child": { position: "static" }
	},
	...genFilledGroupStatusStyle(token, {
		c: "error",
		a: token.colorErrorBg,
		b: token.colorErrorText
	}),
	...genFilledGroupStatusStyle(token, {
		c: "warning",
		a: token.colorWarningBg,
		b: token.colorWarningText
	}),
	[`&${token.componentCls}-group-wrapper-disabled`]: { [`${token.componentCls}-group`]: {
		"&-addon": {
			background: token.colorFillTertiary,
			color: token.colorTextDisabled
		},
		"&-addon:first-child": {
			borderInlineStart: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
			borderTop: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
			borderBottom: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
		},
		"&-addon:last-child": {
			borderInlineEnd: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
			borderTop: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
			borderBottom: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
		}
	} }
} });
/* ============== Underlined ============== */
// https://github.com/ant-design/ant-design/issues/51379
const genBaseUnderlinedStyle = (token, options) => ({
	background: token.colorBgContainer,
	borderWidth: `${unit$1(token.lineWidth)} 0`,
	borderStyle: `${token.lineType} none`,
	borderColor: `transparent transparent ${options.a} transparent`,
	borderRadius: 0,
	"&:hover": {
		borderColor: `transparent transparent ${options.b} transparent`,
		backgroundColor: token.hoverBg
	},
	"&:focus, &:focus-within": {
		borderColor: `transparent transparent ${options.c} transparent`,
		outline: 0,
		backgroundColor: token.activeBg
	}
});
const genUnderlinedStatusStyle = (token, options) => ({
	[`&${token.componentCls}-status-${options.e}:not(${token.componentCls}-disabled)`]: {
		...genBaseUnderlinedStyle(token, options),
		[`${token.componentCls}-prefix, ${token.componentCls}-suffix`]: { color: options.d }
	},
	[`&${token.componentCls}-status-${options.e}${token.componentCls}-disabled`]: { borderColor: `transparent transparent ${options.a} transparent` }
});
const genUnderlinedStyle = (token) => ({ "&-underlined": {
	...genBaseUnderlinedStyle(token, {
		a: token.colorBorder,
		b: token.hoverBorderColor,
		c: token.activeBorderColor
	}),
	[`&${token.componentCls}-disabled, &[disabled]`]: {
		color: token.colorTextDisabled,
		boxShadow: "none",
		cursor: "not-allowed",
		"&:hover": { borderColor: `transparent transparent ${token.colorBorder} transparent` }
	},
	"input[disabled], textarea[disabled]": { cursor: "not-allowed" },
	...genUnderlinedStatusStyle(token, {
		e: "error",
		a: token.colorError,
		b: token.colorErrorBorderHover,
		c: token.colorError,
		d: token.colorError
	}),
	...genUnderlinedStatusStyle(token, {
		e: "warning",
		a: token.colorWarning,
		b: token.colorWarningBorderHover,
		c: token.colorWarning,
		d: token.colorWarning
	}),
	...void 0
} });
const genPlaceholderStyle = (color) => ({
	"&::-moz-placeholder": { opacity: 1 },
	"&::placeholder": {
		color,
		userSelect: "none"
	},
	"&:placeholder-shown": { textOverflow: "ellipsis" }
});
const genInputLargeStyle = (token) => {
	const { paddingBlockLG, lineHeightLG, borderRadiusLG, paddingInlineLG } = token;
	return {
		padding: `${unit$1(paddingBlockLG)} ${unit$1(paddingInlineLG)}`,
		fontSize: token.inputFontSizeLG,
		lineHeight: lineHeightLG,
		borderRadius: borderRadiusLG
	};
};
const genInputSmallStyle = (token) => ({
	padding: `${unit$1(token.paddingBlockSM)} ${unit$1(token.paddingInlineSM)}`,
	fontSize: token.inputFontSizeSM,
	borderRadius: token.borderRadiusSM
});
const genBasicInputStyle = (token) => ({
	position: "relative",
	display: "inline-block",
	width: "100%",
	minWidth: 0,
	padding: `${unit$1(token.paddingBlock)} ${unit$1(token.paddingInline)}`,
	color: token.colorText,
	fontSize: token.inputFontSize,
	lineHeight: token.lineHeight,
	borderRadius: token.borderRadius,
	transition: `all ${token.motionDurationMid}`,
	...genPlaceholderStyle(token.colorTextPlaceholder),
	"&-lg": {
		...genInputLargeStyle(token),
		...void 0
	},
	"&-sm": {
		...genInputSmallStyle(token),
		...void 0
	},
	"&-rtl, &-textarea-rtl": { direction: "rtl" }
});
const genInputGroupStyle = (token) => {
	const { componentCls, antCls } = token;
	return {
		position: "relative",
		display: "table",
		width: "100%",
		borderCollapse: "separate",
		borderSpacing: 0,
		"&[class*='col-']": {
			paddingInlineEnd: token.paddingXS,
			"&:last-child": { paddingInlineEnd: 0 }
		},
		[`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: { ...genInputLargeStyle(token) },
		[`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: { ...genInputSmallStyle(token) },
		[`&-lg ${antCls}-select-single`]: { height: token.controlHeightLG },
		[`&-sm ${antCls}-select-single`]: { height: token.controlHeightSM },
		[`> ${componentCls}`]: {
			display: "table-cell",
			"&:not(:first-child):not(:last-child)": { borderRadius: 0 }
		},
		[`${componentCls}-group`]: {
			"&-addon, &-wrap": {
				display: "table-cell",
				width: 1,
				whiteSpace: "nowrap",
				verticalAlign: "middle",
				"&:not(:first-child):not(:last-child)": { borderRadius: 0 }
			},
			"&-wrap > *": { display: "block !important" },
			"&-addon": {
				position: "relative",
				padding: `0 ${unit$1(token.paddingInline)}`,
				color: token.colorText,
				fontWeight: "normal",
				fontSize: token.inputFontSize,
				textAlign: "center",
				borderRadius: token.borderRadius,
				transition: `all ${token.motionDurationSlow}`,
				lineHeight: 1,
				[`${antCls}-select`]: {
					margin: `${unit$1(token.calc(token.paddingBlock).add(1).mul(-1).equal())} ${unit$1(token.calc(token.paddingInline).mul(-1).equal())}`,
					[`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
						backgroundColor: "inherit",
						border: `${unit$1(token.lineWidth)} ${token.lineType} transparent`,
						boxShadow: "none"
					}
				},
				[`${antCls}-cascader-picker`]: {
					margin: `-9px ${unit$1(token.calc(token.paddingInline).mul(-1).equal())}`,
					backgroundColor: "transparent",
					[`${antCls}-cascader-input`]: {
						textAlign: "start",
						border: 0,
						boxShadow: "none"
					}
				}
			}
		},
		[componentCls]: {
			width: "100%",
			marginBottom: 0,
			textAlign: "inherit",
			"&:focus": {
				zIndex: 1,
				borderInlineEndWidth: 1
			},
			"&:hover": {
				zIndex: 1,
				borderInlineEndWidth: 1
			}
		},
		[`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
			borderStartEndRadius: 0,
			borderEndEndRadius: 0,
			[`${antCls}-select`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			}
		},
		[`> ${componentCls}-affix-wrapper`]: {
			[`&:not(:first-child) ${componentCls}`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			},
			[`&:not(:last-child) ${componentCls}`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			}
		},
		[`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
			borderStartStartRadius: 0,
			borderEndStartRadius: 0,
			[`${antCls}-select`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			}
		},
		[`${componentCls}-affix-wrapper`]: {
			"&:not(:last-child)": {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			},
			"&:not(:first-child)": {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			}
		},
		[`&${componentCls}-group-compact`]: {
			display: "block",
			...clearFix(),
			[`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: { "&:not(:first-child):not(:last-child)": {
				borderInlineEndWidth: token.lineWidth,
				"&:hover, &:focus": { zIndex: 1 }
			} },
			"& > *": {
				display: "inline-flex",
				float: "none",
				verticalAlign: "top",
				borderRadius: 0
			},
			[`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: { display: "inline-flex" },
			"& > *:not(:last-child)": {
				marginInlineEnd: token.calc(token.lineWidth).mul(-1).equal(),
				borderInlineEndWidth: token.lineWidth
			},
			[componentCls]: { float: "none" },
			[`& > ${antCls}-select,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
				borderInlineEndWidth: token.lineWidth,
				borderRadius: 0,
				"&:hover, &:focus": { zIndex: 1 }
			},
			[`& > ${antCls}-select-focused`]: { zIndex: 1 },
			[`& > ${antCls}-select > ${antCls}-select-arrow`]: { zIndex: 1 },
			[`& > *:first-child,
      & > ${antCls}-select:first-child,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
				borderStartStartRadius: token.borderRadius,
				borderEndStartRadius: token.borderRadius
			},
			[`& > *:last-child,
      & > ${antCls}-select:last-child,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
				borderInlineEndWidth: token.lineWidth,
				borderStartEndRadius: token.borderRadius,
				borderEndEndRadius: token.borderRadius
			},
			[`& > ${antCls}-select-auto-complete ${componentCls}`]: { verticalAlign: "top" },
			[`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
				marginInlineStart: token.calc(token.lineWidth).mul(-1).equal(),
				[`${componentCls}-affix-wrapper`]: {}
			}
		}
	};
};
const genInputStyle = (token) => {
	const { componentCls, controlHeightSM, lineWidth, calc } = token;
	const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(16).div(2).equal();
	return { [componentCls]: {
		...resetComponent(token),
		...genBasicInputStyle(token),
		...genOutlinedStyle(token),
		...genFilledStyle(token),
		...genBorderlessStyle(token),
		...genUnderlinedStyle(token),
		"&[type=\"color\"]": {
			height: token.controlHeight,
			[`&${componentCls}-lg`]: { height: token.controlHeightLG },
			[`&${componentCls}-sm`]: {
				height: controlHeightSM,
				paddingTop: colorSmallPadding,
				paddingBottom: colorSmallPadding
			}
		},
		"&[type=\"search\"]::-webkit-search-cancel-button, &[type=\"search\"]::-webkit-search-decoration": { appearance: "none" }
	} };
};
const genAllowClearStyle = (token) => {
	const { componentCls } = token;
	return { [`${componentCls}-clear-icon`]: {
		margin: 0,
		padding: 0,
		lineHeight: 0,
		color: token.colorTextQuaternary,
		fontSize: token.fontSizeIcon,
		verticalAlign: -1,
		cursor: "pointer",
		transition: `color ${token.motionDurationSlow}`,
		border: "none",
		outline: "none",
		backgroundColor: "transparent",
		"&:hover": { color: token.colorIcon },
		"&:active": { color: token.colorText },
		"&-hidden": { visibility: "hidden" },
		"&-has-suffix": { margin: `0 ${unit$1(token.inputAffixPadding)}` }
	} };
};
const genAffixStyle = (token) => {
	const { componentCls, inputAffixPadding, colorTextDescription, motionDurationSlow, colorIcon, colorIconHover, iconCls } = token;
	const affixCls = `${componentCls}-affix-wrapper`;
	const affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
	return {
		[affixCls]: {
			...genBasicInputStyle(token),
			display: "inline-flex",
			"&-focused, &:focus": { zIndex: 1 },
			[`> input${componentCls}`]: { padding: 0 },
			[`> input${componentCls}, > textarea${componentCls}`]: {
				fontSize: "inherit",
				border: "none",
				borderRadius: 0,
				outline: "none",
				background: "transparent",
				color: "inherit",
				"&::-ms-reveal": { display: "none" },
				"&:focus": { boxShadow: "none !important" }
			},
			"&::before": {
				display: "inline-block",
				width: 0,
				visibility: "hidden",
				content: "\"\\a0\""
			},
			[componentCls]: {
				"&-prefix, &-suffix": {
					display: "flex",
					flex: "none",
					alignItems: "center",
					"> *:not(:last-child)": { marginInlineEnd: token.paddingXS }
				},
				"&-show-count-suffix": {
					color: colorTextDescription,
					direction: "ltr"
				},
				"&-show-count-has-suffix": { marginInlineEnd: token.paddingXXS },
				"&-prefix": { marginInlineEnd: inputAffixPadding },
				"&-suffix": { marginInlineStart: inputAffixPadding }
			},
			...genAllowClearStyle(token),
			[`${iconCls}${componentCls}-password-icon`]: {
				color: colorIcon,
				cursor: "pointer",
				transition: `all ${motionDurationSlow}`,
				"&:hover": { color: colorIconHover }
			}
		},
		[`${componentCls}-underlined`]: { borderRadius: 0 },
		[affixClsDisabled]: { [`${iconCls}${componentCls}-password-icon`]: {
			color: colorIcon,
			cursor: "not-allowed",
			"&:hover": { color: colorIcon }
		} }
	};
};
const genGroupStyle = (token) => {
	const { componentCls, borderRadiusLG, borderRadiusSM } = token;
	return { [`${componentCls}-group`]: {
		...resetComponent(token),
		...genInputGroupStyle(token),
		"&-rtl": { direction: "rtl" },
		"&-wrapper": {
			display: "inline-block",
			width: "100%",
			textAlign: "start",
			verticalAlign: "top",
			"&-rtl": { direction: "rtl" },
			"&-lg": { [`${componentCls}-group-addon`]: {
				borderRadius: borderRadiusLG,
				fontSize: token.inputFontSizeLG
			} },
			"&-sm": { [`${componentCls}-group-addon`]: { borderRadius: borderRadiusSM } },
			...genOutlinedGroupStyle(token),
			...genFilledGroupStyle(token),
			[`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: { borderRadius: 0 } },
			[`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			} },
			[`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			} },
			[`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: { [`${componentCls}-affix-wrapper`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			} },
			[`&:not(${componentCls}-compact-first-item)${componentCls}-compact-item`]: { [`${componentCls}-affix-wrapper`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			} }
		}
	} };
};
// ============================== Range ===============================
const genRangeStyle = (token) => {
	const { componentCls } = token;
	return { [`${componentCls}-out-of-range`]: { [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: { color: token.colorError } } };
};
// ============================== Export ==============================
genStyleHooks(["Input", "Shared"], (token) => {
	const inputToken = merge(token, initInputToken(token));
	return [genInputStyle(inputToken), genAffixStyle(inputToken)];
}, initComponentToken, { resetFont: false });
genStyleHooks(["Input", "Component"], (token) => {
	const inputToken = merge(token, initInputToken(token));
	return [
		genGroupStyle(inputToken),
		genRangeStyle(inputToken),
		genCompactItemStyle(inputToken, {
			focus: true,
			focusElCls: `${inputToken.componentCls}-affix-wrapper-focused`
		})
	];
}, initComponentToken, { resetFont: false });
/**
* Get multiple selector needed style. The calculation:
*
* ContainerPadding = BasePadding - ItemMargin
*
* Border:                                     
* ContainerPadding:                                                      
*                                            
* Item Margin:                                                          
*                                                           
* Item(multipleItemHeight):   BasePadding    Item       Overflow  Container(ControlHeight)
*                                                           
* Item Margin:                                                          
*                                            
* ContainerPadding:                                                      
* Border:                                     
*/
const getMultipleSelectorUnit = (token) => {
	const { multipleSelectItemHeight, paddingXXS, lineWidth, INTERNAL_FIXED_ITEM_MARGIN } = token;
	const basePadding = token.max(token.calc(paddingXXS).sub(lineWidth).equal(), 0);
	const containerPadding = token.max(token.calc(basePadding).sub(INTERNAL_FIXED_ITEM_MARGIN).equal(), 0);
	return {
		a: basePadding,
		b: containerPadding,
		c: unit$1(multipleSelectItemHeight),
		d: unit$1(token.calc(multipleSelectItemHeight).sub(token.calc(token.lineWidth).mul(2)).equal())
	};
};
/**
* Get the `@rc-component/overflow` needed style.
* It's a share style which means not affected by `size`.
*/
const genOverflowStyle = (token) => {
	const { componentCls, iconCls, borderRadiusSM, motionDurationSlow, paddingXS, multipleItemColorDisabled, multipleItemBorderColorDisabled, colorIcon, colorIconHover, INTERNAL_FIXED_ITEM_MARGIN } = token;
	const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
	return { [selectOverflowPrefixCls]: {
		position: "relative",
		display: "flex",
		flex: "auto",
		flexWrap: "wrap",
		maxWidth: "100%",
		"&-item": {
			flex: "none",
			alignSelf: "center",
			maxWidth: "calc(100% - 4px)",
			display: "inline-flex"
		},
		[`${componentCls}-selection-item`]: {
			display: "flex",
			alignSelf: "center",
			flex: "none",
			boxSizing: "border-box",
			maxWidth: "100%",
			marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
			borderRadius: borderRadiusSM,
			cursor: "default",
			transition: `font-size ${motionDurationSlow}, line-height ${motionDurationSlow}, height ${motionDurationSlow}`,
			marginInlineEnd: token.calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
			paddingInlineStart: paddingXS,
			paddingInlineEnd: token.calc(paddingXS).div(2).equal(),
			[`${componentCls}-disabled&`]: {
				color: multipleItemColorDisabled,
				borderColor: multipleItemBorderColorDisabled,
				cursor: "not-allowed"
			},
			"&-content": {
				display: "inline-block",
				marginInlineEnd: token.calc(paddingXS).div(2).equal(),
				overflow: "hidden",
				whiteSpace: "pre",
				textOverflow: "ellipsis"
			},
			"&-remove": {
				...resetIcon(),
				display: "inline-flex",
				alignItems: "center",
				color: colorIcon,
				fontWeight: "bold",
				fontSize: 10,
				lineHeight: "inherit",
				cursor: "pointer",
				[`> ${iconCls}`]: { verticalAlign: "-0.2em" },
				"&:hover": { color: colorIconHover }
			}
		}
	} };
};
const genSize = (token, suffix) => {
	const { componentCls, controlHeight } = token;
	const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
	const multipleSelectorUnit = getMultipleSelectorUnit(token);
	return [(
	// genSelectionStyle(token, suffix),
	{ [`${componentCls}-multiple${suffixCls}`]: {
		paddingBlock: multipleSelectorUnit.b,
		paddingInlineStart: multipleSelectorUnit.a,
		minHeight: controlHeight,
		[`${componentCls}-selection-item`]: {
			height: multipleSelectorUnit.c,
			lineHeight: unit$1(multipleSelectorUnit.d)
		}
	} })];
};
const genPickerMultipleStyle = (token) => {
	const { componentCls, calc, lineWidth } = token;
	const smallToken = merge(token, {
		fontHeight: token.fontSize,
		selectHeight: token.controlHeightSM,
		multipleSelectItemHeight: token.multipleItemHeightSM,
		borderRadius: token.borderRadiusSM,
		borderRadiusSM: token.borderRadiusXS,
		controlHeight: token.controlHeightSM
	});
	const largeToken = merge(token, {
		fontHeight: calc(token.multipleItemHeightLG).sub(calc(lineWidth).mul(2).equal()).equal(),
		fontSize: token.fontSizeLG,
		selectHeight: token.controlHeightLG,
		multipleSelectItemHeight: token.multipleItemHeightLG,
		borderRadius: token.borderRadiusLG,
		borderRadiusSM: token.borderRadius,
		controlHeight: token.controlHeightLG
	});
	return [
		genSize(smallToken, "small"),
		genSize(token),
		genSize(largeToken, "large"),
		(
		// ====================== Selection ======================
		{ [`${componentCls}${componentCls}-multiple`]: {
			width: "100%",
			cursor: "text",
			[`${componentCls}-selector`]: {
				flex: "auto",
				padding: 0,
				position: "relative",
				"&:after": { margin: 0 },
				[`${componentCls}-selection-placeholder`]: {
					position: "absolute",
					top: "50%",
					insetInlineStart: token.inputPaddingHorizontalBase,
					insetInlineEnd: 0,
					transform: "translateY(-50%)",
					transition: `all ${token.motionDurationSlow}`,
					overflow: "hidden",
					whiteSpace: "nowrap",
					textOverflow: "ellipsis",
					flex: 1,
					color: token.colorTextPlaceholder,
					pointerEvents: "none"
				}
			},
			...genOverflowStyle(token),
			[`${componentCls}-multiple-input`]: {
				width: 0,
				height: 0,
				border: 0,
				visibility: "hidden",
				position: "absolute",
				zIndex: -1
			}
		} })
	];
};
const genPickerCellInnerStyle = (token) => {
	const { pickerCellCls, pickerCellInnerCls, cellHeight, borderRadiusSM, motionDurationMid, cellHoverBg, lineWidth, lineType, colorPrimary, cellActiveWithRangeBg, colorTextLightSolid, colorTextDisabled, cellBgDisabled, colorFillSecondary } = token;
	return {
		"&::before": {
			position: "absolute",
			top: "50%",
			insetInlineStart: 0,
			insetInlineEnd: 0,
			zIndex: 1,
			height: cellHeight,
			transform: "translateY(-50%)",
			content: "\"\"",
			pointerEvents: "none"
		},
		[pickerCellInnerCls]: {
			position: "relative",
			zIndex: 2,
			display: "inline-block",
			minWidth: cellHeight,
			height: cellHeight,
			lineHeight: unit$1(cellHeight),
			borderRadius: borderRadiusSM,
			transition: `background-color ${motionDurationMid}`
		},
		[`&:hover:not(${pickerCellCls}-in-view):not(${pickerCellCls}-disabled),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-disabled)`]: { [pickerCellInnerCls]: { background: cellHoverBg } },
		[`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: { "&::before": {
			position: "absolute",
			top: 0,
			insetInlineEnd: 0,
			bottom: 0,
			insetInlineStart: 0,
			zIndex: 1,
			border: `${unit$1(lineWidth)} ${lineType} ${colorPrimary}`,
			borderRadius: borderRadiusSM,
			content: "\"\""
		} },
		[`&-in-view${pickerCellCls}-in-range,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
			position: "relative",
			[`&:not(${pickerCellCls}-disabled):before`]: { background: cellActiveWithRangeBg }
		},
		[`&-in-view${pickerCellCls}-selected,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
			[`&:not(${pickerCellCls}-disabled) ${pickerCellInnerCls}`]: {
				color: colorTextLightSolid,
				background: colorPrimary
			},
			[`&${pickerCellCls}-disabled ${pickerCellInnerCls}`]: { background: colorFillSecondary }
		},
		[`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-disabled):before`]: { insetInlineStart: "50%" },
		[`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-disabled):before`]: { insetInlineEnd: "50%" },
		[`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
			borderStartStartRadius: borderRadiusSM,
			borderEndStartRadius: borderRadiusSM,
			borderStartEndRadius: 0,
			borderEndEndRadius: 0
		},
		[`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
			borderStartStartRadius: 0,
			borderEndStartRadius: 0,
			borderStartEndRadius: borderRadiusSM,
			borderEndEndRadius: borderRadiusSM
		},
		"&-disabled": {
			color: colorTextDisabled,
			cursor: "not-allowed",
			[pickerCellInnerCls]: { background: "transparent" },
			"&::before": { background: cellBgDisabled }
		},
		[`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: { borderColor: colorTextDisabled }
	};
};
const genPanelStyle = (token) => {
	const { componentCls, pickerCellCls, pickerCellInnerCls, pickerYearMonthCellWidth, pickerControlIconSize, cellWidth, paddingSM, paddingXS, paddingXXS, colorBgContainer, lineWidth, lineType, borderRadiusLG, colorPrimary, colorTextHeading, colorSplit, pickerControlIconBorderWidth, colorIcon, textHeight, motionDurationMid, colorIconHover, fontWeightStrong, cellHeight, pickerCellPaddingVertical, colorTextDisabled, colorText, fontSize, motionDurationSlow, withoutTimeCellHeight, pickerQuarterPanelContentHeight, borderRadiusSM, colorTextLightSolid, cellHoverBg, timeColumnHeight, timeColumnWidth, timeCellHeight, controlItemBgActive, marginXXS, pickerDatePanelPaddingHorizontal, pickerControlIconMargin } = token;
	const pickerPanelWidth = token.calc(cellWidth).mul(7).add(token.calc(pickerDatePanelPaddingHorizontal).mul(2)).equal();
	return { [componentCls]: {
		"&-panel": {
			display: "inline-flex",
			flexDirection: "column",
			textAlign: "center",
			background: colorBgContainer,
			borderRadius: borderRadiusLG,
			outline: "none",
			"&-focused": { borderColor: colorPrimary },
			"&-rtl": {
				[`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: { transform: "rotate(45deg)" },
				[`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: { transform: "rotate(-135deg)" },
				[`${componentCls}-time-panel`]: { [`${componentCls}-content`]: {
					direction: "ltr",
					"> *": { direction: "rtl" }
				} }
			}
		},
		["&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel,\n        &-week-panel,\n        &-date-panel,\n        &-time-panel"]: {
			display: "flex",
			flexDirection: "column",
			width: pickerPanelWidth
		},
		"&-header": {
			display: "flex",
			padding: `0 ${unit$1(paddingXS)}`,
			color: colorTextHeading,
			borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
			"> *": { flex: "none" },
			button: {
				padding: 0,
				color: colorIcon,
				lineHeight: unit$1(textHeight),
				background: "transparent",
				border: 0,
				cursor: "pointer",
				transition: `color ${motionDurationMid}`,
				fontSize: "inherit",
				display: "inline-flex",
				alignItems: "center",
				justifyContent: "center",
				"&:empty": { display: "none" }
			},
			"> button": {
				minWidth: "1.6em",
				fontSize,
				"&:hover": { color: colorIconHover },
				"&:disabled": {
					opacity: .25,
					pointerEvents: "none"
				}
			},
			"&-view": {
				flex: "auto",
				fontWeight: fontWeightStrong,
				lineHeight: unit$1(textHeight),
				"> button": {
					color: "inherit",
					fontWeight: "inherit",
					verticalAlign: "top",
					"&:not(:first-child)": { marginInlineStart: paddingXS },
					"&:hover": { color: colorPrimary }
				}
			}
		},
		["&-prev-icon,\n        &-next-icon,\n        &-super-prev-icon,\n        &-super-next-icon"]: {
			position: "relative",
			width: pickerControlIconSize,
			height: pickerControlIconSize,
			"&::before": {
				position: "absolute",
				top: 0,
				insetInlineStart: 0,
				width: pickerControlIconSize,
				height: pickerControlIconSize,
				border: "0 solid currentcolor",
				borderBlockStartWidth: pickerControlIconBorderWidth,
				borderInlineStartWidth: pickerControlIconBorderWidth,
				content: "\"\""
			}
		},
		["&-super-prev-icon,\n        &-super-next-icon"]: { "&::after": {
			position: "absolute",
			top: pickerControlIconMargin,
			insetInlineStart: pickerControlIconMargin,
			display: "inline-block",
			width: pickerControlIconSize,
			height: pickerControlIconSize,
			border: "0 solid currentcolor",
			borderBlockStartWidth: pickerControlIconBorderWidth,
			borderInlineStartWidth: pickerControlIconBorderWidth,
			content: "\"\""
		} },
		"&-prev-icon, &-super-prev-icon": { transform: "rotate(-45deg)" },
		"&-next-icon, &-super-next-icon": { transform: "rotate(135deg)" },
		"&-content": {
			width: "100%",
			tableLayout: "fixed",
			borderCollapse: "collapse",
			"th, td": {
				position: "relative",
				minWidth: cellHeight,
				fontWeight: "normal"
			},
			th: {
				height: token.calc(cellHeight).add(token.calc(pickerCellPaddingVertical).mul(2)).equal(),
				color: colorText,
				verticalAlign: "middle"
			}
		},
		"&-cell": {
			padding: `${unit$1(pickerCellPaddingVertical)} 0`,
			color: colorTextDisabled,
			cursor: "pointer",
			"&-in-view": { color: colorText },
			...genPickerCellInnerStyle(token)
		},
		["&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel"]: {
			[`${componentCls}-content`]: { height: token.calc(withoutTimeCellHeight).mul(4).equal() },
			[pickerCellInnerCls]: { padding: `0 ${unit$1(paddingXS)}` }
		},
		"&-quarter-panel": { [`${componentCls}-content`]: { height: pickerQuarterPanelContentHeight } },
		"&-decade-panel": {
			[pickerCellInnerCls]: { padding: `0 ${unit$1(token.calc(paddingXS).div(2).equal())}` },
			[`${componentCls}-cell::before`]: { display: "none" }
		},
		["&-year-panel,\n        &-quarter-panel,\n        &-month-panel"]: {
			[`${componentCls}-body`]: { padding: `0 ${unit$1(paddingXS)}` },
			[pickerCellInnerCls]: { width: pickerYearMonthCellWidth }
		},
		"&-date-panel": {
			[`${componentCls}-body`]: { padding: `${unit$1(paddingXS)} ${unit$1(pickerDatePanelPaddingHorizontal)}` },
			[`${componentCls}-content th`]: {
				boxSizing: "border-box",
				padding: 0
			}
		},
		"&-week-panel-row": {
			td: {
				"&:before": { transition: `background-color ${motionDurationMid}` },
				"&:first-child:before": {
					borderStartStartRadius: borderRadiusSM,
					borderEndStartRadius: borderRadiusSM
				},
				"&:last-child:before": {
					borderStartEndRadius: borderRadiusSM,
					borderEndEndRadius: borderRadiusSM
				}
			},
			"&:hover td:before": { background: cellHoverBg },
			"&-range-start td, &-range-end td, &-selected td, &-hover td": { [`&${pickerCellCls}`]: {
				"&:before": { background: colorPrimary },
				[`&${componentCls}-cell-week`]: { color: new FastColor(colorTextLightSolid).setA(.5).toHexString() },
				[pickerCellInnerCls]: { color: colorTextLightSolid }
			} },
			"&-range-hover td:before": { background: controlItemBgActive }
		},
		"&-week-panel, &-date-panel-show-week": {
			[`${componentCls}-body`]: { padding: `${unit$1(paddingXS)} ${unit$1(paddingSM)}` },
			[`${componentCls}-content th`]: { width: "auto" }
		},
		"&-datetime-panel": {
			display: "flex",
			[`${componentCls}-time-panel`]: { borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorSplit}` },
			[`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: { transition: `opacity ${motionDurationSlow}` },
			"&-active": { [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
				opacity: .3,
				"&-active": { opacity: 1 }
			} }
		},
		"&-time-panel": {
			width: "auto",
			minWidth: "auto",
			[`${componentCls}-content`]: {
				display: "flex",
				flex: "auto",
				height: timeColumnHeight
			},
			"&-column": {
				flex: "1 0 auto",
				width: timeColumnWidth,
				margin: `${unit$1(paddingXXS)} 0`,
				padding: 0,
				overflowY: "hidden",
				textAlign: "start",
				listStyle: "none",
				transition: `background-color ${motionDurationMid}`,
				overflowX: "hidden",
				"&::-webkit-scrollbar": {
					width: 8,
					backgroundColor: "transparent"
				},
				"&::-webkit-scrollbar-thumb": {
					backgroundColor: token.colorTextTertiary,
					borderRadius: token.borderRadiusSM
				},
				"&": {
					scrollbarWidth: "thin",
					scrollbarColor: `${token.colorTextTertiary} transparent`
				},
				"&::after": {
					display: "block",
					height: `calc(100% - ${unit$1(timeCellHeight)})`,
					content: "\"\""
				},
				"&:not(:first-child)": { borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorSplit}` },
				"&-active": { background: new FastColor(controlItemBgActive).setA(.2).toHexString() },
				"&:hover": { overflowY: "auto" },
				"> li": {
					margin: 0,
					padding: 0,
					[`&${componentCls}-time-panel-cell`]: {
						marginInline: marginXXS,
						[`${componentCls}-time-panel-cell-inner`]: {
							display: "block",
							width: token.calc(timeColumnWidth).sub(token.calc(marginXXS).mul(2)).equal(),
							height: timeCellHeight,
							margin: 0,
							paddingBlock: 0,
							paddingInlineEnd: 0,
							paddingInlineStart: token.calc(timeColumnWidth).sub(timeCellHeight).div(2).equal(),
							color: colorText,
							lineHeight: unit$1(timeCellHeight),
							borderRadius: borderRadiusSM,
							cursor: "pointer",
							transition: `background-color ${motionDurationMid}`,
							"&:hover": { background: cellHoverBg }
						},
						"&-selected": { [`${componentCls}-time-panel-cell-inner`]: { background: controlItemBgActive } },
						"&-disabled": { [`${componentCls}-time-panel-cell-inner`]: {
							color: colorTextDisabled,
							background: "transparent",
							cursor: "not-allowed"
						} }
					}
				}
			}
		}
	} };
};
const genPickerPanelStyle = (token) => {
	const { componentCls, textHeight, lineWidth, paddingSM, antCls, colorPrimary, cellActiveWithRangeBg, colorPrimaryBorder, lineType, colorSplit } = token;
	return { [`${componentCls}-dropdown`]: {
		[`${componentCls}-footer`]: {
			borderTop: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
			"&-extra": {
				padding: `0 ${unit$1(paddingSM)}`,
				lineHeight: unit$1(token.calc(textHeight).sub(token.calc(lineWidth).mul(2)).equal()),
				textAlign: "start",
				"&:not(:last-child)": { borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}` }
			}
		},
		[`${componentCls}-panels + ${componentCls}-footer ${componentCls}-ranges`]: { justifyContent: "space-between" },
		[`${componentCls}-ranges`]: {
			marginBlock: 0,
			paddingInline: unit$1(paddingSM),
			overflow: "hidden",
			textAlign: "start",
			listStyle: "none",
			display: "flex",
			justifyContent: "center",
			alignItems: "center",
			"> li": {
				lineHeight: unit$1(token.calc(textHeight).sub(token.calc(lineWidth).mul(2)).equal()),
				display: "inline-block"
			},
			[`${componentCls}-now-btn-disabled`]: {
				pointerEvents: "none",
				color: token.colorTextDisabled
			},
			[`${componentCls}-preset > ${antCls}-tag-blue`]: {
				color: colorPrimary,
				background: cellActiveWithRangeBg,
				borderColor: colorPrimaryBorder,
				cursor: "pointer"
			},
			[`${componentCls}-ok`]: {
				paddingBlock: token.calc(lineWidth).mul(2).equal(),
				marginInlineStart: "auto"
			}
		}
	} };
};
const initPickerPanelToken = (token) => {
	const { componentCls, controlHeightLG, paddingXXS, padding } = token;
	return {
		pickerCellCls: `${componentCls}-cell`,
		pickerCellInnerCls: `${componentCls}-cell-inner`,
		pickerYearMonthCellWidth: token.calc(controlHeightLG).mul(1.5).equal(),
		pickerQuarterPanelContentHeight: token.calc(controlHeightLG).mul(1.4).equal(),
		pickerCellPaddingVertical: token.calc(paddingXXS).add(token.calc(paddingXXS).div(2)).equal(),
		pickerCellBorderGap: 2,
		pickerControlIconSize: 7,
		pickerControlIconMargin: 4,
		pickerControlIconBorderWidth: 1.5,
		pickerDatePanelPaddingHorizontal: token.calc(padding).add(token.calc(paddingXXS).div(2)).equal()
	};
};
const initPanelComponentToken = (token) => {
	const { colorBgContainerDisabled, controlHeight, controlHeightSM, controlHeightLG, paddingXXS, lineWidth } = token;
	// Item height default use `controlHeight - 2 * paddingXXS`,
	// but some case `paddingXXS=0`.
	// Let's fallback it.
	const dblPaddingXXS = paddingXXS * 2;
	const dblLineWidth = lineWidth * 2;
	const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
	const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
	const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
	// FIXED_ITEM_MARGIN is a hardcode calculation since calc not support rounding
	const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
	const filledToken = {
		INTERNAL_FIXED_ITEM_MARGIN,
		cellHoverBg: token.controlItemBgHover,
		cellActiveWithRangeBg: token.controlItemBgActive,
		cellHoverWithRangeBg: new FastColor(token.colorPrimary).lighten(35).toHexString(),
		cellRangeBorderColor: new FastColor(token.colorPrimary).lighten(20).toHexString(),
		cellBgDisabled: colorBgContainerDisabled,
		timeColumnWidth: controlHeightLG * 1.4,
		timeColumnHeight: 224,
		timeCellHeight: 28,
		cellWidth: controlHeightSM * 1.5,
		cellHeight: controlHeightSM,
		textHeight: controlHeightLG,
		withoutTimeCellHeight: controlHeightLG * 1.65,
		multipleItemBg: token.colorFillSecondary,
		multipleItemBorderColor: "transparent",
		multipleItemHeight,
		multipleItemHeightSM,
		multipleItemHeightLG,
		multipleSelectorBgDisabled: colorBgContainerDisabled,
		multipleItemColorDisabled: token.colorTextDisabled,
		multipleItemBorderColorDisabled: "transparent"
	};
	return filledToken;
};
const prepareComponentToken = (token) => ({
	...initComponentToken(token),
	...initPanelComponentToken(token),
	...getArrowToken(token),
	presetsWidth: 120,
	presetsMaxWidth: 200,
	zIndexPopup: token.zIndexPopupBase + 50
});
const genVariantsStyle = (token) => {
	const { componentCls } = token;
	return { [componentCls]: [{
		...genOutlinedStyle(token),
		...genUnderlinedStyle(token),
		...genFilledStyle(token),
		...genBorderlessStyle(token)
	}, (
	// ========================= Multiple =========================
	{
		"&-outlined": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token.multipleItemBg,
			border: `${unit$1(token.lineWidth)} ${token.lineType} ${token.multipleItemBorderColor}`
		} },
		"&-filled": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token.colorBgContainer,
			border: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
		} },
		"&-borderless": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token.multipleItemBg,
			border: `${unit$1(token.lineWidth)} ${token.lineType} ${token.multipleItemBorderColor}`
		} },
		"&-underlined": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token.multipleItemBg,
			border: `${unit$1(token.lineWidth)} ${token.lineType} ${token.multipleItemBorderColor}`
		} }
	})] };
};
const genPickerPadding = (paddingBlock, paddingInline) => {
	return { padding: `${unit$1(paddingBlock)} ${unit$1(paddingInline)}` };
};
const genPickerStatusStyle = (token) => {
	const { componentCls, colorError, colorWarning } = token;
	return { [`${componentCls}:not(${componentCls}-disabled):not([disabled])`]: {
		[`&${componentCls}-status-error`]: { [`${componentCls}-active-bar`]: { background: colorError } },
		[`&${componentCls}-status-warning`]: { [`${componentCls}-active-bar`]: { background: colorWarning } }
	} };
};
const genPickerStyle = (token) => {
	const { componentCls, antCls, paddingInline, lineWidth, lineType, colorBorder, borderRadius, motionDurationMid, colorTextDisabled, colorTextPlaceholder, colorTextQuaternary, fontSizeLG, inputFontSizeLG, fontSizeSM, inputFontSizeSM, controlHeightSM, paddingInlineSM, paddingXS, marginXS, colorIcon, lineWidthBold, colorPrimary, motionDurationSlow, zIndexPopup, paddingXXS, sizePopupArrow, colorBgElevated, borderRadiusLG, boxShadowSecondary, borderRadiusSM, colorSplit, cellHoverBg, presetsWidth, presetsMaxWidth, boxShadowPopoverArrow, fontHeight, lineHeightLG } = token;
	return [
		{ [componentCls]: {
			...resetComponent(token),
			...genPickerPadding(token.paddingBlock, token.paddingInline),
			position: "relative",
			display: "inline-flex",
			alignItems: "center",
			lineHeight: 1,
			borderRadius,
			transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}, background ${motionDurationMid}`,
			[`${componentCls}-prefix`]: {
				flex: "0 0 auto",
				marginInlineEnd: token.inputAffixPadding
			},
			[`${componentCls}-input`]: {
				position: "relative",
				display: "inline-flex",
				alignItems: "center",
				width: "100%",
				"> input": {
					position: "relative",
					display: "inline-block",
					width: "100%",
					color: "inherit",
					fontSize: token.inputFontSize ?? token.fontSize,
					lineHeight: token.lineHeight,
					transition: `all ${motionDurationMid}`,
					...genPlaceholderStyle(colorTextPlaceholder),
					flex: "auto",
					minWidth: 1,
					height: "auto",
					padding: 0,
					background: "transparent",
					border: 0,
					fontFamily: "inherit",
					"&:focus": {
						boxShadow: "none",
						outline: 0
					},
					"&[disabled]": {
						background: "transparent",
						color: colorTextDisabled,
						cursor: "not-allowed"
					}
				},
				"&-placeholder": { "> input": { color: colorTextPlaceholder } }
			},
			"&-large": {
				...genPickerPadding(token.paddingBlockLG, token.paddingInlineLG),
				borderRadius: token.borderRadiusLG,
				[`${componentCls}-input > input`]: {
					fontSize: inputFontSizeLG ?? fontSizeLG,
					lineHeight: lineHeightLG
				}
			},
			"&-small": {
				...genPickerPadding(token.paddingBlockSM, token.paddingInlineSM),
				borderRadius: token.borderRadiusSM,
				[`${componentCls}-input > input`]: { fontSize: inputFontSizeSM ?? fontSizeSM }
			},
			[`${componentCls}-suffix`]: {
				display: "flex",
				flex: "none",
				alignSelf: "center",
				marginInlineStart: token.calc(paddingXS).div(2).equal(),
				color: colorTextQuaternary,
				lineHeight: 1,
				pointerEvents: "none",
				transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
				"> *": {
					verticalAlign: "top",
					"&:not(:last-child)": { marginInlineEnd: marginXS }
				}
			},
			[`${componentCls}-clear`]: {
				position: "absolute",
				top: "50%",
				insetInlineEnd: 0,
				color: colorTextQuaternary,
				lineHeight: 1,
				transform: "translateY(-50%)",
				cursor: "pointer",
				opacity: 0,
				transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
				"> *": { verticalAlign: "top" },
				"&:hover": { color: colorIcon }
			},
			"&:hover": {
				[`${componentCls}-clear`]: { opacity: 1 },
				[`${componentCls}-suffix:not(:last-child)`]: { opacity: 0 }
			},
			[`${componentCls}-separator`]: {
				position: "relative",
				display: "inline-block",
				width: "1em",
				height: fontSizeLG,
				color: colorTextQuaternary,
				fontSize: fontSizeLG,
				verticalAlign: "top",
				cursor: "default",
				[`${componentCls}-focused &`]: { color: colorIcon },
				[`${componentCls}-range-separator &`]: { [`${componentCls}-disabled &`]: { cursor: "not-allowed" } }
			},
			"&-range": {
				position: "relative",
				display: "inline-flex",
				[`${componentCls}-active-bar`]: {
					bottom: token.calc(lineWidth).mul(-1).equal(),
					height: lineWidthBold,
					background: colorPrimary,
					opacity: 0,
					transition: `all ${motionDurationSlow} ease-out`,
					pointerEvents: "none"
				},
				[`&${componentCls}-focused`]: { [`${componentCls}-active-bar`]: { opacity: 1 } },
				[`${componentCls}-range-separator`]: {
					alignItems: "center",
					padding: `0 ${unit$1(paddingXS)}`,
					lineHeight: 1
				}
			},
			"&-range, &-multiple": {
				[`${componentCls}-clear`]: { insetInlineEnd: paddingInline },
				[`&${componentCls}-small`]: { [`${componentCls}-clear`]: { insetInlineEnd: paddingInlineSM } }
			},
			"&-dropdown": {
				...resetComponent(token),
				...genPanelStyle(token),
				pointerEvents: "none",
				position: "absolute",
				top: -9999,
				left: {
					_skip_check_: true,
					value: -9999
				},
				zIndex: zIndexPopup,
				[`&${componentCls}-dropdown-hidden`]: { display: "none" },
				"&-rtl": { direction: "rtl" },
				[`&${componentCls}-dropdown-placement-bottomLeft,
            &${componentCls}-dropdown-placement-bottomRight`]: { [`${componentCls}-range-arrow`]: {
					top: 0,
					display: "block",
					transform: "translateY(-100%)"
				} },
				[`&${componentCls}-dropdown-placement-topLeft,
            &${componentCls}-dropdown-placement-topRight`]: { [`${componentCls}-range-arrow`]: {
					bottom: 0,
					display: "block",
					transform: "translateY(100%) rotate(180deg)"
				} },
				[`&${antCls}-slide-up-appear, &${antCls}-slide-up-enter`]: { [`${componentCls}-range-arrow${componentCls}-range-arrow`]: { transition: "none" } },
				[`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: { animationName: slideDownIn },
				[`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: { animationName: slideUpIn },
				[`&${antCls}-slide-up-leave ${componentCls}-panel-container`]: { pointerEvents: "none" },
				[`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: { animationName: slideDownOut },
				[`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: { animationName: slideUpOut },
				[`${componentCls}-panel > ${componentCls}-time-panel`]: { paddingTop: paddingXXS },
				[`${componentCls}-range-wrapper`]: {
					display: "flex",
					position: "relative"
				},
				[`${componentCls}-range-arrow`]: {
					position: "absolute",
					zIndex: 1,
					display: "none",
					paddingInline: token.calc(paddingInline).mul(1.5).equal(),
					boxSizing: "content-box",
					transition: `all ${motionDurationSlow} ease-out`,
					...genRoundedArrow(token, colorBgElevated, boxShadowPopoverArrow),
					"&:before": { insetInlineStart: token.calc(paddingInline).mul(1.5).equal() }
				},
				[`${componentCls}-panel-container`]: {
					overflow: "hidden",
					verticalAlign: "top",
					background: colorBgElevated,
					borderRadius: borderRadiusLG,
					boxShadow: boxShadowSecondary,
					transition: `margin ${motionDurationSlow}`,
					display: "inline-block",
					pointerEvents: "auto",
					[`${componentCls}-panel-layout`]: {
						display: "flex",
						flexWrap: "nowrap",
						alignItems: "stretch"
					},
					[`${componentCls}-presets`]: {
						display: "flex",
						flexDirection: "column",
						minWidth: presetsWidth,
						maxWidth: presetsMaxWidth,
						ul: {
							height: 0,
							flex: "auto",
							listStyle: "none",
							overflow: "auto",
							margin: 0,
							padding: paddingXS,
							borderInlineEnd: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
							li: {
								...textEllipsis,
								borderRadius: borderRadiusSM,
								paddingInline: paddingXS,
								paddingBlock: token.calc(controlHeightSM).sub(fontHeight).div(2).equal(),
								cursor: "pointer",
								transition: `all ${motionDurationSlow}`,
								"+ li": { marginTop: marginXS },
								"&:hover": { background: cellHoverBg }
							}
						}
					},
					[`${componentCls}-panels`]: {
						display: "inline-flex",
						flexWrap: "nowrap",
						"&:last-child": { [`${componentCls}-panel`]: { borderWidth: 0 } }
					},
					[`${componentCls}-panel`]: {
						verticalAlign: "top",
						background: "transparent",
						borderRadius: 0,
						borderWidth: 0,
						[`${componentCls}-content, table`]: { textAlign: "center" },
						"&-focused": { borderColor: colorBorder }
					}
				}
			},
			"&-dropdown-range": {
				padding: `${unit$1(token.calc(sizePopupArrow).mul(2).div(3).equal())} 0`,
				"&-hidden": { display: "none" }
			},
			"&-rtl": {
				direction: "rtl",
				[`${componentCls}-separator`]: { transform: "scale(-1, 1)" },
				[`${componentCls}-footer`]: { "&-extra": { direction: "rtl" } }
			}
		} },
		initSlideMotion(token, "slide-up"),
		initSlideMotion(token, "slide-down"),
		initMoveMotion(token, "move-up"),
		initMoveMotion(token, "move-down")
	];
};
// ============================== Export ==============================
var useStyle = genStyleHooks("DatePicker", (token) => {
	const pickerToken = merge(initInputToken(token), initPickerPanelToken(token), {
		inputPaddingHorizontalBase: token.calc(token.paddingSM).sub(1).equal(),
		multipleSelectItemHeight: token.multipleItemHeight,
		selectHeight: token.controlHeight
	});
	return [
		genPickerPanelStyle(pickerToken),
		genPickerStyle(pickerToken),
		genVariantsStyle(pickerToken),
		genPickerStatusStyle(pickerToken),
		genPickerMultipleStyle(pickerToken),
		genCompactItemStyle(token, { focusElCls: `${token.componentCls}-focused` })
	];
}, prepareComponentToken);
// This icon file is generated automatically.
var SwapRightOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "0 0 1024 1024",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" }
		}]
	},
	"name": "swap-right",
	"theme": "outlined"
};
var SwapRightOutlinedSvg = SwapRightOutlined$1;
function _extends$2() {
	_extends$2 = Object.assign.bind();
	return _extends$2.apply(this, arguments);
}
const SwapRightOutlined = (props, ref) => reactExports.createElement(Icon$1, _extends$2({}, props, {
	ref,
	icon: SwapRightOutlinedSvg
}));
/**![swap-right](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg3My4xIDU5Ni4ybC0xNjQtMjA4QTMyIDMyIDAgMDA2ODQgMzc2aC02NC44Yy02LjcgMC0xMC40IDcuNy02LjMgMTNsMTQ0LjMgMTgzSDE1MmMtNC40IDAtOCAzLjYtOCA4djYwYzAgNC40IDMuNiA4IDggOGg2OTUuOWMyNi44IDAgNDEuNy0zMC44IDI1LjItNTEuOHoiIC8+PC9zdmc+) */
const RefIcon$2 = reactExports.forwardRef(SwapRightOutlined);
const useMergedPickerSemantic = (pickerType, classNames, styles, popupClassName, popupStyle, mergedProps) => {
	const { classNames: contextClassNames, styles: contextStyles } = useComponentConfig(pickerType);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, { popup: { _default: "root" } });
	return reactExports.useMemo(() => {
		// ClassNames
		const filledClassNames = {
			...mergedClassNames,
			popup: {
				...mergedClassNames.popup,
				root: clsx(mergedClassNames.popup?.root, popupClassName)
			}
		};
		// Styles
		const filledStyles = {
			...mergedStyles,
			popup: {
				...mergedStyles.popup,
				root: {
					...mergedStyles.popup?.root,
					...popupStyle
				}
			}
		};
		// Return
		return [filledClassNames, filledStyles];
	}, [
		mergedClassNames,
		mergedStyles,
		popupClassName,
		popupStyle
	]);
};
function getPlaceholder(locale, picker, customizePlaceholder) {
	if (customizePlaceholder !== void 0) {
		return customizePlaceholder;
	}
	if (picker === "year" && locale.lang.yearPlaceholder) {
		return locale.lang.yearPlaceholder;
	}
	if (picker === "quarter" && locale.lang.quarterPlaceholder) {
		return locale.lang.quarterPlaceholder;
	}
	if (picker === "month" && locale.lang.monthPlaceholder) {
		return locale.lang.monthPlaceholder;
	}
	if (picker === "week" && locale.lang.weekPlaceholder) {
		return locale.lang.weekPlaceholder;
	}
	if (picker === "time" && locale.timePickerLocale.placeholder) {
		return locale.timePickerLocale.placeholder;
	}
	return locale.lang.placeholder;
}
function getRangePlaceholder(locale, picker, customizePlaceholder) {
	if (customizePlaceholder !== void 0) {
		return customizePlaceholder;
	}
	if (picker === "year" && locale.lang.yearPlaceholder) {
		return locale.lang.rangeYearPlaceholder;
	}
	if (picker === "quarter" && locale.lang.quarterPlaceholder) {
		return locale.lang.rangeQuarterPlaceholder;
	}
	if (picker === "month" && locale.lang.monthPlaceholder) {
		return locale.lang.rangeMonthPlaceholder;
	}
	if (picker === "week" && locale.lang.weekPlaceholder) {
		return locale.lang.rangeWeekPlaceholder;
	}
	if (picker === "time" && locale.timePickerLocale.placeholder) {
		return locale.timePickerLocale.rangePlaceholder;
	}
	return locale.lang.rangePlaceholder;
}
function useIcons(props) {
	const { allowClear = true } = props;
	const { a: clearIcon, b: removeIcon } = useIcons$1({ ...props });
	const mergedAllowClear = reactExports.useMemo(() => {
		if (allowClear === false) {
			return false;
		}
		const allowClearConfig = allowClear === true ? {} : allowClear;
		return {
			clearIcon,
			...allowClearConfig
		};
	}, [allowClear, clearIcon]);
	return [mergedAllowClear, removeIcon];
}
const [, QUARTERPICKER] = [, "QuarterPicker"];
// This icon file is generated automatically.
var CalendarOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" }
		}]
	},
	"name": "calendar",
	"theme": "outlined"
};
var CalendarOutlinedSvg = CalendarOutlined$1;
function _extends$1() {
	_extends$1 = Object.assign.bind();
	return _extends$1.apply(this, arguments);
}
const CalendarOutlined = (props, ref) => reactExports.createElement(Icon$1, _extends$1({}, props, {
	ref,
	icon: CalendarOutlinedSvg
}));
/**![calendar](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg4MCAxODRINzEydi02NGMwLTQuNC0zLjYtOC04LThoLTU2Yy00LjQgMC04IDMuNi04IDh2NjRIMzg0di02NGMwLTQuNC0zLjYtOC04LThoLTU2Yy00LjQgMC04IDMuNi04IDh2NjRIMTQ0Yy0xNy43IDAtMzIgMTQuMy0zMiAzMnY2NjRjMCAxNy43IDE0LjMgMzIgMzIgMzJoNzM2YzE3LjcgMCAzMi0xNC4zIDMyLTMyVjIxNmMwLTE3LjctMTQuMy0zMi0zMi0zMnptLTQwIDY1NkgxODRWNDYwaDY1NnYzODB6TTE4NCAzOTJWMjU2aDEyOHY0OGMwIDQuNCAzLjYgOCA4IDhoNTZjNC40IDAgOC0zLjYgOC04di00OGgyNTZ2NDhjMCA0LjQgMy42IDggOCA4aDU2YzQuNCAwIDgtMy42IDgtOHYtNDhoMTI4djEzNkgxODR6IiAvPjwvc3ZnPg==) */
const RefIcon$1 = reactExports.forwardRef(CalendarOutlined);
// This icon file is generated automatically.
var ClockCircleOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" }
		}]
	},
	"name": "clock-circle",
	"theme": "outlined"
};
var ClockCircleOutlinedSvg = ClockCircleOutlined$1;
function _extends() {
	_extends = Object.assign.bind();
	return _extends.apply(this, arguments);
}
const ClockCircleOutlined = (props, ref) => reactExports.createElement(Icon$1, _extends({}, props, {
	ref,
	icon: ClockCircleOutlinedSvg
}));
/**![clock-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0wIDgyMGMtMjA1LjQgMC0zNzItMTY2LjYtMzcyLTM3MnMxNjYuNi0zNzIgMzcyLTM3MiAzNzIgMTY2LjYgMzcyIDM3Mi0xNjYuNiAzNzItMzcyIDM3MnoiIC8+PHBhdGggZD0iTTY4Ni43IDYzOC42TDU0NC4xIDUzNS41VjI4OGMwLTQuNC0zLjYtOC04LThINDg4Yy00LjQgMC04IDMuNi04IDh2Mjc1LjRjMCAyLjYgMS4yIDUgMy4zIDYuNWwxNjUuNCAxMjAuNmMzLjYgMi42IDguNiAxLjggMTEuMi0xLjdsMjguNi0zOWMyLjYtMy43IDEuOC04LjctMS44LTExLjJ6IiAvPjwvc3ZnPg==) */
const RefIcon = reactExports.forwardRef(ClockCircleOutlined);
const useSuffixIcon = ({ a: picker, b: hasFeedback, c: feedbackIcon, d: suffixIcon }) => {
	if (suffixIcon === null || suffixIcon === false) {
		return null;
	}
	if (suffixIcon === true || suffixIcon === void 0) {
		return React.createElement(React.Fragment, null, picker === "time" ? React.createElement(RefIcon, null) : React.createElement(RefIcon$1, null), hasFeedback && feedbackIcon);
	}
	return suffixIcon;
};
const PickerButton = (props) => reactExports.createElement(Button, {
	size: "small",
	type: "primary",
	...props
});
function useComponents(components) {
	return reactExports.useMemo(() => ({
		button: PickerButton,
		...components
	}), [components]);
}
const generateRangePicker = (generateConfig) => {
	const RangePicker = reactExports.forwardRef((props, ref) => {
		const { prefixCls: customizePrefixCls, getPopupContainer: customGetPopupContainer, components, className, style, classNames, styles, placement, size: customizeSize, disabled: customDisabled, bordered = true, placeholder, status: customStatus, variant: customVariant, picker, dropdownClassName, popupClassName, popupStyle, rootClassName, suffixIcon, ...restProps } = props;
		const pickerType = picker === "time" ? "timePicker" : "datePicker";
		const [mergedClassNames, mergedStyles] = useMergedPickerSemantic(pickerType, classNames, styles, popupClassName || dropdownClassName, popupStyle);
		const innerRef = reactExports.useRef(null);
		const { getPrefixCls, direction, getPopupContainer, rangePicker } = reactExports.useContext(ConfigContext);
		const prefixCls = getPrefixCls("picker", customizePrefixCls);
		const { a: compactSize, b: compactItemClassnames } = useCompactItemContext(prefixCls, direction);
		const rootPrefixCls = getPrefixCls();
		const [variant, enableVariantCls] = useVariant("rangePicker", customVariant, bordered);
		const rootCls = useCSSVarCls(prefixCls);
		const [hashId, cssVarCls] = useStyle(prefixCls, rootCls);
		const mergedRootClassName = clsx(hashId, cssVarCls, rootCls, rootClassName);
		// ===================== Icon =====================
		const [mergedAllowClear] = useIcons(props);
		// ================== components ==================
		const mergedComponents = useComponents(components);
		// ===================== Size =====================
		const mergedSize = useSize((ctx) => customizeSize ?? compactSize ?? ctx);
		// ===================== Disabled =====================
		const disabled = reactExports.useContext(DisabledContext);
		const mergedDisabled = customDisabled ?? disabled;
		// ===================== FormItemInput =====================
		const formItemContext = reactExports.useContext(FormItemInputContext);
		const { hasFeedback, status: contextStatus, feedbackIcon } = formItemContext;
		const mergedSuffixIcon = useSuffixIcon({
			a: picker,
			b: hasFeedback,
			c: feedbackIcon,
			d: suffixIcon
		});
		reactExports.useImperativeHandle(ref, () => innerRef.current);
		const [contextLocale] = useLocale$1("Calendar", locale);
		const locale$1 = merge$1(contextLocale, props.locale || {});
		// ============================ zIndex ============================
		const [zIndex] = useZIndex(0, mergedStyles?.popup?.root?.zIndex);
		return reactExports.createElement(ContextIsolator, { space: true }, reactExports.createElement(RCRangePicker, {
			separator: reactExports.createElement("span", {
				"aria-label": "to",
				className: `${prefixCls}-separator`
			}, reactExports.createElement(RefIcon$2, null)),
			disabled: mergedDisabled,
			ref: innerRef,
			placement,
			placeholder: getRangePlaceholder(locale$1, picker, placeholder),
			suffixIcon: mergedSuffixIcon,
			prevIcon: reactExports.createElement("span", { className: `${prefixCls}-prev-icon` }),
			nextIcon: reactExports.createElement("span", { className: `${prefixCls}-next-icon` }),
			superPrevIcon: reactExports.createElement("span", { className: `${prefixCls}-super-prev-icon` }),
			superNextIcon: reactExports.createElement("span", { className: `${prefixCls}-super-next-icon` }),
			transitionName: `${rootPrefixCls}-slide-up`,
			picker,
			...restProps,
			locale: locale$1.lang,
			getPopupContainer: customGetPopupContainer || getPopupContainer,
			generateConfig,
			components: mergedComponents,
			direction,
			prefixCls,
			rootClassName: mergedRootClassName,
			className: clsx({
				[`${prefixCls}-${mergedSize}`]: mergedSize,
				[`${prefixCls}-${variant}`]: enableVariantCls
			}, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), compactItemClassnames, className, rangePicker?.className),
			style: {
				...rangePicker?.style,
				...style
			},
			classNames: mergedClassNames,
			styles: {
				...mergedStyles,
				popup: {
					...mergedStyles.popup,
					root: {
						...mergedStyles.popup.root,
						zIndex
					}
				}
			},
			allowClear: mergedAllowClear
		}));
	});
	return RangePicker;
};
const generatePicker$1 = (generateConfig) => {
	const getPicker = (picker, displayName) => {
		const pickerType = displayName === "TimePicker" ? "timePicker" : "datePicker";
		const Picker = reactExports.forwardRef((props, ref) => {
			const { prefixCls: customizePrefixCls, getPopupContainer: customizeGetPopupContainer, components, style, className, size: customizeSize, bordered, placement, placeholder, disabled: customDisabled, status: customStatus, variant: customVariant, onCalendarChange, classNames, styles, dropdownClassName, popupClassName, popupStyle, rootClassName, suffixIcon, ...restProps } = props;
			const { getPrefixCls, direction, getPopupContainer, [pickerType]: contextPickerConfig } = reactExports.useContext(ConfigContext);
			const prefixCls = getPrefixCls("picker", customizePrefixCls);
			// ===================== Size =====================
			const { a: compactSize, b: compactItemClassnames } = useCompactItemContext(prefixCls, direction);
			const mergedSize = useSize((ctx) => customizeSize ?? compactSize ?? ctx);
			// ===================== Disabled =====================
			const disabled = reactExports.useContext(DisabledContext);
			const mergedDisabled = customDisabled ?? disabled;
			// =========== Merged Props for Semantic ===========
			const mergedProps = {
				...props,
				size: mergedSize,
				disabled: mergedDisabled,
				status: customStatus,
				variant: customVariant
			};
			// ========================= Style ==========================
			// Use original useMergedPickerSemantic for proper popup handling
			const [mergedClassNames, mergedStyles] = useMergedPickerSemantic(pickerType, classNames, styles, popupClassName || dropdownClassName, popupStyle, mergedProps);
			const innerRef = reactExports.useRef(null);
			const [variant, enableVariantCls] = useVariant("datePicker", customVariant, bordered);
			const rootCls = useCSSVarCls(prefixCls);
			const [hashId, cssVarCls] = useStyle(prefixCls, rootCls);
			const mergedRootClassName = clsx(hashId, cssVarCls, rootCls, rootClassName);
			reactExports.useImperativeHandle(ref, () => innerRef.current);
			const additionalProps = { showToday: true };
			const mergedPicker = picker || props.picker;
			const rootPrefixCls = getPrefixCls();
			// ==================== Legacy =====================
			const { onSelect, multiple } = restProps;
			const hasLegacyOnSelect = onSelect && picker === "time" && !multiple;
			const onInternalCalendarChange = (date, dateStr, info) => {
				onCalendarChange?.(date, dateStr, info);
				if (hasLegacyOnSelect) {
					onSelect(date);
				}
			};
			// ===================== Icon =====================
			const [mergedAllowClear, removeIcon] = useIcons(props);
			// ================== components ==================
			const mergedComponents = useComponents(components);
			// ===================== FormItemInput =====================
			const formItemContext = reactExports.useContext(FormItemInputContext);
			const { hasFeedback, status: contextStatus, feedbackIcon } = formItemContext;
			const mergedSuffixIcon = useSuffixIcon({
				a: mergedPicker,
				b: hasFeedback,
				c: feedbackIcon,
				d: suffixIcon
			});
			const [contextLocale] = useLocale$1("DatePicker", locale);
			const locale$1 = merge$1(contextLocale, props.locale || {});
			// ============================ zIndex ============================
			const [zIndex] = useZIndex(0, mergedStyles?.popup?.root?.zIndex);
			return reactExports.createElement(ContextIsolator, { space: true }, reactExports.createElement(Picker$1, {
				ref: innerRef,
				placeholder: getPlaceholder(locale$1, mergedPicker, placeholder),
				suffixIcon: mergedSuffixIcon,
				placement,
				prevIcon: reactExports.createElement("span", { className: `${prefixCls}-prev-icon` }),
				nextIcon: reactExports.createElement("span", { className: `${prefixCls}-next-icon` }),
				superPrevIcon: reactExports.createElement("span", { className: `${prefixCls}-super-prev-icon` }),
				superNextIcon: reactExports.createElement("span", { className: `${prefixCls}-super-next-icon` }),
				transitionName: `${rootPrefixCls}-slide-up`,
				picker,
				onCalendarChange: onInternalCalendarChange,
				...additionalProps,
				...restProps,
				locale: locale$1.lang,
				getPopupContainer: customizeGetPopupContainer || getPopupContainer,
				generateConfig,
				components: mergedComponents,
				direction,
				disabled: mergedDisabled,
				prefixCls,
				rootClassName: mergedRootClassName,
				className: clsx({
					[`${prefixCls}-${mergedSize}`]: mergedSize,
					[`${prefixCls}-${variant}`]: enableVariantCls
				}, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), compactItemClassnames, contextPickerConfig?.className, className),
				style: {
					...contextPickerConfig?.style,
					...style
				},
				classNames: mergedClassNames,
				styles: {
					...mergedStyles,
					popup: {
						...mergedStyles.popup,
						root: {
							...mergedStyles.popup.root,
							zIndex
						}
					}
				},
				allowClear: mergedAllowClear,
				removeIcon
			}));
		});
		return Picker;
	};
	const DatePicker = getPicker();
	const WeekPicker = getPicker("week", "WeekPicker");
	const MonthPicker = getPicker("month", "MonthPicker");
	const YearPicker = getPicker("year", "YearPicker");
	const QuarterPicker = getPicker("quarter", QUARTERPICKER);
	const TimePicker = getPicker("time", "TimePicker");
	return {
		a: DatePicker,
		b: WeekPicker,
		c: MonthPicker,
		d: YearPicker,
		e: TimePicker,
		f: QuarterPicker
	};
};
const generatePicker = (generateConfig) => {
	// =========================== Picker ===========================
	const { a: DatePicker, b: WeekPicker, c: MonthPicker, d: YearPicker, e: TimePicker, f: QuarterPicker } = generatePicker$1(generateConfig);
	// ======================== Range Picker ========================
	const RangePicker = generateRangePicker(generateConfig);
	const MergedDatePicker = DatePicker;
	MergedDatePicker.WeekPicker = WeekPicker;
	MergedDatePicker.MonthPicker = MonthPicker;
	MergedDatePicker.YearPicker = YearPicker;
	MergedDatePicker.RangePicker = RangePicker;
	MergedDatePicker.TimePicker = TimePicker;
	MergedDatePicker.QuarterPicker = QuarterPicker;
	return MergedDatePicker;
};
const DatePicker = generatePicker(dayjsGenerateConfig);
// We don't care debug panel
/* istanbul ignore next */
const PurePanel = genPurePanel(DatePicker);
DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
const PureRangePanel = genPurePanel(DatePicker.RangePicker);
DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PureRangePanel;
DatePicker.generatePicker = generatePicker;
var jsxRuntime = {};
var reactJsxRuntime_production = {};
function requireReactJsxRuntime_production() {
	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
	function jsxProd(type, config, maybeKey) {
		if ("key" in config) {
			maybeKey = {};
			for (var propName in config) maybeKey[propName] = config[propName];
		} else maybeKey = config;
		return {
			$$typeof: REACT_ELEMENT_TYPE,
			type,
			key: null,
			ref: null,
			props: maybeKey
		};
	}
	reactJsxRuntime_production.b = jsxProd;
	return reactJsxRuntime_production;
}
function requireJsxRuntime() {
	{
		jsxRuntime.a = requireReactJsxRuntime_production();
	}
	return jsxRuntime.a;
}
var jsxRuntimeExports = requireJsxRuntime();
const container = document.getElementById("root");
const root = ReactDOM.a(container);
root.render(jsxRuntimeExports.b(React.StrictMode, { children: jsxRuntimeExports.b(DatePicker, {}) }));
